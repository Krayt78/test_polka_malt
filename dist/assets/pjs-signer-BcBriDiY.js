import{t as i,S as T,c as M,a as f,u as S,O as C,B as A,f as x,A as H,b as I,d as O,e as v,g as B}from"./index-DyB_aecY.js";const u=(e,s)=>{let t=e.toString(16);t=(t.length%2?"0":"")+t;const o=Math.max(0,(s||0)-t.length/2);return"0x"+"00".repeat(o)+t},V=({additionalSigned:e})=>({genesisHash:i(e)}),_=({value:e})=>({nonce:u(f.dec(e),4)}),W=({additionalSigned:e})=>({transactionVersion:u(S.dec(e),4)}),$=T({tip:f,asset:C(A(1/0))}).dec,K=({value:e})=>{const{tip:s,asset:t}=$(e);return{...t?{assetId:i(t)}:{},tip:u(s,16)}},N=({value:e})=>({tip:u(M.dec(e),16)}),R=({value:e,additionalSigned:s},t)=>({era:i(e),blockHash:i(s),blockNumber:u(t,4)}),z=({additionalSigned:e})=>({specVersion:u(S.dec(e),4)}),F=({value:e,additionalSigned:s})=>e.length&&e[0]?{mode:1,metadataHash:i(s.length?s.slice(1):s)}:{},P=Object.freeze(Object.defineProperty({__proto__:null,ChargeAssetTxPayment:K,ChargeTransactionPayment:N,CheckGenesis:V,CheckMetadataHash:F,CheckMortality:R,CheckNonce:_,CheckSpecVersion:z,CheckTxVersion:W},Symbol.toStringTag,{value:"Module"})),G=H().enc,J=e=>e.startsWith("0x")?x(e):G(e);function U(e,s,t){const o=r=>t({address:e,data:i(r),type:"bytes"}).then(({signature:a})=>x(a)),h=J(e);return{publicKey:h,signTx:async(r,a,g,y,b=I)=>{const c=O(v(g)),n={};n.signedExtensions=[];const{version:w}=c.extrinsic,k=[];c.extrinsic.signedExtensions.map(({identifier:d})=>{const l=a[d];if(!l)throw new Error(`Missing ${d} signed-extension`);if(k.push(l.value),n.signedExtensions.push(d),!P[d]){if(l.value.length===0&&l.additionalSigned.length===0)return;throw new Error(`PJS does not support this signed-extension: ${d}`)}Object.assign(n,P[d](l,y))});const E=w.includes(4)?4:null;if(E==null)throw new Error("Only extrinsic v4 is supported");n.address=e,n.method=i(r),n.version=E,n.withSignedTransaction=!0;const j=await s(n),p=j.signedTransaction;return p?typeof p=="string"?x(p):p:B(c,h,x(j.signature),k,r)},signBytes:o}}const q=new Set(["ed25519","sr25519","ecdsa","ethereum"]),L=async(e,s)=>{var b;let t=(b=window.injectedWeb3)==null?void 0:b[e];if(!t)throw new Error(`Unavailable extension: "${e}"`);const o=await t.enable(s),h=o.signer.signPayload.bind(o.signer),m=o.signer.signRaw.bind(o.signer),r=c=>c.filter(({type:n})=>q.has(n)).map(n=>{const w=U(n.address,h,m);return{...n,polkadotSigner:w}});let a=r(await o.accounts.get());const g=new Set,y=o.accounts.subscribe(c=>{a=r(c),g.forEach(n=>{n(a)})});return{name:e,getAccounts:()=>a,subscribe:c=>(g.add(c),()=>{g.delete(c)}),disconnect:()=>{y()}}},Q=()=>{const{injectedWeb3:e}=window;return e?Object.keys(e):[]};export{L as connectInjectedExtension,Q as getInjectedExtensions,U as getPolkadotSignerFromPjs};
