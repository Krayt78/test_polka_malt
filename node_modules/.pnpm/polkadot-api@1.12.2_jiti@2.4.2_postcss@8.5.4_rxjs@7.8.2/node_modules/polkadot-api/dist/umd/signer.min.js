(function(Se,De){typeof exports=="object"&&typeof module<"u"?De(exports):typeof define=="function"&&define.amd?define(["exports"],De):(Se=typeof globalThis<"u"?globalThis:Se||self,De(Se.papiSigner={}))})(this,function(Se){"use strict";const De="0123456789abcdef";function oe(e){const t=new Array(e.length+1);t[0]="0x";for(let n=0;n<e.length;){const s=e[n++];t[n]=De[s>>4]+De[s&15]}return t.join("")}const gt={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function Le(e){const t=e.length%2,n=(e[1]==="x"?2:0)+t,s=(e.length-n)/2+t,r=new Uint8Array(s);t&&(r[0]=0|gt[e[2]]);for(let o=0;o<s;){const i=n+o*2,c=gt[e[i]],h=gt[e[i+1]];r[t+o++]=c<<4|h}return r}function vt(e,t){return Object.fromEntries(Object.entries(e).map(([n,s])=>[n,t(s,n)]))}const Y=(...e)=>{const t=e.reduce((s,r)=>s+r.byteLength,0),n=new Uint8Array(t);for(let s=0,r=0;s<e.length;s++){const o=e[s];n.set(o,r),r+=o.byteLength}return n};var Rr=Object.defineProperty,Fr=(e,t,n)=>t in e?Rr(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,qt=(e,t,n)=>(Fr(e,typeof t!="symbol"?t+"":t,n),n),mt={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function qr(e){const t=e.length%2,n=(e[1]==="x"?2:0)+t,s=(e.length-n)/2+t,r=new Uint8Array(s);t&&(r[0]=0|mt[e[2]]);for(let o=0;o<s;){const i=n+o*2,c=mt[e[i]],h=mt[e[i+1]];r[t+o++]=c<<4|h}return r}var jt=class extends Uint8Array{constructor(e){super(e),qt(this,"i",0),qt(this,"v"),this.v=new DataView(e)}},J=e=>t=>e(t instanceof jt?t:new jt(t instanceof Uint8Array?t.buffer:typeof t=="string"?qr(t).buffer:t)),ne=e=>{const t=e.length;let n=0;for(let r=0;r<t;r++)n+=e[r].length;const s=new Uint8Array(n);for(let r=0,o=0;r<t;r++){const i=e[r];s.set(i,o),o+=i.byteLength}return s};function Qe(e,t){const n=Object.keys(e),s=n.length,r={};for(let o=0;o<s;o++){const i=n[o];r[i]=t(e[i],i)}return r}var Ze=J,T=(e,t)=>{const n=[e,t];return n.enc=e,n.dec=t,n},et=(e,t)=>n=>e(t(n)),tt=(e,t)=>n=>t(e(n)),ie=([e,t],n,s)=>T(et(e,n),tt(t,s));function jr(e,t){return J(n=>{const s=n.v[t](n.i,!0);return n.i+=e,s})}function Kr(e,t){return n=>{const s=new Uint8Array(e);return new DataView(s.buffer)[t](0,n,!0),s}}function ye(e,t,n){return T(Kr(e,n),jr(e,t))}var B=ye(1,"getUint8","setUint8"),ge=ye(2,"getUint16","setUint16"),Q=ye(4,"getUint32","setUint32"),He=ye(8,"getBigUint64","setBigUint64"),Kt=ye(1,"getInt8","setInt8"),Xt=ye(2,"getInt16","setInt16"),Wt=ye(4,"getInt32","setInt32"),zt=ye(8,"getBigInt64","setBigInt64"),Gt=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigInt64(0,e,!0),n.setBigInt64(8,e>>64n,!0),t},Yt=e=>J(t=>{const{v:n,i:s}=t,r=n.getBigUint64(s,!0),o=n[e](s+8,!0);return t.i+=16,o<<64n|r}),Jt=T(Gt,Yt("getBigUint64")),Qt=T(Gt,Yt("getBigInt64")),Zt=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigInt64(0,e,!0),n.setBigInt64(8,e>>64n,!0),n.setBigInt64(16,e>>128n,!0),n.setBigInt64(24,e>>192n,!0),t},en=e=>J(t=>{let n=t.v.getBigUint64(t.i,!0);return t.i+=8,n|=t.v.getBigUint64(t.i,!0)<<64n,t.i+=8,n|=t.v.getBigUint64(t.i,!0)<<128n,t.i+=8,n|=t.v[e](t.i,!0)<<192n,t.i+=8,n}),tn=T(Zt,en("getBigUint64")),nn=T(Zt,en("getBigInt64")),rn=ie(B,e=>e?1:0,Boolean),Xr=[B[1],ge[1],Q[1]],Wr=J(e=>{const t=e[e.i],n=t&3;if(n<3)return Xr[n](e)>>>2;const s=(t>>>2)+4;e.i++;let r=0n;const o=s/8|0;let i=0n;for(let h=0;h<o;h++)r=He[1](e)<<i|r,i+=64n;let c=s%8;return c>3&&(r=BigInt(Q[1](e))<<i|r,i+=32n,c-=4),c>1&&(r=BigInt(ge[1](e))<<i|r,i+=16n,c-=2),c&&(r=BigInt(B[1](e))<<i|r),r}),zr=1n<<56n,Gr=1<<24,Yr=256,Jr=4294967295n,Qr=64,Zr=16384,es=1<<30,ts=e=>{if(e<0)throw new Error(`Wrong compact input (${e})`);const t=Number(e)<<2;if(e<Qr)return B[0](t);if(e<Zr)return ge[0](t|1);if(e<es)return Q[0](t|2);let n=[new Uint8Array(1)],s=BigInt(e);for(;s>=zr;)n.push(He[0](s)),s>>=64n;s>=Gr&&(n.push(Q[0](Number(s&Jr))),s>>=32n);let r=Number(s);r>=Yr&&(n.push(ge[0](r)),r>>=16),r&&n.push(B[0](r));const o=ne(n);return o[0]=o.length-5<<2|3,o},D=T(ts,Wr),ns=new TextEncoder,rs=e=>{const t=ns.encode(e);return ne([D.enc(t.length),t])},ss=new TextDecoder,os=J(e=>{let t=D.dec(e);const n=new DataView(e.buffer,e.i,t);return e.i+=t,ss.decode(n)}),k=T(rs,os),is=()=>{},cs=new Uint8Array(0),v=T(()=>cs,is),sn=e=>e===void 0?t=>ne([D.enc(t.length),t]):t=>t.length===e?t:t.slice(0,e),on=e=>J(t=>{const n=e===void 0?D.dec(t):e!==1/0?e:t.byteLength-t.i,s=new Uint8Array(t.buffer.slice(t.i,t.i+n));return t.i+=n,s}),H=e=>T(sn(e),on(e));H.enc=sn,H.dec=on;var cn=(e,t)=>{const n=Object.keys(e),s=new Map(t?.map((o,i)=>[n[i],o])??n.map((o,i)=>[o,i])),r=o=>s.get(o);return({tag:o,value:i})=>ne([B.enc(r(o)),e[o](i)])},an=(e,t)=>{const n=Object.keys(e),s=new Map(t?.map((r,o)=>[r,n[o]])??n.map((r,o)=>[o,r]));return J(r=>{const o=B.dec(r),i=s.get(o),c=e[i];return{tag:i,value:c(r)}})},j=(e,...t)=>T(cn(Qe(e,([n])=>n),...t),an(Qe(e,([,n])=>n),...t));j.enc=cn,j.dec=an;var ln=e=>J(t=>B[1](t)>0?e(t):void 0),un=e=>t=>{const n=new Uint8Array(1);return t===void 0?n:(n[0]=1,ne([n,e(t)]))},K=e=>T(un(e[0]),ln(e[1]));K.enc=un,K.dec=ln;var hn=(e,t)=>J(n=>{const s=B[1](n)===0,o=(s?e:t)(n);return{success:s,value:o}}),dn=(e,t)=>({success:n,value:s})=>ne([B[0](n?0:1),(n?e:t)(s)]),Ne=(e,t)=>T(dn(e[0],t[0]),hn(e[1],t[1]));Ne.dec=hn,Ne.enc=dn;var fn=(...e)=>J(t=>e.map(n=>n(t))),pn=(...e)=>t=>ne(e.map((n,s)=>n(t[s]))),Z=(...e)=>T(pn(...e.map(([t])=>t)),fn(...e.map(([,t])=>t)));Z.enc=pn,Z.dec=fn;var yn=e=>{const t=Object.keys(e);return et(Z.enc(...Object.values(e)),n=>t.map(s=>n[s]))},gn=e=>{const t=Object.keys(e);return tt(Z.dec(...Object.values(e)),n=>Object.fromEntries(n.map((s,r)=>[t[r],s])))},b=e=>T(yn(Qe(e,t=>t[0])),gn(Qe(e,t=>t[1])));b.enc=yn,b.dec=gn;var vn=(e,t)=>t>=0?n=>ne(n.map(e)):n=>ne([D.enc(n.length),ne(n.map(e))]),mn=(e,t)=>J(n=>{const s=t>=0?t:D.dec(n),r=new Array(s);for(let o=0;o<s;o++)r[o]=e(n);return r}),I=(e,t)=>T(vn(e[0],t),mn(e[1],t));I.enc=vn,I.dec=mn;/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function as(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function wn(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(n=>typeof n=="string"):t.every(n=>Number.isSafeInteger(n)):!1}function wt(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function bn(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function bt(e){if(!Array.isArray(e))throw new Error("array expected")}function xn(e,t){if(!wn(!0,t))throw new Error(`${e}: array of strings expected`)}function ls(e,t){if(!wn(!1,t))throw new Error(`${e}: array of numbers expected`)}function us(...e){const t=o=>o,n=(o,i)=>c=>o(i(c)),s=e.map(o=>o.encode).reduceRight(n,t),r=e.map(o=>o.decode).reduce(n,t);return{encode:s,decode:r}}function hs(e){const t=typeof e=="string"?e.split(""):e,n=t.length;xn("alphabet",t);const s=new Map(t.map((r,o)=>[r,o]));return{encode:r=>(bt(r),r.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${e}`);return t[o]})),decode:r=>(bt(r),r.map(o=>{wt("alphabet.decode",o);const i=s.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${e}`);return i}))}}function ds(e=""){return wt("join",e),{encode:t=>(xn("join.decode",t),t.join(e)),decode:t=>(wt("join.decode",t),t.split(e))}}function En(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(bt(e),!e.length)return[];let s=0;const r=[],o=Array.from(e,c=>{if(bn(c),c<0||c>=t)throw new Error(`invalid integer: ${c}`);return c}),i=o.length;for(;;){let c=0,h=!0;for(let l=s;l<i;l++){const d=o[l],y=t*c,a=y+d;if(!Number.isSafeInteger(a)||y/t!==c||a-d!==y)throw new Error("convertRadix: carry overflow");const u=a/n;c=a%n;const p=Math.floor(u);if(o[l]=p,!Number.isSafeInteger(p)||p*n+c!==a)throw new Error("convertRadix: carry overflow");if(h)p?h=!1:s=l;else continue}if(r.push(c),h)break}for(let c=0;c<e.length-1&&e[c]===0;c++)r.push(0);return r.reverse()}function fs(e){bn(e);const t=2**8;return{encode:n=>{if(!as(n))throw new Error("radix.encode input should be Uint8Array");return En(Array.from(n),t,e)},decode:n=>(ls("radix.decode",n),Uint8Array.from(En(n,e,t)))}}const In=(e=>us(fs(58),hs(e),ds("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ps(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Me(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function ke(e,...t){if(!ps(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Re(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function xt(e,t){ke(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function ys(e){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}function Ae(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function ve(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function nt(e,t){return e<<32-t|e>>>t}const kn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function An(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}const ce=kn?e=>e:e=>An(e);function gs(e){for(let t=0;t<e.length;t++)e[t]=An(e[t]);return e}const F=kn?e=>e:gs;function vs(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function re(e){return typeof e=="string"&&(e=vs(e)),ke(e),e}class Bn{}function ms(e){const t=s=>e().update(re(s)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function ws(e){const t=(s,r)=>e(r).update(re(s)).digest(),n=e({});return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=s=>e(s),t}function bs(e){const t=(s,r)=>e(r).update(re(s)).digest(),n=e({});return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=s=>e(s),t}const xs=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9]);function me(e,t,n,s,r){return e=e+t+r|0,s=nt(s^e,16),n=n+s|0,t=nt(t^n,12),{a:e,b:t,c:n,d:s}}function we(e,t,n,s,r){return e=e+t+r|0,s=nt(s^e,8),n=n+s|0,t=nt(t^n,7),{a:e,b:t,c:n,d:s}}const Es=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),rt=BigInt(2**32-1),Un=BigInt(32);function st(e,t=!1){return t?{h:Number(e&rt),l:Number(e>>Un&rt)}:{h:Number(e>>Un&rt)|0,l:Number(e&rt)|0}}function Is(e,t=!1){const n=e.length;let s=new Uint32Array(n),r=new Uint32Array(n);for(let o=0;o<n;o++){const{h:i,l:c}=st(e[o],t);[s[o],r[o]]=[i,c]}return[s,r]}const _n=(e,t,n)=>e>>>n|t<<32-n,On=(e,t,n)=>e<<32-n|t>>>n,ks=(e,t,n)=>e<<64-n|t>>>n-32,As=(e,t,n)=>e>>>n-32|t<<64-n,Bs=(e,t)=>t,Us=(e,t)=>e,_s=(e,t,n)=>e<<n|t>>>32-n,Os=(e,t,n)=>t<<n|e>>>32-n,Ts=(e,t,n)=>t<<n-32|e>>>64-n,Ss=(e,t,n)=>e<<n-32|t>>>64-n;function Tn(e,t,n,s){const r=(t>>>0)+(s>>>0);return{h:e+n+(r/2**32|0)|0,l:r|0}}const Sn=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),Dn=(e,t,n,s)=>t+n+s+(e/2**32|0)|0,M=Uint32Array.from([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),g=new Uint32Array(32);function be(e,t,n,s,r,o){const i=r[o],c=r[o+1];let h=g[2*e],l=g[2*e+1],d=g[2*t],y=g[2*t+1],a=g[2*n],u=g[2*n+1],p=g[2*s],f=g[2*s+1],m=Sn(h,d,i);l=Dn(m,l,y,c),h=m|0,{Dh:f,Dl:p}={Dh:f^l,Dl:p^h},{Dh:f,Dl:p}={Dh:Bs(f,p),Dl:Us(f)},{h:u,l:a}=Tn(u,a,f,p),{Bh:y,Bl:d}={Bh:y^u,Bl:d^a},{Bh:y,Bl:d}={Bh:_n(y,d,24),Bl:On(y,d,24)},g[2*e]=h,g[2*e+1]=l,g[2*t]=d,g[2*t+1]=y,g[2*n]=a,g[2*n+1]=u,g[2*s]=p,g[2*s+1]=f}function xe(e,t,n,s,r,o){const i=r[o],c=r[o+1];let h=g[2*e],l=g[2*e+1],d=g[2*t],y=g[2*t+1],a=g[2*n],u=g[2*n+1],p=g[2*s],f=g[2*s+1],m=Sn(h,d,i);l=Dn(m,l,y,c),h=m|0,{Dh:f,Dl:p}={Dh:f^l,Dl:p^h},{Dh:f,Dl:p}={Dh:_n(f,p,16),Dl:On(f,p,16)},{h:u,l:a}=Tn(u,a,f,p),{Bh:y,Bl:d}={Bh:y^u,Bl:d^a},{Bh:y,Bl:d}={Bh:ks(y,d,63),Bl:As(y,d,63)},g[2*e]=h,g[2*e+1]=l,g[2*t]=d,g[2*t+1]=y,g[2*n]=a,g[2*n+1]=u,g[2*s]=p,g[2*s+1]=f}function Ds(e,t={},n,s,r){if(Me(n),e<0||e>n)throw new Error("outputLen bigger than keyLen");const{key:o,salt:i,personalization:c}=t;if(o!==void 0&&(o.length<1||o.length>n))throw new Error("key length must be undefined or 1.."+n);if(i!==void 0&&i.length!==s)throw new Error("salt must be undefined or "+s);if(c!==void 0&&c.length!==r)throw new Error("personalization must be undefined or "+r)}class Ln extends Bn{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,this.length=0,this.pos=0,Me(t),Me(n),this.blockLen=t,this.outputLen=n,this.buffer=new Uint8Array(t),this.buffer32=Ae(this.buffer)}update(t){Re(this),t=re(t),ke(t);const{blockLen:n,buffer:s,buffer32:r}=this,o=t.length,i=t.byteOffset,c=t.buffer;for(let h=0;h<o;){this.pos===n&&(F(r),this.compress(r,0,!1),F(r),this.pos=0);const l=Math.min(n-this.pos,o-h),d=i+h;if(l===n&&!(d%4)&&h+l<o){const y=new Uint32Array(c,d,Math.floor((o-h)/4));F(y);for(let a=0;h+n<o;a+=r.length,h+=n)this.length+=n,this.compress(y,a,!1);F(y);continue}s.set(t.subarray(h,h+l),this.pos),this.pos+=l,this.length+=l,h+=l}return this}digestInto(t){Re(this),xt(t,this);const{pos:n,buffer32:s}=this;this.finished=!0,ve(this.buffer.subarray(n)),F(s),this.compress(s,0,!0),F(s);const r=Ae(t);this.get().forEach((o,i)=>r[i]=ce(o))}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const s=t.slice(0,n);return this.destroy(),s}_cloneInto(t){const{buffer:n,length:s,finished:r,destroyed:o,outputLen:i,pos:c}=this;return t||(t=new this.constructor({dkLen:i})),t.set(...this.get()),t.buffer.set(n),t.destroyed=o,t.finished=r,t.length=s,t.pos=c,t.outputLen=i,t}clone(){return this._cloneInto()}}class Ls extends Ln{constructor(t={}){const n=t.dkLen===void 0?64:t.dkLen;super(128,n),this.v0l=M[0]|0,this.v0h=M[1]|0,this.v1l=M[2]|0,this.v1h=M[3]|0,this.v2l=M[4]|0,this.v2h=M[5]|0,this.v3l=M[6]|0,this.v3h=M[7]|0,this.v4l=M[8]|0,this.v4h=M[9]|0,this.v5l=M[10]|0,this.v5h=M[11]|0,this.v6l=M[12]|0,this.v6h=M[13]|0,this.v7l=M[14]|0,this.v7h=M[15]|0,Ds(n,t,64,16,16);let{key:s,personalization:r,salt:o}=t,i=0;if(s!==void 0&&(s=re(s),i=s.length),this.v0l^=this.outputLen|i<<8|65536|1<<24,o!==void 0){o=re(o);const c=Ae(o);this.v4l^=ce(c[0]),this.v4h^=ce(c[1]),this.v5l^=ce(c[2]),this.v5h^=ce(c[3])}if(r!==void 0){r=re(r);const c=Ae(r);this.v6l^=ce(c[0]),this.v6h^=ce(c[1]),this.v7l^=ce(c[2]),this.v7h^=ce(c[3])}if(s!==void 0){const c=new Uint8Array(this.blockLen);c.set(s),this.update(c)}}get(){let{v0l:t,v0h:n,v1l:s,v1h:r,v2l:o,v2h:i,v3l:c,v3h:h,v4l:l,v4h:d,v5l:y,v5h:a,v6l:u,v6h:p,v7l:f,v7h:m}=this;return[t,n,s,r,o,i,c,h,l,d,y,a,u,p,f,m]}set(t,n,s,r,o,i,c,h,l,d,y,a,u,p,f,m){this.v0l=t|0,this.v0h=n|0,this.v1l=s|0,this.v1h=r|0,this.v2l=o|0,this.v2h=i|0,this.v3l=c|0,this.v3h=h|0,this.v4l=l|0,this.v4h=d|0,this.v5l=y|0,this.v5h=a|0,this.v6l=u|0,this.v6h=p|0,this.v7l=f|0,this.v7h=m|0}compress(t,n,s){this.get().forEach((h,l)=>g[l]=h),g.set(M,16);let{h:r,l:o}=st(BigInt(this.length));g[24]=M[8]^o,g[25]=M[9]^r,s&&(g[28]=~g[28],g[29]=~g[29]);let i=0;const c=xs;for(let h=0;h<12;h++)be(0,4,8,12,t,n+2*c[i++]),xe(0,4,8,12,t,n+2*c[i++]),be(1,5,9,13,t,n+2*c[i++]),xe(1,5,9,13,t,n+2*c[i++]),be(2,6,10,14,t,n+2*c[i++]),xe(2,6,10,14,t,n+2*c[i++]),be(3,7,11,15,t,n+2*c[i++]),xe(3,7,11,15,t,n+2*c[i++]),be(0,5,10,15,t,n+2*c[i++]),xe(0,5,10,15,t,n+2*c[i++]),be(1,6,11,12,t,n+2*c[i++]),xe(1,6,11,12,t,n+2*c[i++]),be(2,7,8,13,t,n+2*c[i++]),xe(2,7,8,13,t,n+2*c[i++]),be(3,4,9,14,t,n+2*c[i++]),xe(3,4,9,14,t,n+2*c[i++]);this.v0l^=g[0]^g[16],this.v0h^=g[1]^g[17],this.v1l^=g[2]^g[18],this.v1h^=g[3]^g[19],this.v2l^=g[4]^g[20],this.v2h^=g[5]^g[21],this.v3l^=g[6]^g[22],this.v3h^=g[7]^g[23],this.v4l^=g[8]^g[24],this.v4h^=g[9]^g[25],this.v5l^=g[10]^g[26],this.v5h^=g[11]^g[27],this.v6l^=g[12]^g[28],this.v6h^=g[13]^g[29],this.v7l^=g[14]^g[30],this.v7h^=g[15]^g[31],ve(g)}destroy(){this.destroyed=!0,ve(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Ms=ws(e=>new Ls(e));function Mn(e,t,n,s,r,o,i,c,h,l,d,y,a,u,p,f,m,x,A,O){let S=0;for(let G=0;G<s;G++)({a:r,b:h,c:a,d:m}=me(r,h,a,m,n[t+e[S++]])),{a:r,b:h,c:a,d:m}=we(r,h,a,m,n[t+e[S++]]),{a:o,b:l,c:u,d:x}=me(o,l,u,x,n[t+e[S++]]),{a:o,b:l,c:u,d:x}=we(o,l,u,x,n[t+e[S++]]),{a:i,b:d,c:p,d:A}=me(i,d,p,A,n[t+e[S++]]),{a:i,b:d,c:p,d:A}=we(i,d,p,A,n[t+e[S++]]),{a:c,b:y,c:f,d:O}=me(c,y,f,O,n[t+e[S++]]),{a:c,b:y,c:f,d:O}=we(c,y,f,O,n[t+e[S++]]),{a:r,b:l,c:p,d:O}=me(r,l,p,O,n[t+e[S++]]),{a:r,b:l,c:p,d:O}=we(r,l,p,O,n[t+e[S++]]),{a:o,b:d,c:f,d:m}=me(o,d,f,m,n[t+e[S++]]),{a:o,b:d,c:f,d:m}=we(o,d,f,m,n[t+e[S++]]),{a:i,b:y,c:a,d:x}=me(i,y,a,x,n[t+e[S++]]),{a:i,b:y,c:a,d:x}=we(i,y,a,x,n[t+e[S++]]),{a:c,b:h,c:u,d:A}=me(c,h,u,A,n[t+e[S++]]),{a:c,b:h,c:u,d:A}=we(c,h,u,A,n[t+e[S++]]);return{v0:r,v1:o,v2:i,v3:c,v4:h,v5:l,v6:d,v7:y,v8:a,v9:u,v10:p,v11:f,v12:m,v13:x,v14:A,v15:O}}const ot=Ms,Cn=new TextEncoder().encode("SS58PRE"),Et=2,Vn=e=>{try{const t=In.decode(e),n=t.subarray(0,t[0]&64?2:1),s=t.subarray(n.length,t.length-Et),r=t.subarray(n.length+s.length),o=ot(Uint8Array.of(...Cn,...n,...s),{dkLen:64}).subarray(0,Et);return r[0]===o[0]&&r[1]===o[1]?{isValid:!0,ss58Format:Cs(n),publicKey:s.slice()}:{isValid:!1}}catch{return{isValid:!1}}},Cs=e=>{const t=new DataView(e.buffer,e.byteOffset,e.byteLength);return t.byteLength===1?t.getUint8(0):t.getUint16(0)},Pn=e=>{const t=e<64?Uint8Array.of(e):Uint8Array.of((e&252)>>2|64,e>>8|(e&3)<<6);return n=>{const s=ot(Uint8Array.of(...Cn,...t,...n),{dkLen:64}).subarray(0,Et);return In.encode(Uint8Array.of(...t,...n,...s))}};function Vs(e,t){return n=>{const s=Vn(n);if(!s.isValid)throw new Error("Invalid checksum");const{publicKey:r}=s;if(r.length!==e)throw new Error("Invalid public key length");return r}}const it=(e=42,t=32)=>ie(H(t),Vs(t),Pn(e));var Ps=Object.defineProperty,$n=e=>{throw TypeError(e)},$s=(e,t,n)=>t in e?Ps(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Fe=(e,t,n)=>$s(e,typeof t!="symbol"?t+"":t,n),Hn=(e,t,n)=>t.has(e)||$n("Cannot "+n),ae=(e,t,n)=>(Hn(e,t,"read from private field"),n?n.call(e):t.get(e)),qe=(e,t,n)=>t.has(e)?$n("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),Be=(e,t,n,s)=>(Hn(e,t,"write to private field"),t.set(e,n),n),le,je,ct,at,lt;const Hs=new TextEncoder,Ns=new TextDecoder,Rs=Z(D,H(1/0))[1];class Ke{constructor(t,n=!1){if(qe(this,le),qe(this,je,null),qe(this,ct,null),qe(this,at,null),qe(this,lt,null),Fe(this,"asText",()=>ae(this,lt)??Be(this,lt,Ns.decode(ae(this,le)))),Fe(this,"asHex",()=>ae(this,ct)||Be(this,ct,oe(ae(this,le)))),Fe(this,"asOpaqueHex",()=>ae(this,at)||Be(this,at,oe(this.asBytes()))),Fe(this,"asBytes",()=>ae(this,le)),Fe(this,"asOpaqueBytes",()=>ae(this,je)||Be(this,je,Y(D[0](ae(this,le).length),ae(this,le)))),n){try{const[s,r]=Rs(t);if(s===r.length){Be(this,le,r),Be(this,je,t);return}}catch{}throw new Error("Invalid opaque bytes")}else Be(this,le,t)}static fromText(t){return new this(Hs.encode(t))}static fromHex(t){return new this(Le(t))}static fromOpaqueHex(t){return new this(Le(t),!0)}static fromBytes(t){return new this(t)}static fromOpaqueBytes(t){return new this(t,!0)}}le=new WeakMap,je=new WeakMap,ct=new WeakMap,at=new WeakMap,lt=new WeakMap;const[Fs]=it();class Nn extends Ke{constructor(t){super(t)}static fromArray(t){return new this(new Uint8Array(t))}static fromAccountId32(t){return new this(Fs(t))}}const Rn=e=>{const t=H.enc(e);return n=>t(n.asBytes())},Fn=e=>{const t=H.dec(e),n=e==null?Ke:Nn;return s=>n.fromBytes(t(s))},Xe=e=>T(Rn(e),Fn(e));Xe.enc=Rn,Xe.dec=Fn;const w=ie(D,e=>e,Number),qn=ie(D,e=>e,BigInt),qs=Ze(e=>{const t=w.dec(e),n=Math.ceil(t/8);return{bytes:H(n).dec(e),bitsLen:t}}),jn=T(e=>{if(e.bitsLen>e.bytes.length*8)throw new Error(`Not enough bytes. (bitsLen:${e.bitsLen}, bytesLen:${e.bytes.length})`);const t=w.enc(e.bitsLen),n=new Uint8Array(e.bytes.length+t.length);return n.set(t,0),n.set(e.bytes,t.length),n},qs),js=ie(B,e=>e.charCodeAt(0),String.fromCharCode),Kn=e=>{const t=H.enc(e);return n=>t(Le(n))},Xn=e=>{const t=H.dec(e);return n=>oe(t(n))},te=e=>T(Kn(e),Xn(e));te.enc=Kn,te.dec=Xn;const Ks=new TextEncoder,Xs=new TextDecoder,Ws=e=>ie(H(e),t=>Ks.encode(t),t=>Xs.decode(t)),Wn=e=>{let t=n=>{const s=e();return t=s,s(n)};return n=>t(n)},zn=e=>{let t=n=>{const s=e(),r=s;return t=s,r(n)};return n=>t(n)},Gn=e=>T(Wn(()=>e().enc),zn(()=>e().dec)),It=Object.assign((e,t)=>({type:e,value:t}),{is(e,t){return e.type===t},as(e,t){if(t!==e.type)throw new Error(`Enum.as(enum, ${t}) used with actual type ${e.type}`);return e}}),zs=new Proxy({},{get(e,t){return n=>It(t,n)}}),L=(e,t)=>{const n=e;return n.inner=t,n},Yn=(...e)=>{const t=j.enc(...e);return L(n=>t({tag:n.type,value:n.value}),e[0])},Jn=(...e)=>{const t=j.dec(...e);return L(n=>{const{tag:s,value:r}=t(n);return It(s,r)},e[0])},Ce=(e,...t)=>L(T(Yn(vt(e,([n])=>n),...t),Jn(vt(e,([,n])=>n),...t)),e);Ce.enc=Yn,Ce.dec=Jn;const Ue=(e,...t)=>L(j(e,...t),e);Ue.enc=(e,...t)=>L(j.enc(e,...t),e),Ue.dec=(e,...t)=>L(j.dec(e,...t),e);const Gs=BigInt(0),We=BigInt(1),Ys=BigInt(2),Js=BigInt(7),Qs=BigInt(256),Zs=BigInt(113),Qn=[],Zn=[],er=[];for(let e=0,t=We,n=1,s=0;e<24;e++){[n,s]=[s,(2*n+3*s)%5],Qn.push(2*(5*s+n)),Zn.push((e+1)*(e+2)/2%64);let r=Gs;for(let o=0;o<7;o++)t=(t<<We^(t>>Js)*Zs)%Qs,t&Ys&&(r^=We<<(We<<BigInt(o))-We);er.push(r)}const tr=Is(er,!0),eo=tr[0],to=tr[1],nr=(e,t,n)=>n>32?Ts(e,t,n):_s(e,t,n),rr=(e,t,n)=>n>32?Ss(e,t,n):Os(e,t,n);function no(e,t=24){const n=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let i=0;i<10;i++)n[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const c=(i+8)%10,h=(i+2)%10,l=n[h],d=n[h+1],y=nr(l,d,1)^n[c],a=rr(l,d,1)^n[c+1];for(let u=0;u<50;u+=10)e[i+u]^=y,e[i+u+1]^=a}let r=e[2],o=e[3];for(let i=0;i<24;i++){const c=Zn[i],h=nr(r,o,c),l=rr(r,o,c),d=Qn[i];r=e[d],o=e[d+1],e[d]=h,e[d+1]=l}for(let i=0;i<50;i+=10){for(let c=0;c<10;c++)n[c]=e[i+c];for(let c=0;c<10;c++)e[i+c]^=~n[(c+2)%10]&n[(c+4)%10]}e[0]^=eo[s],e[1]^=to[s]}ve(n)}class kt extends Bn{constructor(t,n,s,r=!1,o=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=n,this.outputLen=s,this.enableXOF=r,this.rounds=o,Me(s),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Ae(this.state)}clone(){return this._cloneInto()}keccak(){F(this.state32),no(this.state32,this.rounds),F(this.state32),this.posOut=0,this.pos=0}update(t){Re(this),t=re(t),ke(t);const{blockLen:n,state:s}=this,r=t.length;for(let o=0;o<r;){const i=Math.min(n-this.pos,r-o);for(let c=0;c<i;c++)s[this.pos++]^=t[o++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:s,blockLen:r}=this;t[s]^=n,(n&128)!==0&&s===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){Re(this,!1),ke(t),this.finish();const n=this.state,{blockLen:s}=this;for(let r=0,o=t.length;r<o;){this.posOut>=s&&this.keccak();const i=Math.min(s-this.posOut,o-r);t.set(n.subarray(this.posOut,this.posOut+i),r),this.posOut+=i,r+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Me(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(xt(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,ve(this.state)}_cloneInto(t){const{blockLen:n,suffix:s,outputLen:r,rounds:o,enableXOF:i}=this;return t||(t=new kt(n,s,r,i,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=s,t.outputLen=r,t.enableXOF=i,t.destroyed=this.destroyed,t}}const ro=(e,t,n)=>ms(()=>new kt(t,e,n)),so=ro(1,136,256/8),sr=e=>{const t=e.slice(2),n=oe(so(t)).slice(2),s=new Array(40);for(let r=0;r<40;r++){const o=parseInt(n[r],16),i=t[r];s[r]=o>7?i.toUpperCase():i}return`0x${s.join("")}`},oo=H(20)[1],or=T(e=>{const t=Le(e);if(t.length!==20)throw new Error(`Invalid length found on EthAddress(${e})`);const n=oe(t);if(e===n||e===n.toUpperCase())return t;if(sr(n)!==e)throw new Error(`Invalid checksum found on EthAddress(${e})`);return t},Ze(e=>sr(oe(oo(e))))),N=e=>L(b(e),e);N.enc=e=>L(b.enc(e),e),N.dec=e=>L(b.dec(e),e);const ue=(...e)=>L(Z(...e),e);ue.enc=(...e)=>L(Z.enc(...e),e),ue.dec=(...e)=>L(Z.dec(...e),e);const q=(e,...t)=>L(I(e,...t),e);q.enc=(e,...t)=>L(I.enc(e,...t),e),q.dec=(e,...t)=>L(I.dec(e,...t),e);const ut=(e,t)=>L(Ne(e,t),{ok:e,ko:t});ut.enc=(e,t)=>L(Ne.enc(e,t),{ok:e,ko:t}),ut.dec=(e,t)=>L(Ne.dec(e,t),{ok:e,ko:t});const Ve=e=>L(K(e),e);Ve.enc=e=>L(K.enc(e),e),Ve.dec=e=>L(K.dec(e),e);const ir=new TextEncoder,cr=new TextDecoder,io=ie(H(4),ir.encode.bind(ir),cr.decode.bind(cr)),At=N({engine:io,payload:te()}),co=Ce({consensus:At,seal:At,preRuntime:At,runtimeUpdated:v},[4,5,6,8]),Bt=te(32),ao=N({parentHash:Bt,number:w,stateRoot:Bt,extrinsicRoot:Bt,digests:q(co)}),W=I(k),ar=K(k),lo=j({bool:v,char:v,str:v,u8:v,u16:v,u32:v,u64:v,u128:v,u256:v,i8:v,i16:v,i32:v,i64:v,i128:v,i256:v}),lr=I(b({name:ar,type:w,typeName:ar,docs:W})),uo=b({len:Q,type:w}),ho=b({bitStoreType:w,bitOrderType:w}),fo=I(b({name:k,fields:lr,index:B,docs:W})),po=j({composite:lr,variant:fo,sequence:w,array:uo,tuple:I(w),primitive:lo,compact:w,bitSequence:ho}),yo=b({name:k,type:K(w)}),go=I(yo),vo=b({id:w,path:W,params:go,def:po,docs:W}),ht=I(vo),Pe=j({NotDeprecated:v,DeprecatedWithoutNote:v,Deprecated:b({note:k,since:K(k)})}),mo=I(b({index:B,deprecation:j({DeprecatedWithoutNote:v,Deprecated:b({note:k,since:K(k)})},[1,2])})),Ut={name:k,inputs:I(b({name:k,type:w})),output:w,docs:W},wo=b({name:k,methods:I(b(Ut)),docs:W}),bo=b({name:k,methods:I(b({...Ut,deprecationInfo:Pe})),docs:W,version:w,deprecationInfo:Pe}),xo=b({id:te(32),...Ut,deprecationInfo:Pe}),Eo=j({Blake2128:v,Blake2256:v,Blake2128Concat:v,Twox128:v,Twox256:v,Twox64Concat:v,Identity:v}),Io=I(Eo),ko=b({hashers:Io,key:w,value:w}),ur={name:k,modifier:B,type:j({plain:w,map:ko}),fallback:te(),docs:W},_t=K(w),hr={name:k,storage:K(b({prefix:k,items:I(b(ur))})),calls:_t,events:_t,constants:I(b({name:k,type:w,value:te(),docs:W})),errors:_t,index:B},Ao={...hr,docs:W},Ot=K(b({type:w,deprecationInfo:mo})),Bo={name:k,storage:K(b({prefix:k,items:I(b({...ur,deprecationInfo:Pe}))})),calls:Ot,events:Ot,constants:I(b({name:k,type:w,value:te(),docs:W,deprecationInfo:Pe})),errors:Ot,associatedTypes:I(b({name:k,type:w,docs:W})),viewFns:I(xo),index:B,docs:W,deprecationInfo:Pe},Uo=new Uint8Array,dr=e=>T(()=>Uo,()=>e),_o=b({type:w,version:B,signedExtensions:I(b({identifier:k,type:w,additionalSigned:w}))}),fr=b({lookup:ht,pallets:I(b({...hr,docs:dr([])})),extrinsic:_o,type:w,apis:dr([])}),Oo=b({version:B,address:w,call:w,signature:w,extra:w,signedExtensions:I(b({identifier:k,type:w,additionalSigned:w}))}),pr=b({lookup:ht,pallets:I(b(Ao)),extrinsic:Oo,type:w,apis:I(wo),outerEnums:b({call:w,event:w,error:w}),custom:I(Z(k,b({type:w,value:te()})))}),To=b({version:I(B),address:w,call:w,signature:w,signedExtensionsByVersion:I(Z(B,I(w))),signedExtensions:I(b({identifier:k,type:w,additionalSigned:w}))}),yr=b({lookup:ht,pallets:I(b(Bo)),extrinsic:To,apis:I(bo),outerEnums:b({call:w,event:w,error:w}),custom:I(Z(k,b({type:w,value:te()})))}),gr=()=>{throw new Error("Unsupported metadata version!")},X=T(gr,gr),ze=b({magicNumber:Q,metadata:j({v0:X,v1:X,v2:X,v3:X,v4:X,v5:X,v6:X,v7:X,v8:X,v9:X,v10:X,v11:X,v12:X,v13:X,v14:fr,v15:pr,v16:yr})}),Tt=H(),So=K(Tt),Do=Z(D,Tt),St=e=>{try{return ze.dec(e)}catch{}try{return ze.dec(So.dec(e))}catch{}try{return ze.dec(Tt.dec(e))}catch{}try{return ze.dec(Do.dec(e)[1])}catch{}throw null},Dt=e=>{if("magicNumber"in e&&(e=e.metadata),"tag"in e){if(e.tag!=="v14"&&e.tag!=="v15"&&e.tag!=="v16")throw new Error("Only metadata 14, 15, and 16 are supported");e=e.value}if("signedExtensionsByVersion"in e.extrinsic)return{version:16,...e};if("custom"in e){const{lookup:r,extrinsic:o,custom:i,apis:c,pallets:h,outerEnums:l}=e;return{version:15,lookup:r,pallets:h.map(d=>({...d,calls:d.calls!=null?{type:d.calls}:void 0,events:d.events!=null?{type:d.events}:void 0,errors:d.errors!=null?{type:d.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...o,version:[o.version]},apis:c,outerEnums:l,custom:i}}const{lookup:t,extrinsic:n,pallets:s}=e;return{version:14,lookup:t,pallets:s.map(r=>({...r,calls:r.calls!=null?{type:r.calls}:void 0,events:r.events!=null?{type:r.events}:void 0,errors:r.errors!=null?{type:r.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...n,version:[n.version]},apis:[]}},Lo={dkLen:32},dt=e=>ot(e,Lo),Mo={dkLen:16},Lt=e=>ot(e,Mo),vr=e=>Y(Lt(e),e),se={CHUNK_START:1,CHUNK_END:2,PARENT:4,ROOT:8,KEYED_HASH:16,DERIVE_KEY_CONTEXT:32,DERIVE_KEY_MATERIAL:64},he=Es.slice(),mr=(()=>{const e=Array.from({length:16},(s,r)=>r),t=s=>[2,6,3,10,7,0,4,13,1,11,12,5,9,14,15,8].map(r=>s[r]),n=[];for(let s=0,r=e;s<7;s++,r=t(r))n.push(...r);return Uint8Array.from(n)})();class Mt extends Ln{constructor(t={},n=0){super(64,t.dkLen===void 0?32:t.dkLen),this.chunkPos=0,this.chunksDone=0,this.flags=0,this.stack=[],this.posOut=0,this.bufferOut32=new Uint32Array(16),this.chunkOut=0,this.enableXOF=!0;const{key:s,context:r}=t,o=r!==void 0;if(s!==void 0){if(o)throw new Error('Only "key" or "context" can be specified at same time');const i=re(s).slice();ke(i,32),this.IV=Ae(i),F(this.IV),this.flags=n|se.KEYED_HASH}else if(o){const i=re(r),c=new Mt({dkLen:32},se.DERIVE_KEY_CONTEXT).update(i).digest();this.IV=Ae(c),F(this.IV),this.flags=n|se.DERIVE_KEY_MATERIAL}else this.IV=he.slice(),this.flags=n;this.state=this.IV.slice(),this.bufferOut=ys(this.bufferOut32)}get(){return[]}set(){}b2Compress(t,n,s,r=0){const{state:o,pos:i}=this,{h:c,l:h}=st(BigInt(t),!0),{v0:l,v1:d,v2:y,v3:a,v4:u,v5:p,v6:f,v7:m,v8:x,v9:A,v10:O,v11:S,v12:G,v13:ee,v14:fe,v15:C}=Mn(mr,r,s,7,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],he[0],he[1],he[2],he[3],c,h,i,n);o[0]=l^x,o[1]=d^A,o[2]=y^O,o[3]=a^S,o[4]=u^G,o[5]=p^ee,o[6]=f^fe,o[7]=m^C}compress(t,n=0,s=!1){let r=this.flags;if(this.chunkPos||(r|=se.CHUNK_START),(this.chunkPos===15||s)&&(r|=se.CHUNK_END),s||(this.pos=this.blockLen),this.b2Compress(this.chunksDone,r,t,n),this.chunkPos+=1,this.chunkPos===16||s){let o=this.state;this.state=this.IV.slice();for(let i,c=this.chunksDone+1;(s||!(c&1))&&(i=this.stack.pop());c>>=1)this.buffer32.set(i,0),this.buffer32.set(o,8),this.pos=this.blockLen,this.b2Compress(0,this.flags|se.PARENT,this.buffer32,0),o=this.state,this.state=this.IV.slice();this.chunksDone++,this.chunkPos=0,this.stack.push(o)}this.pos=0}_cloneInto(t){t=super._cloneInto(t);const{IV:n,flags:s,state:r,chunkPos:o,posOut:i,chunkOut:c,stack:h,chunksDone:l}=this;return t.state.set(r.slice()),t.stack=h.map(d=>Uint32Array.from(d)),t.IV.set(n),t.flags=s,t.chunkPos=o,t.chunksDone=l,t.posOut=i,t.chunkOut=c,t.enableXOF=this.enableXOF,t.bufferOut32.set(this.bufferOut32),t}destroy(){this.destroyed=!0,ve(this.state,this.buffer32,this.IV,this.bufferOut32),ve(...this.stack)}b2CompressOut(){const{state:t,pos:n,flags:s,buffer32:r,bufferOut32:o}=this,{h:i,l:c}=st(BigInt(this.chunkOut++));F(r);const{v0:h,v1:l,v2:d,v3:y,v4:a,v5:u,v6:p,v7:f,v8:m,v9:x,v10:A,v11:O,v12:S,v13:G,v14:ee,v15:fe}=Mn(mr,0,r,7,t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],he[0],he[1],he[2],he[3],c,i,n,s);o[0]=h^m,o[1]=l^x,o[2]=d^A,o[3]=y^O,o[4]=a^S,o[5]=u^G,o[6]=p^ee,o[7]=f^fe,o[8]=t[0]^m,o[9]=t[1]^x,o[10]=t[2]^A,o[11]=t[3]^O,o[12]=t[4]^S,o[13]=t[5]^G,o[14]=t[6]^ee,o[15]=t[7]^fe,F(r),F(o),this.posOut=0}finish(){if(this.finished)return;this.finished=!0,ve(this.buffer.subarray(this.pos));let t=this.flags|se.ROOT;this.stack.length?(t|=se.PARENT,F(this.buffer32),this.compress(this.buffer32,0,!0),F(this.buffer32),this.chunksDone=0,this.pos=this.blockLen):t|=(this.chunkPos?0:se.CHUNK_START)|se.CHUNK_END,this.flags=t,this.b2CompressOut()}writeInto(t){Re(this,!1),ke(t),this.finish();const{blockLen:n,bufferOut:s}=this;for(let r=0,o=t.length;r<o;){this.posOut>=n&&this.b2CompressOut();const i=Math.min(n-this.posOut,o-r);t.set(s.subarray(this.posOut,this.posOut+i),r),this.posOut+=i,r+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible after digest call");return this.writeInto(t)}xof(t){return Me(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(xt(t,this),this.finished)throw new Error("digest() was already called");return this.enableXOF=!1,this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}}const Co=bs(e=>new Mt(e)),Vo={dkLen:32},$e=e=>Co(e,Vo),Po=e=>Y($e(e),e),wr=e=>e,_e=(e,t,n,s)=>new DataView(new Uint16Array([e,t,n,s]).buffer).getBigUint64(0,!0),Ct=2n**64n-1n,R=(e,t)=>e<<t&Ct|e>>64n-t,U=(e,t)=>e*t&Ct,P=(e,t)=>e+t&Ct,$=11400714785074694791n,z=14029467366897019727n,br=1609587929392839161n,Ge=9650029242287828579n,xr=2870177450012600261n;function Ee(e,t=0n){let n=P(P(t,$),z),s=P(t,z),r=t,o=t-$,i=e.length,c=0,h=null;(function(){let u=0,p=u+i;if(i){if(h=new Uint8Array(32),i<32){h.set(e.subarray(0,i),c),c+=i;return}if(u<=p-32){const f=p-32;do{let m;m=_e(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),n=U(R(P(n,U(m,z)),31n),$),u+=8,m=_e(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),s=U(R(P(s,U(m,z)),31n),$),u+=8,m=_e(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),r=U(R(P(r,U(m,z)),31n),$),u+=8,m=_e(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),o=U(R(P(o,U(m,z)),31n),$),u+=8}while(u<=f)}u<p&&(h.set(e.subarray(u,p),c),c=p-u)}})(),e=h||e;let l,d=0;for(i>=32?(l=R(n,1n),l=P(l,R(s,7n)),l=P(l,R(r,12n)),l=P(l,R(o,18n)),n=U(R(U(n,z),31n),$),l=l^n,l=P(U(l,$),Ge),s=U(R(U(s,z),31n),$),l=l^s,l=P(U(l,$),Ge),r=U(R(U(r,z),31n),$),l=l^r,l=P(U(l,$),Ge),o=U(R(U(o,z),31n),$),l=l^o,l=P(U(l,$),Ge)):l=P(t,xr),l=P(l,BigInt(i));d<=c-8;){let a=_e(e[d+1]<<8|e[d],e[d+3]<<8|e[d+2],e[d+5]<<8|e[d+4],e[d+7]<<8|e[d+6]);a=U(R(U(a,z),31n),$),l=P(U(R(l^a,27n),$),Ge),d+=8}if(d+4<=c){let a=U(_e(e[d+1]<<8|e[d],e[d+3]<<8|e[d+2],0,0),$);l=P(U(R(l^a,23n),z),br),d+=4}for(;d<c;){const a=U(_e(e[d++],0,0,0),xr);l=U(R(l^a,11n),$)}let y=l>>33n;return l=U(l^y,z),y=l>>29n,l=U(l^y,br),y=l>>32n,l^=y,l}const ft=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigUint64(0,Ee(e),!0),n.setBigUint64(8,Ee(e,1n),!0),t},Er=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigUint64(0,Ee(e),!0),n.setBigUint64(8,Ee(e,1n),!0),n.setBigUint64(16,Ee(e,2n),!0),n.setBigUint64(24,Ee(e,3n),!0),t},Ir=e=>Y(He.enc(Ee(e)),e),kr=new TextEncoder,$o=new Map([[wr,0],[Ir,8],[vr,16],[Lt,-16],[dt,-32],[ft,-16],[Er,-32]]),Ar=e=>{const t=ft(kr.encode(e));return(n,...s)=>{const r=Y(t,ft(kr.encode(n))),o=oe(r),i=l=>{if(!l.startsWith(o))throw new Error(`key does not match this storage (${e}.${n})`);if(s.length===0)return[];const d=Le(l.slice(o.length)),y=new Array(s.length);for(let a=0,u=0;a<s.length;a++){const[p,f]=s[a],m=$o.get(f);if(m==null)throw new Error("Unknown hasher");if(m<0){const x=m*-1;y[a]=oe(d.slice(u,u+x)),u+=x}else u+=m,y[a]=p.dec(d.slice(u)),u+=p.enc(y[a]).length}return y},c=s.map(([{enc:l},d])=>y=>d(l(y)));return{enc:(...l)=>oe(Y(r,...l.map((d,y)=>c[y](d)))),dec:i}}},Ho=Ke.fromText("modlpy/utilisuba").asBytes(),No=({threshold:e,signatories:t})=>{const n=Br(t),s=Y(Ho,D.enc(n.length),...n,ge.enc(e));return dt(s)},Br=e=>e.slice().sort((t,n)=>{for(let s=0;;s++){const r=s>=t.length,o=s>=n.length;if(r&&o)return 0;if(r)return-1;if(o)return 1;if(t[s]!==n[s])return t[s]>n[s]?1:-1}});var Ur=Object.freeze({__proto__:null,AccountId:it,Bin:Xe,Binary:Ke,Blake2128:Lt,Blake2128Concat:vr,Blake2256:dt,Blake3256:$e,Blake3256Concat:Po,Bytes:H,Enum:It,FixedSizeBinary:Nn,Hex:te,Identity:wr,Option:Ve,Result:ut,ScaleEnum:Ue,Self:Gn,Storage:Ar,Struct:N,Tuple:ue,Twox128:ft,Twox256:Er,Twox64Concat:Ir,Variant:Ce,Vector:q,_Enum:zs,_void:v,bitSequence:jn,blockHeader:ao,bool:rn,char:js,compact:D,compactBn:qn,compactNumber:w,createCodec:T,createDecoder:Ze,decAnyMetadata:St,enhanceCodec:ie,enhanceDecoder:tt,enhanceEncoder:et,ethAccount:or,fixedStr:Ws,fromBufferToBase58:Pn,getMultisigAccountId:No,getSs58AddressInfo:Vn,h64:Ee,i128:Qt,i16:Xt,i256:nn,i32:Wt,i64:zt,i8:Kt,metadata:ze,selfDecoder:zn,selfEncoder:Wn,sortMultisigSignatories:Br,str:k,u128:Jt,u16:ge,u256:tn,u32:Q,u64:He,u8:B,unifyMetadata:Dt,v14:fr,v14Lookup:ht,v15:pr,v16:yr});const _r=(e,t)=>e.type==="array"&&e.len===t&&e.value.type==="primitive"&&e.value.value==="u8",Ie={type:"void"},Ro=(e,t=()=>null)=>{const n=new Map,s=new Set,r=d=>y=>{let a=n.get(y);if(a)return a;if(s.has(y)){const p={id:y};return n.set(y,p),p}s.add(y);const u=d(y);return a=n.get(y),a?Object.assign(a,u):(a={id:y,...u},n.set(y,a)),s.delete(y),a};let o=!0,i=!0;const c=r(d=>{const y=t(e[d]);if(y)return y;const{def:a,path:u,params:p}=e[d];if(a.tag==="composite"){if(a.value.length===0)return Ie;if(a.value.length===1){const f=c(a.value[0].type);return o&&u.at(-1)==="AccountId32"&&_r(f,32)?(o=!1,{type:"AccountId32"}):i&&u.at(-1)==="AccountId20"&&_r(f,20)?(i=!1,{type:"AccountId20"}):f}return h(a.value)}if(a.tag==="variant"){if(u.length===1&&u[0]==="Option"&&p.length===1&&p[0].name==="T"){const x=c(p[0].type);return x.type==="void"?{type:"primitive",value:"bool"}:{type:"option",value:x}}if(u.length===1&&u[0]==="Result"&&p.length===2&&p[0].name==="T"&&p[1].name==="E")return{type:"result",value:{ok:c(p[0].type),ko:c(p[1].type)}};if(a.value.length===0)return Ie;const f={},m={};return a.value.forEach(x=>{const A=x.name;if(m[A]=x.docs,x.fields.length===0){f[A]={...Ie,idx:x.index};return}if(x.fields.length===1&&!x.fields[0].name){f[A]={type:"lookupEntry",value:c(x.fields[0].type),idx:x.index};return}f[A]={...h(x.fields),idx:x.index}}),{type:"enum",value:f,innerDocs:m}}if(a.tag==="sequence")return{type:"sequence",value:c(a.value)};if(a.tag==="array"){const{len:f}=a.value,m=c(a.value.type);return!f||m.type==="void"?Ie:f>1?{type:"array",value:m,len:a.value.len}:m}if(a.tag==="tuple")return a.value.length===0?Ie:a.value.length>1?l(a.value.map(f=>c(f)),a.value.map(f=>e[f].docs)):c(a.value[0]);if(a.tag==="primitive")return{type:"primitive",value:a.value.tag};if(a.tag==="compact"){const f=c(a.value);return f.type==="void"?Ie:{type:"compact",isBig:Number(f.value.slice(1))>32,size:f.value}}return{type:a.tag}}),h=d=>{let y=!0;const a={},u={};return d.forEach((p,f)=>{y=y&&!!p.name;const m=p.name||f,x=c(p.type);x.type!=="void"&&(a[m]=x,u[m]=p.docs)}),y?{type:"struct",value:a,innerDocs:u}:l(Object.values(a),Object.values(u))},l=(d,y)=>{if(d.every(a=>a.id===d[0].id)&&y.every(a=>!a.length)){const[a]=d;return a.type==="void"?Ie:{type:"array",value:d[0],len:d.length}}return{type:"tuple",value:d,innerDocs:y}};return c},Or=e=>{const t=Ro(e.lookup,({def:r})=>{if(r.tag==="composite"){const o=n(r);if(o)return{type:"enum",innerDocs:{},value:Object.fromEntries(e.pallets.map(i=>[i.name,i.errors==null?{...Ie,idx:i.index}:{type:"lookupEntry",value:t(i.errors.type),idx:i.index}])),byteLength:o}}return null});function n(r){if(!(r.value.length===2&&r.value[0].name==="index"&&r.value[1].name==="error"))return null;const i=t(r.value[0].type),c=t(r.value[1].type);return i.type==="primitive"&&i.value==="u8"&&c.type==="array"&&c.value.type==="primitive"&&c.value.value==="u8"?1+c.len:null}return Object.assign(t,{metadata:e,call:"call"in e.extrinsic?e.extrinsic.call:e.lookup[e.extrinsic.type]?.params.find(i=>i.name==="Call")?.type??null})},Fo=(e,t,n)=>(s,r,o,...i)=>{const{id:c}=s;if(r.has(c))return r.get(c);if(o.has(c)){const l=t(()=>r.get(c),s,...i);return r.set(c,l),l}o.add(c);let h=e(s,r,o,...i);return o.delete(c),r.has(c)&&(h=n(h,r.get(c),s,...i)),r.set(c,h),h},qo=Xe(),Tr=Fo((e,t,n,s)=>{if(e.type==="primitive")return Ur[e.value];if(e.type==="void")return v;if(e.type==="AccountId32")return s;if(e.type==="AccountId20")return or;if(e.type==="compact")return e.isBig?qn:w;if(e.type==="bitSequence")return jn;const r=u=>Tr(u,t,n,s),o=(u,p)=>{const f=r(u);return p?q(f,p):q(f)},i=u=>ue(...u.map(r)),c=u=>{const p=Object.fromEntries(Object.entries(u).map(([f,m])=>[f,r(m)]));return N(p)};if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return qo;if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?Xe(e.len):o(e.value,e.len);if(e.type==="sequence")return o(e.value);if(e.type==="tuple")return i(e.value);if(e.type==="struct")return c(e.value);if(e.type==="option")return Ve(r(e.value));if(e.type==="result")return ut(r(e.value.ok),r(e.value.ko));const h=Object.values(e.value).map(u=>{switch(u.type){case"void":return v;case"lookupEntry":return r(u.value);case"tuple":return i(u.value);case"struct":return c(u.value);case"array":return o(u.value,u.len)}}),l=Object.fromEntries(Object.keys(e.value).map((u,p)=>[u,h[p]])),d=Object.values(e.value).map(u=>u.idx),a=d.every((u,p)=>u===p)?Ce(l):Ce(l,d);return e.byteLength?jo(a,e.byteLength):a},Gn,e=>e),Sr=(e,t=it())=>{const n=new Map,s=r=>Tr(e(r),n,new Set,t);return r=>s(r)},jo=(e,t)=>{const n=H(t);return T(s=>n.enc(e.enc(s)),s=>e.dec(n.dec(s)))},Ko=ie(v,()=>{},()=>null),Xo=e=>{const{metadata:t}=e;let n=Sr(e);const s=t.pallets.find(a=>a.name==="System")?.constants.find(a=>a.name==="SS58Prefix");let r;if(s)try{const a=n(s.type).dec(s.value);typeof a=="number"&&(r=a,n=Sr(e,it(a)))}catch{}const o=new Map,i=(a,u)=>{let p=o.get(a);p||o.set(a,p=Ar(a));const f=t.pallets.find(C=>C.name===a).storage.items.find(C=>C.name===u),m=C=>C===v?Ko:C,x=(C,Oe,...Je)=>{const _=p(...Je),[,...E]=Je;return{args:ue(...E.map(([V])=>V)),keys:_,value:Oe,len:C,fallback:f.modifier===1?Oe.dec(f.fallback):void 0}};if(f.type.tag==="plain")return x(0,m(n(f.type.value)),u);const{key:A,value:O,hashers:S}=f.type.value,G=m(n(O)),ee=S.map(C=>Ur[C.tag]),fe=(()=>{if(ee.length===1)return[[n(A),ee[0]]];const C=e(A);switch(C.type){case"array":return ee.map(Oe=>[n(C.value.id),Oe]);case"tuple":return C.value.map((Oe,Je)=>[n(Oe.id),ee[Je]]);default:throw new Error("Invalid key type")}})();return x(ee.length,G,u,...fe)},c=a=>{switch(a.type){case"void":return v;case"lookupEntry":return n(a.value.id);case"tuple":return ue(...Object.values(a.value).map(u=>n(u.id)));case"struct":return N(vt(a.value,u=>n(u.id)));case"array":return q(n(a.value.id),a.len)}},h=(a,u)=>{const p=t.pallets.find(f=>f.name===a).constants.find(f=>f.name===u);return n(p.type)},l=a=>(u,p)=>{const f=t.pallets.find(A=>A.name===u),m=e(f[a].type);if(m.type!=="enum")throw null;const x=m.value[p];return{location:[f.index,x.idx],codec:c(m.value[p])}},d=(a,u)=>{const p=t.pallets.find(f=>f.name===a)?.viewFns.find(f=>f.name===u);if(!p)throw null;return{args:ue(...p.inputs.map(f=>n(f.type))),value:n(p.output)}},y=(a,u)=>{const p=t.apis.find(f=>f.name===a)?.methods.find(f=>f.name===u);if(!p)throw null;return{args:ue(...p.inputs.map(f=>n(f.type))),value:n(p.output)}};return{buildDefinition:n,buildStorage:i,buildEvent:l("events"),buildError:l("errors"),buildViewFn:d,buildRuntimeCall:y,buildCall:l("calls"),buildConstant:h,ss58Prefix:r}},Wo=et(B.enc,e=>+!!e.signed<<7|e.version),Vt=()=>new Error("Unkown signer"),zo=e=>{const{extrinsic:t}=e,n=Or(e);let s,r;if("address"in t)s=n(t.address),r=n(t.signature);else{const o=Object.fromEntries(e.lookup[t.type].params.filter(i=>i.type!=null).map(i=>[i.name,n(i.type)]));if(s=o.Address,r=o.Signature,!s||!r)throw Vt()}if(s.type==="AccountId20"&&r.type==="array"&&r.len===65&&r.value.type==="primitive"&&r.value.value==="u8")return[1,[]];if(r.type!=="enum"||["Ecdsa","Ed25519","Sr25519"].some(o=>!(o in r.value)))throw Vt();if(s.type==="enum"){const o=s.value.Id;if(o.type==="lookupEntry"&&o.value.type==="AccountId32")return[0,[o.idx]]}else if(s.type==="AccountId32")return[0,[]];throw Vt()},Go={Ed25519:0,Sr25519:1,Ecdsa:2},Yo=(e,t,n,s,r,o)=>{const[i,c]=zo(e),h=Y(Wo({signed:!0,version:4}),i===1?t:new Uint8Array([...c,...t]),i===1||!o?n:new Uint8Array([Go[o],...n]),...s,r);return Y(D.enc(h.length),h)},[pt,Ye]=["<Bytes>","</Bytes>"].map(e=>Ke.fromText(e).asBytes()),Jo=e=>async t=>{let n=!0,s;for(s=0;n&&s<pt.length;s++)n=pt[s]===t[s];n=n&&s===pt.length;const r=t.length-Ye.length;for(s=0;n&&s<Ye.length;s++)n=Ye[s]===t[r+s];return n=n&&s===Ye.length,e(n?t:Y(pt,t,Ye))},Dr={specVersion:Q,specName:k,base58Prefix:ge,decimals:B,tokenSymbol:k},Lr=N(Dr),Pt=H(32),Qo=Ue({V0:v,V1:N({typeInformationTreeRoot:Pt,extrinsicMetadataHash:Pt,...Dr})});Ue({bool:v,char:v,str:v,u8:v,u16:v,u32:v,u64:v,u128:v,u256:v,i8:v,i16:v,i32:v,i64:v,i128:v,i256:v});const de=Ue({bool:v,char:v,str:v,u8:v,u16:v,u32:v,u64:v,u128:v,u256:v,i8:v,i16:v,i32:v,i64:v,i128:v,i256:v,compactU8:v,compactU16:v,compactU32:v,compactU64:v,compactU128:v,compactU256:v,void:v,perId:w}),Mr=N({name:Ve(k),ty:de,typeName:Ve(k)}),Zo=Ue({composite:q(Mr),enumeration:N({name:k,fields:q(Mr),index:w}),sequence:de,array:N({len:Q,typeParam:de}),tuple:q(de),bitSequence:N({numBytes:B,leastSignificantBitFirst:rn})}),Cr=N({path:q(k),typeDef:Zo,typeId:w}),ei=q(Cr),$t=N({version:B,addressTy:de,callTy:de,signatureTy:de,signedExtensions:q(N({identifier:k,includedInExtrinsic:de,includedInSignedData:de}))}),ti=tt(B[1],e=>({version:e&-129,signed:!!(e&128)})),ni=ue.dec(D[1],ti,H(1/0)[1]);N({leaves:ei,leafIdxs:q(Q),proofs:q(Pt),extrinsic:$t,info:Lr});const ri=(e,t)=>{const n=new Set,s=o=>{if(n.has(o))return;const{tag:i,value:c}=t.get(o).def;switch(i){case"composite":if(!c.length)break;n.add(o),c.forEach(({type:h})=>{s(h)});break;case"variant":if(!c.length)break;n.add(o),c.forEach(({fields:h})=>{h.forEach(({type:l})=>{s(l)})});break;case"tuple":if(!c.length)break;n.add(o),c.forEach(s);break;case"sequence":n.add(o),s(c);break;case"array":n.add(o),s(c.type);break;case"bitSequence":n.add(o)}};s(e.extrinsic.call),s(e.extrinsic.address),s(e.extrinsic.signature),e.extrinsic.signedExtensions.forEach(({type:o,additionalSigned:i})=>{s(o),s(i)});const r=[...n].sort((o,i)=>o-i);return new Map(r.map((o,i)=>[o,i]))},si={u8:1,u16:2,u32:4,u64:8},oi=(e,t,n,s)=>{const{def:{tag:r,value:o}}=e.get(s);switch(r){case"composite":return[{tag:r,value:o.map(i=>({name:i.name,typeName:i.typeName,ty:t(i.type)}))}];case"variant":return o.map(i=>({tag:"enumeration",value:{name:i.name,index:i.index,fields:i.fields.map(c=>({name:c.name,typeName:c.typeName,ty:t(c.type)}))}}));case"sequence":return[{tag:r,value:t(o)}];case"array":return[{tag:r,value:{len:o.len,typeParam:t(o.type)}}];case"tuple":return[{tag:r,value:o.map(t)}];case"bitSequence":{const i=n(o.bitStoreType),c=si[i];if(!c)throw new Error("Invalid primitive for BitSequence");const h=e.get(o.bitOrderType).path,l=h.includes("Lsb0");if(!l&&!h.includes("Msb0"))throw new Error("BitOrderType not recognized");return[{tag:"bitSequence",value:{numBytes:c,leastSignificantBitFirst:l}}]}}throw new Error(`FrameId(${s}) should have been filtered out`)},ii=(e,t,n,s)=>{const r=[];return[...t.entries()].forEach(([o,i])=>{const{path:c}=e.get(o);oi(e,n,s,o).forEach(h=>{r.push({path:c,typeId:i,typeDef:h})})}),r.sort((o,i)=>{if(o.typeId!==i.typeId)return o.typeId-i.typeId;if(o.typeDef.tag!=="enumeration"||i.typeDef.tag!=="enumeration")throw new Error("Found two types with same id");return o.typeDef.value.index-i.typeDef.value.index}),r},ci=e=>{try{const t=Dt(St(e));if(t.version<=14)throw new Error("Wrong metadata version");return t}catch(t){throw t||new Error("Unable to decode metadata")}},yt=e=>{const t=e.length;let n=0;for(let r=0;r<t;r++)n+=e[r].byteLength;const s=new Uint8Array(n);for(let r=0,o=0;r<t;r++){const i=e[r];s.set(i,o),o+=i.byteLength}return s},Vr=e=>typeof e=="string"?Le(e):e,ai={null:"void",u8:"compactU8",u16:"compactU16",u32:"compactU32",u64:"compactU64",u128:"compactU128",u256:"compactU256"},li={bool:B,char:B,str:k,u8:B,u16:ge,u32:Q,u64:He,u128:Jt,u256:tn,i8:Kt,i16:Xt,i32:Wt,i64:zt,i128:Qt,i256:nn,void:v,compactU8:D,compactU16:D,compactU32:D,compactU64:D,compactU128:D,compactU256:D},Pr=(e,t,n,s,r)=>{if(t.tag!=="perId"){li[t.tag][1](e);return}const o=l=>{Pr(e,l,n,s,r)},i=n.get(t.value),[c]=i,h=s[c];switch(i.length===1&&r.add(c),h.typeDef.tag){case"enumeration":{const l=B.dec(e),[d,y]=i.map(a=>[s[a].typeDef,a]).find(([a])=>a.value.index===l);r.add(y),d.value.fields.forEach(({ty:a})=>{o(a)});break}case"sequence":{const l=D.dec(e);for(let d=0;d<l;d++)o(h.typeDef.value);break}case"array":{for(let l=0;l<h.typeDef.value.len;l++)o(h.typeDef.value.typeParam);break}case"composite":{h.typeDef.value.forEach(l=>{o(l.ty)});break}case"tuple":{h.typeDef.value.forEach(o);break}case"bitSequence":throw new Error("bitSequence is not supported")}},$r=(e,t,n)=>{let s=new Uint8Array;Ze(i=>{s=i})(e);const r=new Map;n.forEach((i,c)=>{const h=r.get(i.typeId);h?h.push(c):r.set(i.typeId,[c])});const o=new Set;return t.forEach(i=>{Pr(s,i,r,n,o)}),[...o].sort((i,c)=>i-c)},Ht=e=>Math.log2(e+1)|0,ui=(e,t)=>(e+1>>t)-1;function hi(e,t){const n=t.map(h=>e[h]),s=e.length-1,r=t.map(h=>s+h),o=[];if(r.length){const h=Ht(r.at(-1)),l=Math.pow(2,h)-1,d=r.findIndex(y=>y>=l);d>0&&(r.unshift(...r.splice(d)),n.unshift(...n.splice(d)))}let i=0;const c=h=>{if(i===r.length){o.push(h);return}const l=r[i];if(l===h){++i;return}const d=Ht(h),y=Ht(l);if(h!==ui(l,y-d)){o.push(h);return}const a=2*h+1;c(a),c(a+1)};return c(0),{leaves:n,leafIdxs:r,proofIdxs:o}}const Nt=(e,t,n)=>{if(n!=null&&n!==t)throw new Error(`${e} not expected. Received ${n} expected ${t}`)},di=(e,{decimals:t,tokenSymbol:n,...s})=>{const r=ci(e),o=r.extrinsic.version.includes(4)?4:null;if(o==null)throw new Error("Only extrinsic v4 is supported");const{ss58Prefix:i,buildDefinition:c}=Xo(Or(r));if(i==null)throw new Error("SS58 prefix not found in metadata");Nt("SS58 prefix",i,s.base58Prefix);const h=r.pallets.find(_=>_.name==="System")?.constants.find(_=>_.name==="Version");if(h==null)throw new Error("System.Version constant not found");const{spec_name:l,spec_version:d}=c(h.type).dec(h.value);if(typeof l!="string"||typeof d!="number")throw new Error("Spec name or spec version not found");Nt("Spec name",l,s.specName),Nt("Spec version",d,s.specVersion);const y={decimals:t,tokenSymbol:n,specVersion:d,specName:l,base58Prefix:i},a=new Map(r.lookup.map(_=>[_.id,_])),u=ri(r,a),p=_=>{const{def:{tag:E,value:V}}=a.get(_);if(E==="primitive")return V.tag;if(E!=="composite"&&E!=="tuple"||V.length>1)throw new Error("The provided definition doesn't map to a primitive");return V.length===0?null:p(E==="tuple"?V[0]:V[0].type)},f=_=>{const{def:E}=a.get(_);if(E.tag==="primitive")return{tag:E.value.tag,value:void 0};if(E.tag==="compact"){const V=p(E.value),pe=ai[V];if(!pe)throw new Error("Invalid primitive for Compact");return{tag:pe,value:void 0}}return u.has(_)?{tag:"perId",value:u.get(_)}:{tag:"void",value:void 0}},m={version:o,addressTy:f(r.extrinsic.address),callTy:f(r.extrinsic.call),signatureTy:f(r.extrinsic.signature),signedExtensions:r.extrinsic.signedExtensions.map(_=>({identifier:_.identifier,includedInExtrinsic:f(_.type),includedInSignedData:f(_.additionalSigned)}))},x=ii(a,u,f,p),A=x.map(Cr.enc);let O;const S=()=>{if(O)return O;if(!A.length)return O=[new Uint8Array(32).fill(0)];O=new Array(A.length*2-1);let _=A.length-1;for(let E=0;E<A.length;E++)O[_+E]=$e(A[E]);for(let E=O.length-2;E>0;E-=2)O[(E-1)/2]=$e(yt([O[E],O[E+1]]));return O};let G;const ee=()=>{if(G)return G;const E={tag:"V1",value:{typeInformationTreeRoot:S()[0],extrinsicMetadataHash:$e($t.enc(m)),...y}};return G=$e(Qo.enc(E))},fe=_=>{const E=hi(A,_),V=S(),pe=E.proofIdxs.map(Te=>V[Te]);return yt([D.enc(E.leaves.length),...E.leaves,D.enc(E.leafIdxs.length),...E.leafIdxs.map(Te=>Q.enc(Te)),D.enc(pe.length),...pe,$t.enc(m),Lr.enc(y)])},C=_=>{const E=[m.callTy,...m.signedExtensions.map(V=>V.includedInExtrinsic),...m.signedExtensions.map(V=>V.includedInSignedData)];return fe($r(_,E,x))};return{digest:ee,getProofForExtrinsic:(_,E)=>{let[,{version:V,signed:pe},Te]=ni(_);if(V!==m.version)throw new Error("Incorrect extrinsic version");const Nr=pe?[m.addressTy,m.signatureTy,...m.signedExtensions.map(Ft=>Ft.includedInExtrinsic),m.callTy]:[m.callTy];return E&&(Te=yt([Te,Vr(E)]),Nr.push(...m.signedExtensions.map(Ft=>Ft.includedInSignedData))),fe($r(Te,Nr,x))},getProofForExtrinsicParts:(_,E,V)=>{const pe=yt([_,E,V].map(Vr));return C(pe)},getProofForExtrinsicPayload:C}};function fi(e,t,n){return{publicKey:e,signTx:async(r,o,i,c,h=dt)=>{const l=Dt(St(i)),d=[],y=[];l.extrinsic.signedExtensions.map(({identifier:p})=>{const f=o[p];if(!f)throw new Error(`Missing ${p} signed extension`);d.push(f.value),y.push(f.additionalSigned)});const a=Y(r,...d,...y),u=await n(a.length>256?h(a):a);return Yo(l,e,u,d,r,t)},signBytes:Jo(n)}}const Rt="CheckMetadataHash",Hr=Uint8Array.from([1]),pi=(e,t)=>({...t,signTx:async(n,s,r,...o)=>t.signTx(n,s[Rt]?{...s,[Rt]:{identifier:Rt,value:Hr,additionalSigned:Y(Hr,di(r,e).digest())}}:s,r,...o)});Se.getPolkadotSigner=fi,Se.withMetadataHash=pi});
