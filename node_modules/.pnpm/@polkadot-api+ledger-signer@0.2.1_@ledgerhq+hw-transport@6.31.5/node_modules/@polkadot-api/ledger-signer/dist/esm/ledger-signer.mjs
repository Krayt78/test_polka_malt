import { merkleizeMetadata } from '@polkadot-api/merkleize-metadata';
import { Binary, u32, ethAccount, u16 } from '@polkadot-api/substrate-bindings';
import { mergeUint8 } from '@polkadot-api/utils';
import { getMetadata } from './get-metadata.mjs';
import { PUBKEY_LEN, DEFAULT_SS58, CLA, INS, P1, P2, SIGN_LEN } from './consts.mjs';
import { getSignBytes, createV4Tx } from '@polkadot-api/signers-common';

var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _transport, _schema, _pubkeys, _deviceId, _appInfo, _verified, _LedgerSigner_instances, send_fn, safeSend_fn, getPublicKeyAndAddr_fn, sign_fn;
const METADATA_IDENTIFIER = "CheckMetadataHash";
const START_PATH = Uint8Array.from([44, 0, 0, 128, 98, 1, 0, 128]);
const MID_PATH = Uint8Array.from([0, 0, 0, 128]);
const HARDENED = 2147483648;
const encodePath = (path1, path2) => {
  if (!Number.isInteger(path1) || path1 < 0 || path1 >= HARDENED || !Number.isInteger(path2) || path2 < 0 || path2 >= HARDENED)
    throw new Error(`Invalid path segments ${path1}, ${path2}`);
  return mergeUint8(
    START_PATH,
    u32.enc(HARDENED + path1),
    MID_PATH,
    u32.enc(HARDENED + path2)
  );
};
class LedgerSigner {
  /**
   * @param transport           Valid and opened transport.
   * @param [schema="ed25519"]  Signing schema to use. Default: `ed25519`.
   */
  constructor(transport, schema = "ed25519") {
    __privateAdd(this, _LedgerSigner_instances);
    __privateAdd(this, _transport);
    __privateAdd(this, _schema);
    __privateAdd(this, _pubkeys);
    // `${schema}:${path1}:${path2}, pubkey|addr`
    __privateAdd(this, _deviceId);
    __privateAdd(this, _appInfo);
    __privateAdd(this, _verified);
    __privateSet(this, _deviceId, null);
    __privateSet(this, _appInfo, null);
    __privateSet(this, _verified, null);
    __privateSet(this, _transport, transport);
    __privateSet(this, _schema, schema);
    __privateSet(this, _pubkeys, /* @__PURE__ */ new Map());
  }
  /**
   * Retrieve running app from device.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @returns App name and version.
   * @throws This could throw if the device is not connected, locked, etc.
   */
  async appInfo() {
    if (!__privateGet(this, _appInfo))
      __privateSet(this, _appInfo, __privateMethod(this, _LedgerSigner_instances, send_fn).call(this, 176, 1, 0, 0).then((v) => {
        const res = Uint8Array.from(v);
        const appName = Binary.fromBytes(res.slice(2, 2 + res[1])).asText();
        const appVersion = Binary.fromBytes(
          res.slice(2 + res[1] + 1, 2 + res[1] + 1 + res[2 + res[1]])
        ).asText();
        return { appName, appVersion };
      }));
    return __privateGet(this, _appInfo);
  }
  /**
   * Get unique identifier of the seed phrase. It is useful to uniquely identify
   * each device/seed that is connected.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @returns DeviceId.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc.
   */
  async deviceId() {
    if (!__privateGet(this, _deviceId))
      __privateSet(this, _deviceId, __privateMethod(this, _LedgerSigner_instances, getPublicKeyAndAddr_fn).call(this, 0, 0).then(
        (v) => u32.dec(v.slice(0, 4))
      ));
    return __privateGet(this, _deviceId);
  }
  /**
   * Get pubkey for a specific derivation path.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @param path1  Primary derivation index.
   * @param path2  Secondary derivation index. Defaults to 0.
   * @returns Public key.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc.
   */
  async getPubkey(path1, path2 = 0) {
    return await __privateMethod(this, _LedgerSigner_instances, getPublicKeyAndAddr_fn).call(this, path1, path2).then(
      (v) => v.slice(0, PUBKEY_LEN[__privateGet(this, _schema)])
    );
  }
  /**
   * Show address in device's screen.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @param ss58Prefix  SS58 prefix for address formatting. This is only
   *                    relevant for `ed25519` schema.
   * @param path1       Primary derivation index.
   * @param path2       Secondary derivation index. Defaults to 0.
   * @returns Public key.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc.
   */
  async seeAddressInDevice(ss58Prefix, path1, path2 = 0) {
    return await __privateMethod(this, _LedgerSigner_instances, getPublicKeyAndAddr_fn).call(this, path1, path2, true, ss58Prefix).then(
      (v) => v.slice(0, PUBKEY_LEN[__privateGet(this, _schema)])
    );
  }
  /**
   * Get `AccountId20` (ETH-like) for a specific derivation path.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @param path1  Primary derivation index.
   * @param path2  Secondary derivation index. Defaults to 0.
   * @returns AccountId20.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc. It throws as well if the
   *         schema is `ed25519`.
   */
  async getAddress20(path1, path2 = 0) {
    if (__privateGet(this, _schema) !== "ecdsa")
      throw new Error("This method only supports `ecdsa` schema.");
    return await __privateMethod(this, _LedgerSigner_instances, getPublicKeyAndAddr_fn).call(this, path1, path2).then(
      (v) => ethAccount.dec(v.slice(PUBKEY_LEN[__privateGet(this, _schema)]))
    );
  }
  /**
   * Create PolkadotSigner object from a specific derivation path and for a
   * specific network.
   *
   * This call prevents race conditions and waits until the device is free to
   * receive new messages.
   *
   * @param networkInfo  Off-chain info required to sign transactions. This
   *                     makes this object be network-specific.
   * @param path1        Primary derivation index.
   * @param path2        Secondary derivation index. Defaults to 0.
   * @returns PolkadotSigner object.
   * @throws This could throw if the device is not connected, locked, in a
   *         different app than Polkadot, etc.
   */
  async getPolkadotSigner(networkInfo, path1, path2 = 0) {
    const publicKey = await __privateMethod(this, _LedgerSigner_instances, getPublicKeyAndAddr_fn).call(this, path1, path2).then(
      (v) => __privateGet(this, _schema) === "ed25519" ? v.slice(0, PUBKEY_LEN[__privateGet(this, _schema)]) : v.slice(PUBKEY_LEN[__privateGet(this, _schema)])
    );
    const signTx = async (callData, signedExtensions, metadata) => {
      const merkleizer = merkleizeMetadata(metadata, networkInfo);
      const digest = merkleizer.digest();
      const meta = getMetadata(metadata);
      if (meta.extrinsic.signedExtensions.find(
        ({ identifier }) => identifier === METADATA_IDENTIFIER
      ) == null)
        throw new Error("No `CheckMetadataHash` sigExt found");
      const extra = [];
      const additionalSigned = [];
      meta.extrinsic.signedExtensions.map(({ identifier }) => {
        if (identifier === METADATA_IDENTIFIER) {
          extra.push(Uint8Array.from([1]));
          additionalSigned.push(mergeUint8(Uint8Array.from([1]), digest));
          return;
        }
        const signedExtension = signedExtensions[identifier];
        if (!signedExtension)
          throw new Error(`Missing ${identifier} signed extension`);
        extra.push(signedExtension.value);
        additionalSigned.push(signedExtension.additionalSigned);
      });
      const toSign = mergeUint8(callData, ...extra, ...additionalSigned);
      const signature = await __privateMethod(this, _LedgerSigner_instances, sign_fn).call(this, path1, path2, toSign, merkleizer.getProofForExtrinsicPayload(toSign));
      return createV4Tx(meta, publicKey, signature, extra, callData);
    };
    return {
      publicKey,
      signTx,
      signBytes: getSignBytes(
        async (x) => (
          // the signature includes a "0x00" at the beginning, indicating a ed25519 signature, ecdsa do not
          // this is not needed for non-extrinsic signatures
          (await __privateMethod(this, _LedgerSigner_instances, sign_fn).call(this, path1, path2, x)).slice(
            __privateGet(this, _schema) === "ed25519" ? 1 : 0
          )
        )
      )
    };
  }
}
_transport = new WeakMap();
_schema = new WeakMap();
_pubkeys = new WeakMap();
_deviceId = new WeakMap();
_appInfo = new WeakMap();
_verified = new WeakMap();
_LedgerSigner_instances = new WeakSet();
send_fn = async function(...params) {
  while (__privateGet(this, _transport).exchangeBusyPromise)
    await __privateGet(this, _transport).exchangeBusyPromise;
  return await __privateGet(this, _transport).send(...params);
};
safeSend_fn = async function(...params) {
  if (!__privateGet(this, _verified))
    __privateSet(this, _verified, this.appInfo().then(({ appName, appVersion }) => {
      if (appName !== "Polkadot")
        throw new Error("Polkadot App is not opened");
      const version = appVersion.split(".").map((v) => parseInt(v));
      if (
        // from version 100 it is Polkadot Generic App
        version[0] < 100 || // ecdsa was only released on 100.0.12
        version[0] === 100 && version[1] === 0 && version[2] < 12
      )
        throw new Error(`Polkadot App version ${appVersion} not expected`);
    }));
  await __privateGet(this, _verified);
  return await __privateMethod(this, _LedgerSigner_instances, send_fn).call(this, ...params);
};
getPublicKeyAndAddr_fn = async function(path1, path2, seeAddressInDevice, ss58Prefix) {
  const key = `${__privateGet(this, _schema)}:${path1}:${path2}`;
  if (!seeAddressInDevice && __privateGet(this, _pubkeys).has(key))
    return __privateGet(this, _pubkeys).get(key);
  if (ss58Prefix != null && (!Number.isInteger(ss58Prefix) || ss58Prefix < 0 || ss58Prefix >= 1 << 16))
    throw new Error(`Invalid ss58Prefix ${ss58Prefix}`);
  const bufToSend = Buffer.from(
    // id + ss58 prefix
    mergeUint8(
      encodePath(path1, path2),
      Uint8Array.from(u16.enc(ss58Prefix ?? DEFAULT_SS58))
    )
  );
  const prom = __privateMethod(this, _LedgerSigner_instances, safeSend_fn).call(this, CLA, INS.getAddress, seeAddressInDevice ? P1.showAddress : P1.getAddress, P2[__privateGet(this, _schema)], bufToSend).then((v) => Uint8Array.from(v).slice(0, -2));
  __privateGet(this, _pubkeys).set(key, prom);
  return prom;
};
sign_fn = async function(path1, path2, payload, shortMetadata) {
  const path = encodePath(path1, path2);
  const chunks = [];
  chunks.push(Buffer.from(mergeUint8(path, u16.enc(payload.length))));
  const combinedPayload = shortMetadata == null ? payload : mergeUint8(payload, shortMetadata);
  let offset = 0;
  while (offset < combinedPayload.length) {
    const chunkEnd = Math.min(offset + 250, combinedPayload.length);
    chunks.push(Buffer.from(combinedPayload.slice(offset, chunkEnd)));
    offset = chunkEnd;
  }
  let result;
  for (let i = 0; i < chunks.length; i++) {
    result = await __privateMethod(this, _LedgerSigner_instances, safeSend_fn).call(this, CLA, shortMetadata == null ? INS.signRaw : INS.signTx, i === 0 ? P1.init : i === chunks.length - 1 ? P1.end : P1.continue, P2[__privateGet(this, _schema)], chunks[i]);
  }
  if (result == null) throw null;
  return Uint8Array.from(result).slice(
    0,
    // ed25519 includes as well a `0x00` at the beginning
    SIGN_LEN[__privateGet(this, _schema)] + (__privateGet(this, _schema) === "ed25519" ? 1 : 0)
  );
};

export { LedgerSigner };
//# sourceMappingURL=ledger-signer.mjs.map
