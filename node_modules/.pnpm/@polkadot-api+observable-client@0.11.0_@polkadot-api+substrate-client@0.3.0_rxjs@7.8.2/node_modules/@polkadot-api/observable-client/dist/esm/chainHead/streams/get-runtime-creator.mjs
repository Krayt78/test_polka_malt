import { getLookupFn, getDynamicBuilder } from '@polkadot-api/metadata-builders';
import { Bytes, Option, Vector, u32, AccountId, unifyMetadata, metadata } from '@polkadot-api/substrate-bindings';
import { toHex } from '@polkadot-api/utils';
import { map, shareReplay, catchError, of, mergeMap, tap, EMPTY, timer } from 'rxjs';
import { BlockNotPinnedError } from '../errors.mjs';
import { OperationInaccessibleError } from '@polkadot-api/substrate-client';

const versionedArgs = (v) => toHex(u32.enc(v));
const opaqueBytes = Bytes();
const optionalOpaqueBytes = Option(opaqueBytes);
const u32ListDecoder = Vector(u32).dec;
const getRuntimeCreator = (call$, getCodeHash$, getCachedMetadata, setCachedMetadata) => {
  const getMetadata$ = (getHash) => {
    const withRecovery = (fn) => {
      const result = (...args) => {
        const hash = getHash();
        return hash ? fn(hash, ...args).pipe(
          catchError((e) => {
            if (e instanceof BlockNotPinnedError) return result(...args);
            if (e instanceof OperationInaccessibleError)
              return timer(750).pipe(mergeMap(() => result(...args)));
            throw e;
          })
        ) : EMPTY;
      };
      return result;
    };
    const recoverCall$ = withRecovery(call$);
    const recoverCodeHash$ = withRecovery(getCodeHash$);
    const versions$ = recoverCall$("Metadata_metadata_versions", "").pipe(
      map(u32ListDecoder),
      catchError(() => of([14]))
    );
    const versioned$ = (availableVersions) => {
      const [v] = availableVersions.filter((x) => x > 13 && x < 17).sort((a, b) => b - a);
      return v === 14 ? recoverCall$("Metadata_metadata", "").pipe(map(opaqueBytes.dec)) : recoverCall$("Metadata_metadata_at_version", versionedArgs(v)).pipe(
        map((x) => optionalOpaqueBytes.dec(x))
      );
    };
    const metadataRaw$ = versions$.pipe(mergeMap(versioned$));
    return recoverCodeHash$().pipe(
      mergeMap(
        (codeHash) => getCachedMetadata(codeHash).pipe(
          catchError(() => of(null)),
          mergeMap(
            (metadataRaw) => metadataRaw ? of(metadataRaw) : metadataRaw$.pipe(
              tap((raw) => {
                setCachedMetadata(codeHash, raw);
              })
            )
          ),
          map((metadataRaw) => ({
            codeHash,
            metadataRaw,
            metadata: unifyMetadata(metadata.dec(metadataRaw))
          }))
        )
      )
    );
  };
  return (getHash) => {
    const initialHash = getHash();
    const usages = /* @__PURE__ */ new Set([initialHash]);
    const runtimeContext$ = getMetadata$(
      getHash
    ).pipe(
      map(({ metadata, metadataRaw, codeHash }) => {
        const lookup = getLookupFn(metadata);
        const dynamicBuilder = getDynamicBuilder(lookup);
        const events = dynamicBuilder.buildStorage("System", "Events");
        const assetPayment = metadata.extrinsic.signedExtensions.find(
          (x) => x.identifier === "ChargeAssetTxPayment"
        );
        let assetId = null;
        if (assetPayment) {
          const assetTxPayment = lookup(assetPayment.type);
          if (assetTxPayment.type === "struct") {
            const optionalAssetId = assetTxPayment.value.asset_id;
            if (optionalAssetId.type === "option")
              assetId = optionalAssetId.value.id;
          }
        }
        return {
          assetId,
          metadataRaw,
          codeHash,
          lookup,
          dynamicBuilder,
          events: {
            key: events.keys.enc(),
            dec: events.value.dec
          },
          accountId: AccountId(dynamicBuilder.ss58Prefix)
        };
      }),
      shareReplay(1)
    );
    const result = {
      at: initialHash,
      runtime: runtimeContext$,
      addBlock: (block) => {
        usages.add(block);
        return result;
      },
      deleteBlocks: (blocks) => {
        blocks.forEach((block) => {
          usages.delete(block);
        });
        return usages.size;
      },
      usages
    };
    runtimeContext$.subscribe({
      error() {
      }
    });
    return result;
  };
};

export { getRuntimeCreator };
//# sourceMappingURL=get-runtime-creator.mjs.map
