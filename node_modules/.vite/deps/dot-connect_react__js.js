import {
  ConnectionButton,
  ConnectionDialog
} from "./chunk-6HYL3RYW.js";
import "./chunk-IEHBY26R.js";
import {
  require_react
} from "./chunk-LPNUN4BZ.js";
import "./chunk-Y7OA44XQ.js";
import "./chunk-HK3DZUUN.js";
import "./chunk-CGJMGULG.js";
import "./chunk-CH5HA4ZP.js";
import "./chunk-AKNCNGJG.js";
import "./chunk-6ZBYRXGS.js";
import "./chunk-EVM4Y7G3.js";
import "./chunk-OVJJME56.js";
import "./chunk-2T3XQHSK.js";
import {
  __toESM
} from "./chunk-B4Q33VKO.js";

// node_modules/.pnpm/@lit+react@1.0.7_@types+react@19.1.6/node_modules/@lit/react/development/create-component.js
var NODE_MODE = false;
var DEV_MODE = true;
var reservedReactProperties = /* @__PURE__ */ new Set([
  "children",
  "localName",
  "ref",
  "style",
  "className"
]);
var listenedEvents = /* @__PURE__ */ new WeakMap();
var addOrUpdateEventListener = (node, event, listener) => {
  let events = listenedEvents.get(node);
  if (events === void 0) {
    listenedEvents.set(node, events = /* @__PURE__ */ new Map());
  }
  let handler = events.get(event);
  if (listener !== void 0) {
    if (handler === void 0) {
      events.set(event, handler = { handleEvent: listener });
      node.addEventListener(event, handler);
    } else {
      handler.handleEvent = listener;
    }
  } else if (handler !== void 0) {
    events.delete(event);
    node.removeEventListener(event, handler);
  }
};
var setProperty = (node, name, value, old, events) => {
  const event = events == null ? void 0 : events[name];
  if (event !== void 0) {
    if (value !== old) {
      addOrUpdateEventListener(node, event, value);
    }
    return;
  }
  node[name] = value;
  if ((value === void 0 || value === null) && name in HTMLElement.prototype) {
    node.removeAttribute(name);
  }
};
var createComponent = ({ react: React2, tagName, elementClass, events, displayName }) => {
  const eventProps = new Set(Object.keys(events ?? {}));
  if (DEV_MODE && !NODE_MODE) {
    for (const p of reservedReactProperties) {
      if (p in elementClass.prototype && !(p in HTMLElement.prototype)) {
        console.warn(`${tagName} contains property ${p} which is a React reserved property. It will be used by React and not set on the element.`);
      }
    }
  }
  const ReactComponent = React2.forwardRef((props, ref) => {
    const prevElemPropsRef = React2.useRef(/* @__PURE__ */ new Map());
    const elementRef = React2.useRef(null);
    const reactProps = {};
    const elementProps = {};
    for (const [k, v] of Object.entries(props)) {
      if (reservedReactProperties.has(k)) {
        reactProps[k === "className" ? "class" : k] = v;
        continue;
      }
      if (eventProps.has(k) || k in elementClass.prototype) {
        elementProps[k] = v;
        continue;
      }
      reactProps[k] = v;
    }
    if (!NODE_MODE) {
      React2.useLayoutEffect(() => {
        if (elementRef.current === null) {
          return;
        }
        const newElemProps = /* @__PURE__ */ new Map();
        for (const key in elementProps) {
          setProperty(elementRef.current, key, props[key], prevElemPropsRef.current.get(key), events);
          prevElemPropsRef.current.delete(key);
          newElemProps.set(key, props[key]);
        }
        for (const [key, value] of prevElemPropsRef.current) {
          setProperty(elementRef.current, key, void 0, value, events);
        }
        prevElemPropsRef.current = newElemProps;
      });
      React2.useLayoutEffect(() => {
        var _a;
        (_a = elementRef.current) == null ? void 0 : _a.removeAttribute("defer-hydration");
      }, []);
    }
    if (NODE_MODE) {
      if ((React2.createElement.name === "litPatchedCreateElement" || globalThis.litSsrReactEnabled) && Object.keys(elementProps).length) {
        reactProps["_$litProps$"] = elementProps;
      }
    } else {
      reactProps["suppressHydrationWarning"] = true;
    }
    return React2.createElement(tagName, {
      ...reactProps,
      ref: React2.useCallback((node) => {
        elementRef.current = node;
        if (typeof ref === "function") {
          ref(node);
        } else if (ref !== null) {
          ref.current = node;
        }
      }, [ref])
    });
  });
  ReactComponent.displayName = displayName ?? elementClass.name;
  return ReactComponent;
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/react/index.js
var import_react2 = __toESM(require_react());
var ConnectionButton2 = createComponent({
  tagName: "dc-connection-button",
  elementClass: ConnectionButton,
  react: import_react2.default
});
var ConnectionDialog2 = createComponent({
  tagName: "dc-connection-dialog",
  elementClass: ConnectionDialog,
  react: import_react2.default,
  events: {
    onClose: "close"
  }
});
export {
  ConnectionButton2 as ConnectionButton,
  ConnectionDialog2 as ConnectionDialog
};
/*! Bundled license information:

@lit/react/development/create-component.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/react/development/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=dot-connect_react__js.js.map
