{
  "version": 3,
  "sources": ["../../.pnpm/@polkadot-api+ledger-signer@0.2.1_@ledgerhq+hw-transport@6.31.5/node_modules/@polkadot-api/ledger-signer/src/get-metadata.ts", "../../.pnpm/@polkadot-api+ledger-signer@0.2.1_@ledgerhq+hw-transport@6.31.5/node_modules/@polkadot-api/ledger-signer/src/consts.ts", "../../.pnpm/@polkadot-api+ledger-signer@0.2.1_@ledgerhq+hw-transport@6.31.5/node_modules/@polkadot-api/ledger-signer/src/ledger-signer.ts"],
  "sourcesContent": ["import {\n  decAnyMetadata,\n  UnifiedMetadata,\n  unifyMetadata,\n  type HexString,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const getMetadata = (\n  input: Uint8Array | HexString,\n): UnifiedMetadata<15 | 16> => {\n  try {\n    const metadata = unifyMetadata(decAnyMetadata(input))\n    if (metadata.version <= 14) throw new Error(\"Wrong metadata version\")\n    return metadata as UnifiedMetadata<15 | 16>\n  } catch (e) {\n    throw e || new Error(\"Unable to decode metadata\")\n  }\n}\n", "export const CLA = 0xf9\nexport const INS = {\n  getVersion: 0,\n  getAddress: 1,\n  signTx: 2,\n  signRaw: 3,\n}\nexport const P1 = {\n  // sign\n  init: 0,\n  continue: 1,\n  end: 2,\n\n  // addr\n  getAddress: 0,\n  showAddress: 1,\n}\nexport const P2 = {\n  ed25519: 0,\n  ecdsa: 2,\n}\nexport const PUBKEY_LEN = {\n  ed25519: 32,\n  ecdsa: 33,\n}\nexport const SIGN_LEN = {\n  ed25519: 64,\n  ecdsa: 65,\n}\nexport const DEFAULT_SS58 = 0\n", "import type Transport from \"@ledgerhq/hw-transport\"\nimport { merkleizeMetadata } from \"@polkadot-api/merkleize-metadata\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport {\n  Binary,\n  ethAccount,\n  HexString,\n  u16,\n  u32,\n} from \"@polkadot-api/substrate-bindings\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\nimport { getMetadata } from \"./get-metadata\"\nimport { CLA, DEFAULT_SS58, INS, P1, P2, PUBKEY_LEN, SIGN_LEN } from \"./consts\"\nimport { getSignBytes, createV4Tx } from \"@polkadot-api/signers-common\"\n\nconst METADATA_IDENTIFIER = \"CheckMetadataHash\"\n\n// 44'/354'\nconst START_PATH = Uint8Array.from([44, 0, 0, 128, 98, 1, 0, 128])\n// 0'\nconst MID_PATH = Uint8Array.from([0, 0, 0, 128])\nconst HARDENED = 0x80000000 // 1 << 31\nconst encodePath = (path1: number, path2: number) => {\n  // ensure numbers are positive integers and fit in 31 bits\n  if (\n    !Number.isInteger(path1) ||\n    path1 < 0 ||\n    path1 >= HARDENED ||\n    !Number.isInteger(path2) ||\n    path2 < 0 ||\n    path2 >= HARDENED\n  )\n    throw new Error(`Invalid path segments ${path1}, ${path2}`)\n\n  return mergeUint8(\n    START_PATH,\n    u32.enc(HARDENED + path1),\n    MID_PATH,\n    u32.enc(HARDENED + path2),\n  )\n}\n\n/**\n * ATTENTION: This class requires `Buffer` to be available. This is an Ledger\n * requirement that we need to fulfill. If you are on a browser-based\n * environment, make sure you polyfill it.\n */\nexport class LedgerSigner {\n  readonly #transport: Transport\n  readonly #schema: \"ed25519\" | \"ecdsa\"\n  #pubkeys: Map<string, Promise<Uint8Array>> // `${schema}:${path1}:${path2}, pubkey|addr`\n  #deviceId: Promise<number> | null\n  #appInfo: ReturnType<typeof this.appInfo> | null\n  #verified: Promise<void> | null\n\n  /**\n   * @param transport           Valid and opened transport.\n   * @param [schema=\"ed25519\"]  Signing schema to use. Default: `ed25519`.\n   */\n  constructor(transport: Transport, schema: \"ed25519\" | \"ecdsa\" = \"ed25519\") {\n    this.#deviceId = null\n    this.#appInfo = null\n    this.#verified = null\n    this.#transport = transport\n    this.#schema = schema\n    this.#pubkeys = new Map()\n  }\n\n  async #send(\n    ...params: Parameters<Transport[\"send\"]>\n  ): ReturnType<Transport[\"send\"]> {\n    while (this.#transport.exchangeBusyPromise)\n      await this.#transport.exchangeBusyPromise\n    return await this.#transport.send(...params)\n  }\n\n  async #safeSend(\n    ...params: Parameters<Transport[\"send\"]>\n  ): ReturnType<Transport[\"send\"]> {\n    if (!this.#verified)\n      this.#verified = this.appInfo().then(({ appName, appVersion }) => {\n        if (appName !== \"Polkadot\")\n          throw new Error(\"Polkadot App is not opened\")\n        const version = appVersion.split(\".\").map((v) => parseInt(v))\n        if (\n          // from version 100 it is Polkadot Generic App\n          version[0] < 100 ||\n          // ecdsa was only released on 100.0.12\n          (version[0] === 100 && version[1] === 0 && version[2] < 12)\n        )\n          throw new Error(`Polkadot App version ${appVersion} not expected`)\n      })\n    await this.#verified\n    return await this.#send(...params)\n  }\n\n  /**\n   * Retrieve running app from device.\n   *\n   * This call prevents race conditions and waits until the device is free to\n   * receive new messages.\n   *\n   * @returns App name and version.\n   * @throws This could throw if the device is not connected, locked, etc.\n   */\n  async appInfo(): Promise<{\n    appName: string\n    appVersion: string\n  }> {\n    // this message is common among Ledger, not only Polkadot app\n    if (!this.#appInfo)\n      this.#appInfo = this.#send(0xb0, 1, 0, 0).then((v) => {\n        const res = Uint8Array.from(v)\n        const appName = Binary.fromBytes(res.slice(2, 2 + res[1])).asText()\n        const appVersion = Binary.fromBytes(\n          res.slice(2 + res[1] + 1, 2 + res[1] + 1 + res[2 + res[1]]),\n        ).asText()\n        return { appName, appVersion }\n      })\n    return this.#appInfo\n  }\n\n  /**\n   * Get unique identifier of the seed phrase. It is useful to uniquely identify\n   * each device/seed that is connected.\n   *\n   * This call prevents race conditions and waits until the device is free to\n   * receive new messages.\n   *\n   * @returns DeviceId.\n   * @throws This could throw if the device is not connected, locked, in a\n   *         different app than Polkadot, etc.\n   */\n  async deviceId(): Promise<number> {\n    if (!this.#deviceId)\n      this.#deviceId = this.#getPublicKeyAndAddr(0, 0).then((v) =>\n        u32.dec(v.slice(0, 4)),\n      )\n    return this.#deviceId\n  }\n\n  async #getPublicKeyAndAddr(\n    path1: number,\n    path2: number,\n    seeAddressInDevice?: boolean,\n    ss58Prefix?: number,\n  ): Promise<Uint8Array> {\n    const key = `${this.#schema}:${path1}:${path2}`\n    if (!seeAddressInDevice && this.#pubkeys.has(key))\n      return this.#pubkeys.get(key)!\n    if (\n      ss58Prefix != null &&\n      (!Number.isInteger(ss58Prefix) || ss58Prefix < 0 || ss58Prefix >= 1 << 16) // u16 max value\n    )\n      throw new Error(`Invalid ss58Prefix ${ss58Prefix}`)\n    const bufToSend = Buffer.from(\n      // id + ss58 prefix\n      mergeUint8(\n        encodePath(path1, path2),\n        Uint8Array.from(u16.enc(ss58Prefix ?? DEFAULT_SS58)),\n      ),\n    )\n    const prom = this.#safeSend(\n      CLA,\n      INS.getAddress,\n      seeAddressInDevice ? P1.showAddress : P1.getAddress,\n      P2[this.#schema],\n      bufToSend,\n    ).then((v) => Uint8Array.from(v).slice(0, -2)) // remove return code\n    this.#pubkeys.set(key, prom)\n    return prom\n  }\n\n  /**\n   * Get pubkey for a specific derivation path.\n   *\n   * This call prevents race conditions and waits until the device is free to\n   * receive new messages.\n   *\n   * @param path1  Primary derivation index.\n   * @param path2  Secondary derivation index. Defaults to 0.\n   * @returns Public key.\n   * @throws This could throw if the device is not connected, locked, in a\n   *         different app than Polkadot, etc.\n   */\n  async getPubkey(path1: number, path2: number = 0): Promise<Uint8Array> {\n    return await this.#getPublicKeyAndAddr(path1, path2).then((v) =>\n      v.slice(0, PUBKEY_LEN[this.#schema]),\n    )\n  }\n\n  /**\n   * Show address in device's screen.\n   *\n   * This call prevents race conditions and waits until the device is free to\n   * receive new messages.\n   *\n   * @param ss58Prefix  SS58 prefix for address formatting. This is only\n   *                    relevant for `ed25519` schema.\n   * @param path1       Primary derivation index.\n   * @param path2       Secondary derivation index. Defaults to 0.\n   * @returns Public key.\n   * @throws This could throw if the device is not connected, locked, in a\n   *         different app than Polkadot, etc.\n   */\n  async seeAddressInDevice(\n    ss58Prefix: number,\n    path1: number,\n    path2: number = 0,\n  ): Promise<Uint8Array> {\n    return await this.#getPublicKeyAndAddr(path1, path2, true, ss58Prefix).then(\n      (v) => v.slice(0, PUBKEY_LEN[this.#schema]),\n    )\n  }\n\n  /**\n   * Get `AccountId20` (ETH-like) for a specific derivation path.\n   *\n   * This call prevents race conditions and waits until the device is free to\n   * receive new messages.\n   *\n   * @param path1  Primary derivation index.\n   * @param path2  Secondary derivation index. Defaults to 0.\n   * @returns AccountId20.\n   * @throws This could throw if the device is not connected, locked, in a\n   *         different app than Polkadot, etc. It throws as well if the\n   *         schema is `ed25519`.\n   */\n  async getAddress20(path1: number, path2: number = 0): Promise<HexString> {\n    if (this.#schema !== \"ecdsa\")\n      throw new Error(\"This method only supports `ecdsa` schema.\")\n    return await this.#getPublicKeyAndAddr(path1, path2).then((v) =>\n      ethAccount.dec(v.slice(PUBKEY_LEN[this.#schema])),\n    )\n  }\n\n  async #sign(\n    path1: number,\n    path2: number,\n    payload: Uint8Array,\n    // without shortMetadata indicates signBytes\n    shortMetadata?: Uint8Array,\n  ): Promise<Uint8Array> {\n    const path = encodePath(path1, path2)\n    const chunks: Buffer[] = []\n    chunks.push(Buffer.from(mergeUint8(path, u16.enc(payload.length))))\n    const combinedPayload =\n      shortMetadata == null ? payload : mergeUint8(payload, shortMetadata)\n    let offset = 0\n    while (offset < combinedPayload.length) {\n      const chunkEnd = Math.min(offset + 250, combinedPayload.length)\n      chunks.push(Buffer.from(combinedPayload.slice(offset, chunkEnd)))\n      offset = chunkEnd\n    }\n    let result\n    for (let i = 0; i < chunks.length; i++) {\n      result = await this.#safeSend(\n        CLA,\n        shortMetadata == null ? INS.signRaw : INS.signTx,\n        i === 0 ? P1.init : i === chunks.length - 1 ? P1.end : P1.continue,\n        P2[this.#schema],\n        chunks[i],\n      )\n    }\n    if (result == null) throw null\n\n    // remove return code\n    return Uint8Array.from(result).slice(\n      0,\n      // ed25519 includes as well a `0x00` at the beginning\n      SIGN_LEN[this.#schema] + (this.#schema === \"ed25519\" ? 1 : 0),\n    )\n  }\n\n  /**\n   * Create PolkadotSigner object from a specific derivation path and for a\n   * specific network.\n   *\n   * This call prevents race conditions and waits until the device is free to\n   * receive new messages.\n   *\n   * @param networkInfo  Off-chain info required to sign transactions. This\n   *                     makes this object be network-specific.\n   * @param path1        Primary derivation index.\n   * @param path2        Secondary derivation index. Defaults to 0.\n   * @returns PolkadotSigner object.\n   * @throws This could throw if the device is not connected, locked, in a\n   *         different app than Polkadot, etc.\n   */\n  async getPolkadotSigner(\n    networkInfo: { decimals: number; tokenSymbol: string },\n    path1: number,\n    path2: number = 0,\n  ): Promise<PolkadotSigner> {\n    // ed25519 has public key, ecdsa has addr (20 bytes)\n    const publicKey = await this.#getPublicKeyAndAddr(path1, path2).then((v) =>\n      this.#schema === \"ed25519\"\n        ? v.slice(0, PUBKEY_LEN[this.#schema])\n        : v.slice(PUBKEY_LEN[this.#schema]),\n    )\n    const signTx: PolkadotSigner[\"signTx\"] = async (\n      callData,\n      signedExtensions,\n      metadata,\n    ) => {\n      const merkleizer = merkleizeMetadata(metadata, networkInfo)\n      const digest = merkleizer.digest()\n      const meta = getMetadata(metadata)\n      if (\n        meta.extrinsic.signedExtensions.find(\n          ({ identifier }) => identifier === METADATA_IDENTIFIER,\n        ) == null\n      )\n        throw new Error(\"No `CheckMetadataHash` sigExt found\")\n      const extra: Array<Uint8Array> = []\n      const additionalSigned: Array<Uint8Array> = []\n      meta.extrinsic.signedExtensions.map(({ identifier }) => {\n        if (identifier === METADATA_IDENTIFIER) {\n          extra.push(Uint8Array.from([1]))\n          additionalSigned.push(mergeUint8(Uint8Array.from([1]), digest))\n          return\n        }\n        const signedExtension = signedExtensions[identifier]\n        if (!signedExtension)\n          throw new Error(`Missing ${identifier} signed extension`)\n        extra.push(signedExtension.value)\n        additionalSigned.push(signedExtension.additionalSigned)\n      })\n      const toSign = mergeUint8(callData, ...extra, ...additionalSigned)\n      const signature = await this.#sign(\n        path1,\n        path2,\n        toSign,\n        merkleizer.getProofForExtrinsicPayload(toSign),\n      )\n      return createV4Tx(meta, publicKey, signature, extra, callData)\n    }\n\n    return {\n      publicKey,\n      signTx,\n      signBytes: getSignBytes(async (x) =>\n        // the signature includes a \"0x00\" at the beginning, indicating a ed25519 signature, ecdsa do not\n        // this is not needed for non-extrinsic signatures\n        (await this.#sign(path1, path2, x)).slice(\n          this.#schema === \"ed25519\" ? 1 : 0,\n        ),\n      ),\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAOa,IAAA,cAAc,CACzB,UAC6B;AACzB,MAAA;AACF,UAAM,WAAW,cAAc,eAAe,KAAK,CAAC;AACpD,QAAI,SAAS,WAAW,GAAU,OAAA,IAAI,MAAM,wBAAwB;AAC7D,WAAA;EAAA,SACA,GAAG;AACJ,UAAA,KAAK,IAAI,MAAM,2BAA2B;EAAA;AAEpD;;;ACjBO,IAAM,MAAM;AACZ,IAAM,MAAM;EAEjB,YAAY;EACZ,QAAQ;EACR,SAAS;AACX;AACO,IAAM,KAAK;;EAEhB,MAAM;EACN,UAAU;EACV,KAAK;;EAGL,YAAY;EACZ,aAAa;AACf;AACO,IAAM,KAAK;EAChB,SAAS;EACT,OAAO;AACT;AACO,IAAM,aAAa;EACxB,SAAS;EACT,OAAO;AACT;AACO,IAAM,WAAW;EACtB,SAAS;EACT,OAAO;AACT;AACO,IAAM,eAAe;;;;;;;;;;;AC7B5B,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAeA,IAAM,sBAAsB;AAG5B,IAAM,aAAa,WAAW,KAAK,CAAC,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,GAAG,GAAG,CAAC;AAEjE,IAAM,WAAW,WAAW,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC;AAC/C,IAAM,WAAW;AACjB,IAAM,aAAa,CAAC,OAAe,UAAkB;AAEnD,MACE,CAAC,OAAO,UAAU,KAAK,KACvB,QAAQ,KACR,SAAS,YACT,CAAC,OAAO,UAAU,KAAK,KACvB,QAAQ,KACR,SAAS;AAET,UAAM,IAAI,MAAM,yBAAyB,KAAK,KAAK,KAAK,EAAE;AAErD,SAAA;IACL;IACA,IAAI,IAAI,WAAW,KAAK;IACxB;IACA,IAAI,IAAI,WAAW,KAAK;EAAA;AAE5B;AAOO,IAAM,eAAN,MAAmB;;;;;EAYxB,YAAY,WAAsB,SAA8B,WAAW;AAZtE,iBAAA,MAAA,uBAAA;AACI,iBAAA,MAAA,UAAA;AACA,iBAAA,MAAA,OAAA;AACT,iBAAA,MAAA,QAAA;AACA,iBAAA,MAAA,SAAA;AACA,iBAAA,MAAA,QAAA;AACA,iBAAA,MAAA,SAAA;AAOE,iBAAA,MAAK,WAAY,IAAA;AACjB,iBAAA,MAAK,UAAW,IAAA;AAChB,iBAAA,MAAK,WAAY,IAAA;AACjB,iBAAA,MAAK,YAAa,SAAA;AAClB,iBAAA,MAAK,SAAU,MAAA;AACV,iBAAA,MAAA,UAAA,oBAAe,IAAI,CAAA;EAAA;;;;;;;;;;EAwC1B,MAAM,UAGH;AAED,QAAI,CAAC,aAAK,MAAA,QAAA;AACH,mBAAA,MAAA,UAAW,gBAAK,MAAA,yBAAA,OAAA,EAAL,KAAW,MAAA,KAAM,GAAG,GAAG,CAAA,EAAG,KAAK,CAAC,MAAM;AAC9C,cAAA,MAAM,WAAW,KAAK,CAAC;AAC7B,cAAM,UAAU,OAAO,UAAU,IAAI,MAAM,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE,OAAO;AAClE,cAAM,aAAa,OAAO;UACxB,IAAI,MAAM,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;QAAA,EAC1D,OAAO;AACF,eAAA,EAAE,SAAS,WAAW;MAAA,CAC9B,CAAA;AACH,WAAO,aAAK,MAAA,QAAA;EAAA;;;;;;;;;;;;EAcd,MAAM,WAA4B;AAChC,QAAI,CAAC,aAAK,MAAA,SAAA;AACR,mBAAA,MAAK,WAAY,gBAAA,MAAK,yBAAL,sBAAA,EAAA,KAAA,MAA0B,GAAG,CAAG,EAAA;QAAK,CAAC,MACrD,IAAI,IAAI,EAAE,MAAM,GAAG,CAAC,CAAC;MAAA,CACvB;AACF,WAAO,aAAK,MAAA,SAAA;EAAA;;;;;;;;;;;;;EA+Cd,MAAM,UAAU,OAAe,QAAgB,GAAwB;AACrE,WAAO,MAAM,gBAAA,MAAK,yBAAL,sBAAA,EAAA,KAAA,MAA0B,OAAO,KAAO,EAAA;MAAK,CAAC,MACzD,EAAE,MAAM,GAAG,WAAW,aAAA,MAAK,OAAA,CAAO,CAAC;IAAA;EACrC;;;;;;;;;;;;;;;EAiBF,MAAM,mBACJ,YACA,OACA,QAAgB,GACK;AACrB,WAAO,MAAM,gBAAK,MAAA,yBAAA,sBAAA,EAAL,KAAA,MAA0B,OAAO,OAAO,MAAM,UAAY,EAAA;MACrE,CAAC,MAAM,EAAE,MAAM,GAAG,WAAW,aAAA,MAAK,OAAA,CAAO,CAAC;IAAA;EAC5C;;;;;;;;;;;;;;EAgBF,MAAM,aAAa,OAAe,QAAgB,GAAuB;AACvE,QAAI,aAAA,MAAK,OAAY,MAAA;AACb,YAAA,IAAI,MAAM,2CAA2C;AAC7D,WAAO,MAAM,gBAAA,MAAK,yBAAL,sBAAA,EAAA,KAAA,MAA0B,OAAO,KAAO,EAAA;MAAK,CAAC,MACzD,WAAW,IAAI,EAAE,MAAM,WAAW,aAAA,MAAK,OAAO,CAAA,CAAC,CAAC;IAAA;EAClD;;;;;;;;;;;;;;;;EAwDF,MAAM,kBACJ,aACA,OACA,QAAgB,GACS;AAEzB,UAAM,YAAY,MAAM,gBAAA,MAAK,yBAAL,sBAAA,EAAA,KAAA,MAA0B,OAAO,KAAO,EAAA;MAAK,CAAC,MACpE,aAAA,MAAK,OAAA,MAAY,YACb,EAAE,MAAM,GAAG,WAAW,aAAK,MAAA,OAAA,CAAO,CAAC,IACnC,EAAE,MAAM,WAAW,aAAA,MAAK,OAAA,CAAO,CAAC;IAAA;AAEtC,UAAM,SAAmC,OACvC,UACA,kBACA,aACG;AACG,YAAA,aAAa,kBAAkB,UAAU,WAAW;AACpD,YAAA,SAAS,WAAW,OAAO;AAC3B,YAAA,OAAO,YAAY,QAAQ;AAE/B,UAAA,KAAK,UAAU,iBAAiB;QAC9B,CAAC,EAAE,WAAW,MAAM,eAAe;MAAA,KAChC;AAEC,cAAA,IAAI,MAAM,qCAAqC;AACvD,YAAM,QAA2B,CAAA;AACjC,YAAM,mBAAsC,CAAA;AAC5C,WAAK,UAAU,iBAAiB,IAAI,CAAC,EAAE,WAAA,MAAiB;AACtD,YAAI,eAAe,qBAAqB;AACtC,gBAAM,KAAK,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC;AACd,2BAAA,KAAK,WAAW,WAAW,KAAK,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC;AAC9D;QAAA;AAEI,cAAA,kBAAkB,iBAAiB,UAAU;AACnD,YAAI,CAAC;AACH,gBAAM,IAAI,MAAM,WAAW,UAAU,mBAAmB;AACpD,cAAA,KAAK,gBAAgB,KAAK;AACf,yBAAA,KAAK,gBAAgB,gBAAgB;MAAA,CACvD;AACD,YAAM,SAAS,WAAW,UAAU,GAAG,OAAO,GAAG,gBAAgB;AAC3D,YAAA,YAAY,MAAM,gBAAA,MAAK,yBAAL,OAAA,EAAA,KAAA,MACtB,OACA,OACA,QACA,WAAW,4BAA4B,MAAM,CAAA;AAE/C,aAAO,WAAW,MAAM,WAAW,WAAW,OAAO,QAAQ;IAAA;AAGxD,WAAA;MACL;MACA;MACA,WAAW;QAAa,OAAO;;;WAG5B,MAAM,gBAAK,MAAA,yBAAA,OAAA,EAAL,KAAW,MAAA,OAAO,OAAO,CAAI,GAAA;YAClC,aAAA,MAAK,OAAY,MAAA,YAAY,IAAI;UAAA;;MACnC;IACF;EACF;AAEJ;AA9SW,aAAA,oBAAA,QAAA;AACA,UAAA,oBAAA,QAAA;AACT,WAAA,oBAAA,QAAA;AACA,YAAA,oBAAA,QAAA;AACA,WAAA,oBAAA,QAAA;AACA,YAAA,oBAAA,QAAA;AANK,0BAAA,oBAAA,QAAA;AAqBC,UAAK,kBACN,QAC4B;AAC/B,SAAO,aAAA,MAAK,UAAW,EAAA;AACrB,UAAM,aAAA,MAAK,UAAW,EAAA;AACxB,SAAO,MAAM,aAAA,MAAK,UAAW,EAAA,KAAK,GAAG,MAAM;AAC7C;AAEM,cAAS,kBACV,QAC4B;AAC/B,MAAI,CAAC,aAAK,MAAA,SAAA;AACH,iBAAA,MAAA,WAAY,KAAK,QAAQ,EAAE,KAAK,CAAC,EAAE,SAAS,WAAA,MAAiB;AAChE,UAAI,YAAY;AACR,cAAA,IAAI,MAAM,4BAA4B;AACxC,YAAA,UAAU,WAAW,MAAM,GAAG,EAAE,IAAI,CAAC,MAAM,SAAS,CAAC,CAAC;AAC5D;;QAEE,QAAQ,CAAC,IAAI;QAEZ,QAAQ,CAAC,MAAM,OAAO,QAAQ,CAAC,MAAM,KAAK,QAAQ,CAAC,IAAI;;AAExD,cAAM,IAAI,MAAM,wBAAwB,UAAU,eAAe;IAAA,CACpE,CAAA;AACH,QAAM,aAAK,MAAA,SAAA;AACX,SAAO,MAAM,gBAAA,MAAK,yBAAL,OAAA,EAAA,KAAA,MAAW,GAAG,MAAA;AAC7B;AA+CM,yBAAoB,eACxB,OACA,OACA,oBACA,YACqB;AACrB,QAAM,MAAM,GAAG,aAAA,MAAK,OAAA,CAAO,IAAI,KAAK,IAAI,KAAK;AAC7C,MAAI,CAAC,sBAAsB,aAAK,MAAA,QAAA,EAAS,IAAI,GAAG;AACvC,WAAA,aAAA,MAAK,QAAS,EAAA,IAAI,GAAG;AAE5B,MAAA,cAAc,SACb,CAAC,OAAO,UAAU,UAAU,KAAK,aAAa,KAAK,cAAc,KAAK;AAEvE,UAAM,IAAI,MAAM,sBAAsB,UAAU,EAAE;AACpD,QAAM,YAAY,OAAO;;IAEvB;MACE,WAAW,OAAO,KAAK;MACvB,WAAW,KAAK,IAAI,IAAI,cAAc,YAAY,CAAC;IAAA;EACrD;AAEI,QAAA,OAAO,gBAAK,MAAA,yBAAA,WAAA,EAAL,KACX,MAAA,KACA,IAAI,YACJ,qBAAqB,GAAG,cAAc,GAAG,YACzC,GAAG,aAAK,MAAA,OAAA,CAAO,GACf,SAAA,EACA,KAAK,CAAC,MAAM,WAAW,KAAK,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC;AACxC,eAAA,MAAA,QAAA,EAAS,IAAI,KAAK,IAAI;AACpB,SAAA;AACT;AAiEM,UAAK,eACT,OACA,OACA,SAEA,eACqB;AACf,QAAA,OAAO,WAAW,OAAO,KAAK;AACpC,QAAM,SAAmB,CAAA;AAClB,SAAA,KAAK,OAAO,KAAK,WAAW,MAAM,IAAI,IAAI,QAAQ,MAAM,CAAC,CAAC,CAAC;AAClE,QAAM,kBACJ,iBAAiB,OAAO,UAAU,WAAW,SAAS,aAAa;AACrE,MAAI,SAAS;AACN,SAAA,SAAS,gBAAgB,QAAQ;AACtC,UAAM,WAAW,KAAK,IAAI,SAAS,KAAK,gBAAgB,MAAM;AACvD,WAAA,KAAK,OAAO,KAAK,gBAAgB,MAAM,QAAQ,QAAQ,CAAC,CAAC;AACvD,aAAA;EAAA;AAEP,MAAA;AACJ,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,aAAS,MAAM,gBAAA,MAAK,yBAAL,WAAA,EAAA,KAAA,MACb,KACA,iBAAiB,OAAO,IAAI,UAAU,IAAI,QAC1C,MAAM,IAAI,GAAG,OAAO,MAAM,OAAO,SAAS,IAAI,GAAG,MAAM,GAAG,UAC1D,GAAG,aAAK,MAAA,OAAA,CAAO,GACf,OAAO,CAAC,CAAA;EAAA;AAGR,MAAA,UAAU,KAAY,OAAA;AAGnB,SAAA,WAAW,KAAK,MAAM,EAAE;IAC7B;;IAEA,SAAS,aAAK,MAAA,OAAA,CAAO,KAAK,aAAK,MAAA,OAAA,MAAY,YAAY,IAAI;EAAA;AAE/D;",
  "names": []
}
