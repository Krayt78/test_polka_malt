import {
  Blake3256,
  Bytes,
  Option,
  ScaleEnum,
  Struct,
  Tuple,
  Vector,
  _void,
  bool,
  compact,
  compactNumber,
  createDecoder,
  decAnyMetadata,
  enhanceDecoder,
  fromHex,
  getDynamicBuilder,
  getLookupFn,
  i128,
  i16,
  i256,
  i32,
  i64,
  i8,
  str,
  u128,
  u16,
  u256,
  u32,
  u64,
  u8,
  unifyMetadata
} from "./chunk-EVM4Y7G3.js";

// node_modules/.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/dist/esm/codecs.mjs
var extraInfoInner = {
  specVersion: u32,
  specName: str,
  base58Prefix: u16,
  decimals: u8,
  tokenSymbol: str
};
var extraInfo = Struct(extraInfoInner);
var hash = Bytes(32);
var metadataDigest = ScaleEnum({
  V0: _void,
  V1: Struct({
    typeInformationTreeRoot: hash,
    extrinsicMetadataHash: hash,
    ...extraInfoInner
  })
});
ScaleEnum({
  bool: _void,
  char: _void,
  str: _void,
  u8: _void,
  u16: _void,
  u32: _void,
  u64: _void,
  u128: _void,
  u256: _void,
  i8: _void,
  i16: _void,
  i32: _void,
  i64: _void,
  i128: _void,
  i256: _void
});
var typeRef = ScaleEnum({
  bool: _void,
  char: _void,
  str: _void,
  u8: _void,
  u16: _void,
  u32: _void,
  u64: _void,
  u128: _void,
  u256: _void,
  i8: _void,
  i16: _void,
  i32: _void,
  i64: _void,
  i128: _void,
  i256: _void,
  compactU8: _void,
  compactU16: _void,
  compactU32: _void,
  compactU64: _void,
  compactU128: _void,
  compactU256: _void,
  void: _void,
  perId: compactNumber
});
var field = Struct({
  name: Option(str),
  ty: typeRef,
  typeName: Option(str)
});
var typeDef = ScaleEnum({
  composite: Vector(field),
  enumeration: Struct({
    name: str,
    fields: Vector(field),
    index: compactNumber
  }),
  sequence: typeRef,
  array: Struct({
    len: u32,
    typeParam: typeRef
  }),
  tuple: Vector(typeRef),
  bitSequence: Struct({
    numBytes: u8,
    leastSignificantBitFirst: bool
  })
});
var lookupType = Struct({
  path: Vector(str),
  typeDef,
  typeId: compactNumber
});
var lookup = Vector(lookupType);
var extrinsicMetadata = Struct({
  version: u8,
  addressTy: typeRef,
  callTy: typeRef,
  signatureTy: typeRef,
  signedExtensions: Vector(
    Struct({
      identifier: str,
      includedInExtrinsic: typeRef,
      includedInSignedData: typeRef
    })
  )
});
var versionDecoder = enhanceDecoder(u8[1], (value) => ({
  version: value & -129,
  signed: !!(value & 1 << 7)
}));
var extrinsicDec = Tuple.dec(
  compact[1],
  versionDecoder,
  Bytes(Infinity)[1]
);
var proof = Struct({
  leaves: lookup,
  leafIdxs: Vector(u32),
  proofs: Vector(hash),
  extrinsic: extrinsicMetadata,
  info: extraInfo
});

// node_modules/.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/dist/esm/get-accessible-types.mjs
var getAccessibleTypes = (metadata, definitions) => {
  const types = /* @__PURE__ */ new Set();
  const collectTypesFromId = (id) => {
    if (types.has(id)) return;
    const { tag, value } = definitions.get(id).def;
    switch (tag) {
      case "composite":
        if (!value.length) break;
        types.add(id);
        value.forEach(({ type }) => {
          collectTypesFromId(type);
        });
        break;
      case "variant":
        if (!value.length) break;
        types.add(id);
        value.forEach(({ fields }) => {
          fields.forEach(({ type }) => {
            collectTypesFromId(type);
          });
        });
        break;
      case "tuple":
        if (!value.length) break;
        types.add(id);
        value.forEach(collectTypesFromId);
        break;
      case "sequence":
        types.add(id);
        collectTypesFromId(value);
        break;
      case "array":
        types.add(id);
        collectTypesFromId(value.type);
        break;
      case "bitSequence":
        types.add(id);
    }
  };
  collectTypesFromId(metadata.extrinsic.call);
  collectTypesFromId(metadata.extrinsic.address);
  collectTypesFromId(metadata.extrinsic.signature);
  metadata.extrinsic.signedExtensions.forEach(({ type, additionalSigned }) => {
    collectTypesFromId(type);
    collectTypesFromId(additionalSigned);
  });
  const sortedTypes = [...types].sort((a, b) => a - b);
  return new Map(sortedTypes.map((value, idx) => [value, idx]));
};

// node_modules/.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/dist/esm/get-lookup.mjs
var bitSequenceBytes = {
  u8: 1,
  u16: 2,
  u32: 4,
  u64: 8
};
var constructTypeDef = (definitions, getTypeRef, getPrimitive, frameId) => {
  const {
    def: { tag, value }
  } = definitions.get(frameId);
  switch (tag) {
    case "composite":
      return [
        {
          tag,
          value: value.map((f) => ({
            name: f.name,
            typeName: f.typeName,
            ty: getTypeRef(f.type)
          }))
        }
      ];
    case "variant": {
      return value.map((v) => ({
        tag: "enumeration",
        value: {
          name: v.name,
          index: v.index,
          fields: v.fields.map((f) => ({
            name: f.name,
            typeName: f.typeName,
            ty: getTypeRef(f.type)
          }))
        }
      }));
    }
    case "sequence":
      return [
        {
          tag,
          value: getTypeRef(value)
        }
      ];
    case "array":
      return [
        {
          tag,
          value: {
            len: value.len,
            typeParam: getTypeRef(value.type)
          }
        }
      ];
    case "tuple":
      return [
        {
          tag,
          value: value.map(getTypeRef)
        }
      ];
    case "bitSequence": {
      const primitive = getPrimitive(value.bitStoreType);
      const numBytes = bitSequenceBytes[primitive];
      if (!numBytes) throw new Error("Invalid primitive for BitSequence");
      const storeOrderPath = definitions.get(value.bitOrderType).path;
      const leastSignificantBitFirst = storeOrderPath.includes("Lsb0");
      if (!leastSignificantBitFirst && !storeOrderPath.includes("Msb0"))
        throw new Error("BitOrderType not recognized");
      return [
        {
          tag: "bitSequence",
          value: { numBytes, leastSignificantBitFirst }
        }
      ];
    }
  }
  throw new Error(`FrameId(${frameId}) should have been filtered out`);
};
var getLookup = (definitions, accessibleTypes, getTypeRef, getPrimitive) => {
  const typeTree = [];
  [...accessibleTypes.entries()].forEach(([frameId, typeId]) => {
    const { path } = definitions.get(frameId);
    constructTypeDef(definitions, getTypeRef, getPrimitive, frameId).forEach(
      (typeDef2) => {
        typeTree.push({
          path,
          typeId,
          typeDef: typeDef2
        });
      }
    );
  });
  typeTree.sort((a, b) => {
    if (a.typeId !== b.typeId) return a.typeId - b.typeId;
    if (a.typeDef.tag !== "enumeration" || b.typeDef.tag !== "enumeration")
      throw new Error("Found two types with same id");
    return a.typeDef.value.index - b.typeDef.value.index;
  });
  return typeTree;
};

// node_modules/.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/dist/esm/get-metadata.mjs
var getMetadata = (input) => {
  try {
    const metadata = unifyMetadata(decAnyMetadata(input));
    if (metadata.version <= 14) throw new Error("Wrong metadata version");
    return metadata;
  } catch (e) {
    throw e || new Error("Unable to decode metadata");
  }
};

// node_modules/.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/dist/esm/utils.mjs
var mergeUint8 = (inputs) => {
  const len = inputs.length;
  let totalLen = 0;
  for (let i = 0; i < len; i++) totalLen += inputs[i].byteLength;
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < len; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};
var toBytes = (input) => typeof input === "string" ? fromHex(input) : input;
var compactTypeRefs = {
  null: "void",
  u8: "compactU8",
  u16: "compactU16",
  u32: "compactU32",
  u64: "compactU64",
  u128: "compactU128",
  u256: "compactU256"
};

// node_modules/.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/dist/esm/decode-and-collect.mjs
var typeRefDecoders = {
  bool: u8,
  char: u8,
  str,
  u8,
  u16,
  u32,
  u64,
  u128,
  u256,
  i8,
  i16,
  i32,
  i64,
  i128,
  i256,
  void: _void,
  compactU8: compact,
  compactU16: compact,
  compactU32: compact,
  compactU64: compact,
  compactU128: compact,
  compactU256: compact
};
var innerDecodeAndCollect = (input, typeRef2, idToLookups, lookup2, collected) => {
  if (typeRef2.tag !== "perId") {
    typeRefDecoders[typeRef2.tag][1](input);
    return;
  }
  const handleTypeRef = (typeRef22) => {
    innerDecodeAndCollect(input, typeRef22, idToLookups, lookup2, collected);
  };
  const lookupIdxs = idToLookups.get(typeRef2.value);
  const [currentIdx] = lookupIdxs;
  const current = lookup2[currentIdx];
  if (lookupIdxs.length === 1) collected.add(currentIdx);
  switch (current.typeDef.tag) {
    case "enumeration": {
      const selectedIdx = u8.dec(input);
      const [selected, collectedIdx] = lookupIdxs.map(
        (lookupIdx) => [lookup2[lookupIdx].typeDef, lookupIdx]
      ).find(([x]) => x.value.index === selectedIdx);
      collected.add(collectedIdx);
      selected.value.fields.forEach(({ ty }) => {
        handleTypeRef(ty);
      });
      break;
    }
    case "sequence": {
      const len = compact.dec(input);
      for (let i = 0; i < len; i++) handleTypeRef(current.typeDef.value);
      break;
    }
    case "array": {
      for (let i = 0; i < current.typeDef.value.len; i++)
        handleTypeRef(current.typeDef.value.typeParam);
      break;
    }
    case "composite": {
      current.typeDef.value.forEach((x) => {
        handleTypeRef(x.ty);
      });
      break;
    }
    case "tuple": {
      current.typeDef.value.forEach(handleTypeRef);
      break;
    }
    case "bitSequence":
      throw new Error("bitSequence is not supported");
  }
};
var decodeAndCollectKnownLeafs = (data, typeRefs, lookup2) => {
  let input = new Uint8Array();
  createDecoder((_input) => {
    input = _input;
  })(data);
  const idToLookups = /* @__PURE__ */ new Map();
  lookup2.forEach((lookup22, idx) => {
    const arr = idToLookups.get(lookup22.typeId);
    if (arr) arr.push(idx);
    else idToLookups.set(lookup22.typeId, [idx]);
  });
  const result = /* @__PURE__ */ new Set();
  typeRefs.forEach((typeRef2) => {
    innerDecodeAndCollect(input, typeRef2, idToLookups, lookup2, result);
  });
  return [...result].sort((a, b) => a - b);
};

// node_modules/.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/dist/esm/proof.mjs
var getLevelFromIdx = (idx) => Math.log2(idx + 1) | 0;
var getAncestorIdx = (from, nLevels) => (from + 1 >> nLevels) - 1;
function getProofData(leaves, knownLeavesIdxs) {
  const knownLeaves = knownLeavesIdxs.map((idx) => leaves[idx]);
  const startingIdx = leaves.length - 1;
  const leafIdxs = knownLeavesIdxs.map((idx) => startingIdx + idx);
  const proofIdxs = [];
  if (leafIdxs.length) {
    const nLevels = getLevelFromIdx(leafIdxs.at(-1));
    const splitPosition = Math.pow(2, nLevels) - 1;
    const splitIdx = leafIdxs.findIndex((x) => x >= splitPosition);
    if (splitIdx > 0) {
      leafIdxs.unshift(...leafIdxs.splice(splitIdx));
      knownLeaves.unshift(...knownLeaves.splice(splitIdx));
    }
  }
  let targetIdx = 0;
  const traverse = (nodeIdx) => {
    if (targetIdx === leafIdxs.length) {
      proofIdxs.push(nodeIdx);
      return;
    }
    const target = leafIdxs[targetIdx];
    if (target === nodeIdx) {
      ++targetIdx;
      return;
    }
    const currentLevel = getLevelFromIdx(nodeIdx);
    const targetLevel = getLevelFromIdx(target);
    if (nodeIdx !== getAncestorIdx(target, targetLevel - currentLevel)) {
      proofIdxs.push(nodeIdx);
      return;
    }
    const leftSon = 2 * nodeIdx + 1;
    traverse(leftSon);
    traverse(leftSon + 1);
  };
  traverse(0);
  return {
    leaves: knownLeaves,
    leafIdxs,
    proofIdxs
  };
}

// node_modules/.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/dist/esm/main.mjs
var assertExpected = (name, expected, received) => {
  if (received != null && received !== expected)
    throw new Error(
      `${name} not expected. Received ${received} expected ${expected}`
    );
};
var merkleizeMetadata = (metadataBytes, {
  decimals,
  tokenSymbol,
  ...hinted
}) => {
  var _a;
  const metadata = getMetadata(metadataBytes);
  const checkedVersion = metadata.extrinsic.version.includes(4) ? 4 : null;
  if (checkedVersion == null) throw new Error("Only extrinsic v4 is supported");
  const { ss58Prefix, buildDefinition } = getDynamicBuilder(
    getLookupFn(metadata)
  );
  if (ss58Prefix == null) throw new Error("SS58 prefix not found in metadata");
  assertExpected("SS58 prefix", ss58Prefix, hinted.base58Prefix);
  const version = (_a = metadata.pallets.find((x) => x.name === "System")) == null ? void 0 : _a.constants.find((x) => x.name === "Version");
  if (version == null) throw new Error("System.Version constant not found");
  const { spec_name: specName, spec_version: specVersion } = buildDefinition(
    version.type
  ).dec(version.value);
  if (typeof specName !== "string" || typeof specVersion !== "number")
    throw new Error("Spec name or spec version not found");
  assertExpected("Spec name", specName, hinted.specName);
  assertExpected("Spec version", specVersion, hinted.specVersion);
  const info = {
    decimals,
    tokenSymbol,
    specVersion,
    specName,
    base58Prefix: ss58Prefix
  };
  const definitions = new Map(
    metadata.lookup.map((value) => [value.id, value])
  );
  const accessibleTypes = getAccessibleTypes(metadata, definitions);
  const getPrimitive = (frameId) => {
    const {
      def: { tag, value }
    } = definitions.get(frameId);
    if (tag === "primitive") return value.tag;
    if (tag !== "composite" && tag !== "tuple" || value.length > 1)
      throw new Error("The provided definition doesn't map to a primitive");
    return value.length === 0 ? null : getPrimitive(tag === "tuple" ? value[0] : value[0].type);
  };
  const getTypeRef = (frameId) => {
    const { def } = definitions.get(frameId);
    if (def.tag === "primitive") return { tag: def.value.tag, value: void 0 };
    if (def.tag === "compact") {
      const primitive = getPrimitive(def.value);
      const tag = compactTypeRefs[primitive];
      if (!tag) throw new Error("Invalid primitive for Compact");
      return { tag, value: void 0 };
    }
    return accessibleTypes.has(frameId) ? { tag: "perId", value: accessibleTypes.get(frameId) } : { tag: "void", value: void 0 };
  };
  const extrinsic = {
    version: checkedVersion,
    addressTy: getTypeRef(metadata.extrinsic.address),
    callTy: getTypeRef(metadata.extrinsic.call),
    signatureTy: getTypeRef(metadata.extrinsic.signature),
    signedExtensions: metadata.extrinsic.signedExtensions.map((se) => ({
      identifier: se.identifier,
      includedInExtrinsic: getTypeRef(se.type),
      includedInSignedData: getTypeRef(se.additionalSigned)
    }))
  };
  const lookup2 = getLookup(
    definitions,
    accessibleTypes,
    getTypeRef,
    getPrimitive
  );
  const lookupEncoded = lookup2.map(lookupType.enc);
  let hashTree;
  const getHashTree = () => {
    if (hashTree) return hashTree;
    if (!lookupEncoded.length) return hashTree = [new Uint8Array(32).fill(0)];
    hashTree = new Array(lookupEncoded.length * 2 - 1);
    let leavesStartIdx = lookupEncoded.length - 1;
    for (let i = 0; i < lookupEncoded.length; i++)
      hashTree[leavesStartIdx + i] = Blake3256(lookupEncoded[i]);
    for (let i = hashTree.length - 2; i > 0; i -= 2)
      hashTree[(i - 1) / 2] = Blake3256(
        mergeUint8([hashTree[i], hashTree[i + 1]])
      );
    return hashTree;
  };
  let digested;
  const digest = () => {
    if (digested) return digested;
    const rootLookupHash = getHashTree()[0];
    const digest2 = {
      tag: "V1",
      value: {
        typeInformationTreeRoot: rootLookupHash,
        extrinsicMetadataHash: Blake3256(extrinsicMetadata.enc(extrinsic)),
        ...info
      }
    };
    return digested = Blake3256(metadataDigest.enc(digest2));
  };
  const generateProof = (knownIndexes) => {
    const proofData = getProofData(lookupEncoded, knownIndexes);
    const hashTree2 = getHashTree();
    const proofs = proofData.proofIdxs.map((idx) => hashTree2[idx]);
    return mergeUint8([
      compact.enc(proofData.leaves.length),
      ...proofData.leaves,
      compact.enc(proofData.leafIdxs.length),
      ...proofData.leafIdxs.map((x) => u32.enc(x)),
      compact.enc(proofs.length),
      ...proofs,
      extrinsicMetadata.enc(extrinsic),
      extraInfo.enc(info)
    ]);
  };
  const getProofForExtrinsicPayload = (extrinsicPayload) => {
    const typeRefs = [
      extrinsic.callTy,
      ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),
      ...extrinsic.signedExtensions.map((x) => x.includedInSignedData)
    ];
    return generateProof(
      decodeAndCollectKnownLeafs(extrinsicPayload, typeRefs, lookup2)
    );
  };
  const getProofForExtrinsicParts = (callData, includedInExtrinsic, includedInSignedData) => {
    const bytes = mergeUint8(
      [callData, includedInExtrinsic, includedInSignedData].map(toBytes)
    );
    return getProofForExtrinsicPayload(bytes);
  };
  const getProofForExtrinsic = (transaction, txAdditionalSigned) => {
    let [, { version: version2, signed }, bytes] = extrinsicDec(transaction);
    if (version2 !== extrinsic.version)
      throw new Error("Incorrect extrinsic version");
    const typeRefs = signed ? [
      extrinsic.addressTy,
      extrinsic.signatureTy,
      ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),
      extrinsic.callTy
    ] : [extrinsic.callTy];
    if (txAdditionalSigned) {
      bytes = mergeUint8([bytes, toBytes(txAdditionalSigned)]);
      typeRefs.push(
        ...extrinsic.signedExtensions.map((x) => x.includedInSignedData)
      );
    }
    return generateProof(decodeAndCollectKnownLeafs(bytes, typeRefs, lookup2));
  };
  return {
    digest,
    getProofForExtrinsic,
    getProofForExtrinsicParts,
    getProofForExtrinsicPayload
  };
};

export {
  merkleizeMetadata
};
//# sourceMappingURL=chunk-6ZBYRXGS.js.map
