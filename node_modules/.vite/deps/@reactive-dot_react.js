"use client";
import "./chunk-IEHBY26R.js";
import {
  require_jsx_runtime
} from "./chunk-EKS5H333.js";
import {
  require_react
} from "./chunk-LPNUN4BZ.js";
import {
  Query,
  idle,
  pending
} from "./chunk-HH3KF7AJ.js";
import {
  aggregateWallets,
  connectWallet,
  disconnectWallet,
  getAccounts,
  getBlock,
  getClient,
  getConnectedWallets,
  nativeTokenInfoFromChainSpecData,
  preflight,
  query
} from "./chunk-Y7OA44XQ.js";
import "./chunk-HK3DZUUN.js";
import "./chunk-CGJMGULG.js";
import "./chunk-CH5HA4ZP.js";
import "./chunk-AKNCNGJG.js";
import "./chunk-6ZBYRXGS.js";
import {
  Binary
} from "./chunk-EVM4Y7G3.js";
import {
  BaseError,
  MutationError,
  initializeWallets
} from "./chunk-OVJJME56.js";
import {
  Subject,
  catchError,
  firstValueFrom,
  from,
  shareReplay,
  switchMap,
  tap
} from "./chunk-2T3XQHSK.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __publicField,
  __toESM
} from "./chunk-B4Q33VKO.js";

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/find-all-indexes.js
function findAllIndexes(array, predicate) {
  return array.reduce((indexes, item, index) => {
    if (predicate(item)) {
      indexes.push(index);
    }
    return indexes;
  }, []);
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/interlace.js
function interlace(array, itemsWithIndexes) {
  const result = array.slice();
  for (const [item, index] of itemsWithIndexes) {
    result.splice(index, 0, item);
  }
  return result;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/object-id.js
var objectIds = /* @__PURE__ */ new WeakMap();
function objectId(object) {
  if (object === null || typeof object !== "object") {
    return object;
  }
  return objectIds.get(object) ?? objectIds.set(object, globalThis.crypto.randomUUID()).get(object);
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/jotai/atom-family.js
function atomFamily(initializeAtom, getKey) {
  const empty3 = Symbol("empty");
  const atoms = /* @__PURE__ */ new Map();
  const _getKey = getKey ?? ((...args) => args.length === 0 ? empty3 : args.length === 1 ? args[0] : args.map(objectId).join());
  return Object.assign((...args) => {
    const key = _getKey(...args);
    return atoms.get(key) ?? atoms.set(key, initializeAtom(...args)).get(key);
  }, { delete: (...args) => atoms.delete(_getKey(...args)) });
}

// node_modules/.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/vanilla/internals.mjs
var isSelfAtom = (atom2, a) => atom2.unstable_is ? atom2.unstable_is(a) : a === atom2;
var hasInitialValue = (atom2) => "init" in atom2;
var isActuallyWritableAtom = (atom2) => !!atom2.write;
var isAtomStateInitialized = (atomState) => "v" in atomState || "e" in atomState;
var returnAtomValue = (atomState) => {
  if ("e" in atomState) {
    throw atomState.e;
  }
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("v" in atomState)) {
    throw new Error("[Bug] atom state is not initialized");
  }
  return atomState.v;
};
var promiseStateMap = /* @__PURE__ */ new WeakMap();
var isPendingPromise = (value) => {
  var _a;
  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);
};
var abortPromise = (promise) => {
  const promiseState = promiseStateMap.get(promise);
  if (promiseState == null ? void 0 : promiseState[0]) {
    promiseState[0] = false;
    promiseState[1].forEach((fn) => fn());
  }
};
var registerAbortHandler = (promise, abortHandler) => {
  let promiseState = promiseStateMap.get(promise);
  if (!promiseState) {
    promiseState = [true, /* @__PURE__ */ new Set()];
    promiseStateMap.set(promise, promiseState);
    const settle = () => {
      promiseState[0] = false;
    };
    promise.then(settle, settle);
  }
  promiseState[1].add(abortHandler);
};
var isPromiseLike = (p) => typeof (p == null ? void 0 : p.then) === "function";
var addPendingPromiseToDependency = (atom2, promise, dependencyAtomState) => {
  if (!dependencyAtomState.p.has(atom2)) {
    dependencyAtomState.p.add(atom2);
    promise.then(
      () => {
        dependencyAtomState.p.delete(atom2);
      },
      () => {
        dependencyAtomState.p.delete(atom2);
      }
    );
  }
};
var setAtomStateValueOrPromise = (atom2, valueOrPromise, ensureAtomState) => {
  const atomState = ensureAtomState(atom2);
  const hasPrevValue = "v" in atomState;
  const prevValue = atomState.v;
  if (isPromiseLike(valueOrPromise)) {
    for (const a of atomState.d.keys()) {
      addPendingPromiseToDependency(atom2, valueOrPromise, ensureAtomState(a));
    }
  }
  atomState.v = valueOrPromise;
  delete atomState.e;
  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
    ++atomState.n;
    if (isPromiseLike(prevValue)) {
      abortPromise(prevValue);
    }
  }
};
var getMountedOrPendingDependents = (atom2, atomState, mountedMap) => {
  var _a;
  const dependents = /* @__PURE__ */ new Set();
  for (const a of ((_a = mountedMap.get(atom2)) == null ? void 0 : _a.t) || []) {
    if (mountedMap.has(a)) {
      dependents.add(a);
    }
  }
  for (const atomWithPendingPromise of atomState.p) {
    dependents.add(atomWithPendingPromise);
  }
  return dependents;
};
var createStoreHook = () => {
  const callbacks = /* @__PURE__ */ new Set();
  const notify = () => {
    callbacks.forEach((fn) => fn());
  };
  notify.add = (fn) => {
    callbacks.add(fn);
    return () => {
      callbacks.delete(fn);
    };
  };
  return notify;
};
var createStoreHookForAtoms = () => {
  const all = {};
  const callbacks = /* @__PURE__ */ new WeakMap();
  const notify = (atom2) => {
    var _a, _b;
    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom2));
    (_b = callbacks.get(atom2)) == null ? void 0 : _b.forEach((fn) => fn());
  };
  notify.add = (atom2, fn) => {
    const key = atom2 || all;
    const fns = (callbacks.has(key) ? callbacks : callbacks.set(key, /* @__PURE__ */ new Set())).get(key);
    fns.add(fn);
    return () => {
      fns == null ? void 0 : fns.delete(fn);
      if (!fns.size) {
        callbacks.delete(key);
      }
    };
  };
  return notify;
};
var initializeStoreHooks = (storeHooks) => {
  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());
  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());
  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());
  storeHooks.f || (storeHooks.f = createStoreHook());
  return storeHooks;
};
var BUILDING_BLOCKS = Symbol();
var getBuildingBlocks = (store) => store[BUILDING_BLOCKS];
var buildStore = (atomStateMap = /* @__PURE__ */ new WeakMap(), mountedMap = /* @__PURE__ */ new WeakMap(), invalidatedAtoms = /* @__PURE__ */ new WeakMap(), changedAtoms = /* @__PURE__ */ new Set(), mountCallbacks = /* @__PURE__ */ new Set(), unmountCallbacks = /* @__PURE__ */ new Set(), storeHooks = {}, atomRead = (atom2, ...params) => atom2.read(...params), atomWrite = (atom2, ...params) => atom2.write(...params), atomOnInit = (atom2, store) => {
  var _a;
  return (_a = atom2.unstable_onInit) == null ? void 0 : _a.call(atom2, store);
}, atomOnMount = (atom2, setAtom) => {
  var _a;
  return (_a = atom2.onMount) == null ? void 0 : _a.call(atom2, setAtom);
}, ...buildingBlockFunctions) => {
  const ensureAtomState = buildingBlockFunctions[0] || ((atom2) => {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !atom2) {
      throw new Error("Atom is undefined or null");
    }
    let atomState = atomStateMap.get(atom2);
    if (!atomState) {
      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };
      atomStateMap.set(atom2, atomState);
      atomOnInit == null ? void 0 : atomOnInit(atom2, store);
    }
    return atomState;
  });
  const flushCallbacks = buildingBlockFunctions[1] || (() => {
    const errors = [];
    const call = (fn) => {
      try {
        fn();
      } catch (e) {
        errors.push(e);
      }
    };
    do {
      if (storeHooks.f) {
        call(storeHooks.f);
      }
      const callbacks = /* @__PURE__ */ new Set();
      const add = callbacks.add.bind(callbacks);
      changedAtoms.forEach((atom2) => {
        var _a;
        return (_a = mountedMap.get(atom2)) == null ? void 0 : _a.l.forEach(add);
      });
      changedAtoms.clear();
      unmountCallbacks.forEach(add);
      unmountCallbacks.clear();
      mountCallbacks.forEach(add);
      mountCallbacks.clear();
      callbacks.forEach(call);
      if (changedAtoms.size) {
        recomputeInvalidatedAtoms();
      }
    } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);
    if (errors.length) {
      throw new AggregateError(errors);
    }
  });
  const recomputeInvalidatedAtoms = buildingBlockFunctions[2] || (() => {
    const topSortedReversed = [];
    const visiting = /* @__PURE__ */ new WeakSet();
    const visited = /* @__PURE__ */ new WeakSet();
    const stack = Array.from(changedAtoms);
    while (stack.length) {
      const a = stack[stack.length - 1];
      const aState = ensureAtomState(a);
      if (visited.has(a)) {
        stack.pop();
        continue;
      }
      if (visiting.has(a)) {
        if (invalidatedAtoms.get(a) === aState.n) {
          topSortedReversed.push([a, aState]);
        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && invalidatedAtoms.has(a)) {
          throw new Error("[Bug] invalidated atom exists");
        }
        visited.add(a);
        stack.pop();
        continue;
      }
      visiting.add(a);
      for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
        if (!visiting.has(d)) {
          stack.push(d);
        }
      }
    }
    for (let i = topSortedReversed.length - 1; i >= 0; --i) {
      const [a, aState] = topSortedReversed[i];
      let hasChangedDeps = false;
      for (const dep of aState.d.keys()) {
        if (dep !== a && changedAtoms.has(dep)) {
          hasChangedDeps = true;
          break;
        }
      }
      if (hasChangedDeps) {
        readAtomState(a);
        mountDependencies(a);
      }
      invalidatedAtoms.delete(a);
    }
  });
  const readAtomState = buildingBlockFunctions[3] || ((atom2) => {
    var _a;
    const atomState = ensureAtomState(atom2);
    if (isAtomStateInitialized(atomState)) {
      if (mountedMap.has(atom2) && invalidatedAtoms.get(atom2) !== atomState.n) {
        return atomState;
      }
      if (Array.from(atomState.d).every(
        ([a, n]) => (
          // Recursively, read the atom state of the dependency, and
          // check if the atom epoch number is unchanged
          readAtomState(a).n === n
        )
      )) {
        return atomState;
      }
    }
    atomState.d.clear();
    let isSync = true;
    const mountDependenciesIfAsync = () => {
      if (mountedMap.has(atom2)) {
        mountDependencies(atom2);
        recomputeInvalidatedAtoms();
        flushCallbacks();
      }
    };
    const getter = (a) => {
      var _a2;
      if (isSelfAtom(atom2, a)) {
        const aState2 = ensureAtomState(a);
        if (!isAtomStateInitialized(aState2)) {
          if (hasInitialValue(a)) {
            setAtomStateValueOrPromise(a, a.init, ensureAtomState);
          } else {
            throw new Error("no atom init");
          }
        }
        return returnAtomValue(aState2);
      }
      const aState = readAtomState(a);
      try {
        return returnAtomValue(aState);
      } finally {
        atomState.d.set(a, aState.n);
        if (isPendingPromise(atomState.v)) {
          addPendingPromiseToDependency(atom2, atomState.v, aState);
        }
        (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom2);
        if (!isSync) {
          mountDependenciesIfAsync();
        }
      }
    };
    let controller;
    let setSelf;
    const options = {
      get signal() {
        if (!controller) {
          controller = new AbortController();
        }
        return controller.signal;
      },
      get setSelf() {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
          console.warn("setSelf function cannot be used with read-only atom");
        }
        if (!setSelf && isActuallyWritableAtom(atom2)) {
          setSelf = (...args) => {
            if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && isSync) {
              console.warn("setSelf function cannot be called in sync");
            }
            if (!isSync) {
              try {
                return writeAtomState(atom2, ...args);
              } finally {
                recomputeInvalidatedAtoms();
                flushCallbacks();
              }
            }
          };
        }
        return setSelf;
      }
    };
    const prevEpochNumber = atomState.n;
    try {
      const valueOrPromise = atomRead(atom2, getter, options);
      setAtomStateValueOrPromise(atom2, valueOrPromise, ensureAtomState);
      if (isPromiseLike(valueOrPromise)) {
        registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());
        valueOrPromise.then(
          mountDependenciesIfAsync,
          mountDependenciesIfAsync
        );
      }
      return atomState;
    } catch (error) {
      delete atomState.v;
      atomState.e = error;
      ++atomState.n;
      return atomState;
    } finally {
      isSync = false;
      if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom2) === prevEpochNumber) {
        invalidatedAtoms.set(atom2, atomState.n);
        changedAtoms.add(atom2);
        (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, atom2);
      }
    }
  });
  const invalidateDependents = buildingBlockFunctions[4] || ((atom2) => {
    const stack = [atom2];
    while (stack.length) {
      const a = stack.pop();
      const aState = ensureAtomState(a);
      for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
        const dState = ensureAtomState(d);
        invalidatedAtoms.set(d, dState.n);
        stack.push(d);
      }
    }
  });
  const writeAtomState = buildingBlockFunctions[5] || ((atom2, ...args) => {
    let isSync = true;
    const getter = (a) => returnAtomValue(readAtomState(a));
    const setter = (a, ...args2) => {
      var _a;
      const aState = ensureAtomState(a);
      try {
        if (isSelfAtom(atom2, a)) {
          if (!hasInitialValue(a)) {
            throw new Error("atom not writable");
          }
          const prevEpochNumber = aState.n;
          const v = args2[0];
          setAtomStateValueOrPromise(a, v, ensureAtomState);
          mountDependencies(a);
          if (prevEpochNumber !== aState.n) {
            changedAtoms.add(a);
            (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);
            invalidateDependents(a);
          }
          return void 0;
        } else {
          return writeAtomState(a, ...args2);
        }
      } finally {
        if (!isSync) {
          recomputeInvalidatedAtoms();
          flushCallbacks();
        }
      }
    };
    try {
      return atomWrite(atom2, getter, setter, ...args);
    } finally {
      isSync = false;
    }
  });
  const mountDependencies = buildingBlockFunctions[6] || ((atom2) => {
    var _a;
    const atomState = ensureAtomState(atom2);
    const mounted = mountedMap.get(atom2);
    if (mounted && !isPendingPromise(atomState.v)) {
      for (const [a, n] of atomState.d) {
        if (!mounted.d.has(a)) {
          const aState = ensureAtomState(a);
          const aMounted = mountAtom(a);
          aMounted.t.add(atom2);
          mounted.d.add(a);
          if (n !== aState.n) {
            changedAtoms.add(a);
            (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);
            invalidateDependents(a);
          }
        }
      }
      for (const a of mounted.d || []) {
        if (!atomState.d.has(a)) {
          mounted.d.delete(a);
          const aMounted = unmountAtom(a);
          aMounted == null ? void 0 : aMounted.t.delete(atom2);
        }
      }
    }
  });
  const mountAtom = buildingBlockFunctions[7] || ((atom2) => {
    var _a;
    const atomState = ensureAtomState(atom2);
    let mounted = mountedMap.get(atom2);
    if (!mounted) {
      readAtomState(atom2);
      for (const a of atomState.d.keys()) {
        const aMounted = mountAtom(a);
        aMounted.t.add(atom2);
      }
      mounted = {
        l: /* @__PURE__ */ new Set(),
        d: new Set(atomState.d.keys()),
        t: /* @__PURE__ */ new Set()
      };
      mountedMap.set(atom2, mounted);
      (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom2);
      if (isActuallyWritableAtom(atom2)) {
        const processOnMount = () => {
          let isSync = true;
          const setAtom = (...args) => {
            try {
              return writeAtomState(atom2, ...args);
            } finally {
              if (!isSync) {
                recomputeInvalidatedAtoms();
                flushCallbacks();
              }
            }
          };
          try {
            const onUnmount = atomOnMount(atom2, setAtom);
            if (onUnmount) {
              mounted.u = () => {
                isSync = true;
                try {
                  onUnmount();
                } finally {
                  isSync = false;
                }
              };
            }
          } finally {
            isSync = false;
          }
        };
        mountCallbacks.add(processOnMount);
      }
    }
    return mounted;
  });
  const unmountAtom = buildingBlockFunctions[8] || ((atom2) => {
    var _a;
    const atomState = ensureAtomState(atom2);
    let mounted = mountedMap.get(atom2);
    if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {
      var _a2;
      return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom2);
    })) {
      if (mounted.u) {
        unmountCallbacks.add(mounted.u);
      }
      mounted = void 0;
      mountedMap.delete(atom2);
      (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom2);
      for (const a of atomState.d.keys()) {
        const aMounted = unmountAtom(a);
        aMounted == null ? void 0 : aMounted.t.delete(atom2);
      }
      return void 0;
    }
    return mounted;
  });
  const buildingBlocks = [
    // store state
    atomStateMap,
    mountedMap,
    invalidatedAtoms,
    changedAtoms,
    mountCallbacks,
    unmountCallbacks,
    storeHooks,
    // atom interceptors
    atomRead,
    atomWrite,
    atomOnInit,
    atomOnMount,
    // building-block functions
    ensureAtomState,
    flushCallbacks,
    recomputeInvalidatedAtoms,
    readAtomState,
    invalidateDependents,
    writeAtomState,
    mountDependencies,
    mountAtom,
    unmountAtom
  ];
  const store = {
    get: (atom2) => returnAtomValue(readAtomState(atom2)),
    set: (atom2, ...args) => {
      try {
        return writeAtomState(atom2, ...args);
      } finally {
        recomputeInvalidatedAtoms();
        flushCallbacks();
      }
    },
    sub: (atom2, listener) => {
      const mounted = mountAtom(atom2);
      const listeners = mounted.l;
      listeners.add(listener);
      flushCallbacks();
      return () => {
        listeners.delete(listener);
        unmountAtom(atom2);
        flushCallbacks();
      };
    }
  };
  Object.defineProperty(store, BUILDING_BLOCKS, { value: buildingBlocks });
  return store;
};
var INTERNAL_buildStoreRev1 = buildStore;
var INTERNAL_getBuildingBlocksRev1 = getBuildingBlocks;
var INTERNAL_initializeStoreHooks = initializeStoreHooks;
var INTERNAL_isSelfAtom = isSelfAtom;
var INTERNAL_hasInitialValue = hasInitialValue;
var INTERNAL_isAtomStateInitialized = isAtomStateInitialized;
var INTERNAL_returnAtomValue = returnAtomValue;
var INTERNAL_registerAbortHandler = registerAbortHandler;
var INTERNAL_setAtomStateValueOrPromise = setAtomStateValueOrPromise;

// node_modules/.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/vanilla.mjs
var keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString() {
      return (import.meta.env ? import.meta.env.MODE : void 0) !== "production" && this.debugLabel ? key + ":" + this.debugLabel : key;
    }
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = defaultRead;
    config.write = defaultWrite;
  }
  if (write) {
    config.write = write;
  }
  return config;
}
function defaultRead(get) {
  return get(this);
}
function defaultWrite(get, set, arg) {
  return set(
    this,
    typeof arg === "function" ? arg(get(this)) : arg
  );
}
var createDevStoreRev4 = () => {
  let inRestoreAtom = 0;
  const storeHooks = INTERNAL_initializeStoreHooks({});
  const atomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedAtoms = /* @__PURE__ */ new WeakMap();
  const store = INTERNAL_buildStoreRev1(
    atomStateMap,
    mountedAtoms,
    void 0,
    void 0,
    void 0,
    void 0,
    storeHooks,
    void 0,
    (atom2, get, set, ...args) => {
      if (inRestoreAtom) {
        return set(atom2, ...args);
      }
      return atom2.write(get, set, ...args);
    }
  );
  const debugMountedAtoms = /* @__PURE__ */ new Set();
  storeHooks.m.add(void 0, (atom2) => {
    debugMountedAtoms.add(atom2);
    const atomState = atomStateMap.get(atom2);
    atomState.m = mountedAtoms.get(atom2);
  });
  storeHooks.u.add(void 0, (atom2) => {
    debugMountedAtoms.delete(atom2);
    const atomState = atomStateMap.get(atom2);
    delete atomState.m;
  });
  const devStore = {
    // store dev methods (these are tentative and subject to change without notice)
    dev4_get_internal_weak_map: () => {
      console.log("Deprecated: Use devstore from the devtools library");
      return atomStateMap;
    },
    dev4_get_mounted_atoms: () => debugMountedAtoms,
    dev4_restore_atoms: (values) => {
      const restoreAtom = {
        read: () => null,
        write: (_get, set) => {
          ++inRestoreAtom;
          try {
            for (const [atom2, value] of values) {
              if ("init" in atom2) {
                set(atom2, value);
              }
            }
          } finally {
            --inRestoreAtom;
          }
        }
      };
      store.set(restoreAtom);
    }
  };
  return Object.assign(store, devStore);
};
var overiddenCreateStore;
function createStore() {
  if (overiddenCreateStore) {
    return overiddenCreateStore();
  }
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    return createDevStoreRev4();
  }
  return INTERNAL_buildStoreRev1();
}
var defaultStore;
function getDefaultStore() {
  if (!defaultStore) {
    defaultStore = createStore();
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);
      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {
        console.warn(
          "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
        );
      }
    }
  }
  return defaultStore;
}

// node_modules/.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var StoreContext = (0, import_react.createContext)(
  void 0
);
function useStore(options) {
  const store = (0, import_react.useContext)(StoreContext);
  return (options == null ? void 0 : options.store) || store || getDefaultStore();
}
function Provider({
  children,
  store
}) {
  const storeRef = (0, import_react.useRef)(void 0);
  if (!store && !storeRef.current) {
    storeRef.current = createStore();
  }
  return (0, import_react.createElement)(
    StoreContext.Provider,
    {
      value: store || storeRef.current
    },
    children
  );
}
var isPromiseLike2 = (x) => typeof (x == null ? void 0 : x.then) === "function";
var attachPromiseStatus = (promise) => {
  if (!promise.status) {
    promise.status = "pending";
    promise.then(
      (v) => {
        promise.status = "fulfilled";
        promise.value = v;
      },
      (e) => {
        promise.status = "rejected";
        promise.reason = e;
      }
    );
  }
};
var use = import_react.default.use || // A shim for older React versions
((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    attachPromiseStatus(promise);
    throw promise;
  }
});
var continuablePromiseMap = /* @__PURE__ */ new WeakMap();
var createContinuablePromise = (promise, getValue) => {
  let continuablePromise = continuablePromiseMap.get(promise);
  if (!continuablePromise) {
    continuablePromise = new Promise((resolve, reject) => {
      let curr = promise;
      const onFulfilled = (me) => (v) => {
        if (curr === me) {
          resolve(v);
        }
      };
      const onRejected = (me) => (e) => {
        if (curr === me) {
          reject(e);
        }
      };
      const onAbort = () => {
        try {
          const nextValue = getValue();
          if (isPromiseLike2(nextValue)) {
            continuablePromiseMap.set(nextValue, continuablePromise);
            curr = nextValue;
            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));
            INTERNAL_registerAbortHandler(nextValue, onAbort);
          } else {
            resolve(nextValue);
          }
        } catch (e) {
          reject(e);
        }
      };
      promise.then(onFulfilled(promise), onRejected(promise));
      INTERNAL_registerAbortHandler(promise, onAbort);
    });
    continuablePromiseMap.set(promise, continuablePromise);
  }
  return continuablePromise;
};
function useAtomValue(atom2, options) {
  const { delay, unstable_promiseStatus: promiseStatus = !import_react.default.use } = options || {};
  const store = useStore(options);
  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, import_react.useReducer)(
    (prev) => {
      const nextValue = store.get(atom2);
      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {
        return prev;
      }
      return [nextValue, store, atom2];
    },
    void 0,
    () => [store.get(atom2), store, atom2]
  );
  let value = valueFromReducer;
  if (storeFromReducer !== store || atomFromReducer !== atom2) {
    rerender();
    value = store.get(atom2);
  }
  (0, import_react.useEffect)(() => {
    const unsub = store.sub(atom2, () => {
      if (promiseStatus) {
        try {
          const value2 = store.get(atom2);
          if (isPromiseLike2(value2)) {
            attachPromiseStatus(
              createContinuablePromise(value2, () => store.get(atom2))
            );
          }
        } catch (e) {
        }
      }
      if (typeof delay === "number") {
        setTimeout(rerender, delay);
        return;
      }
      rerender();
    });
    rerender();
    return unsub;
  }, [store, atom2, delay, promiseStatus]);
  (0, import_react.useDebugValue)(value);
  if (isPromiseLike2(value)) {
    const promise = createContinuablePromise(value, () => store.get(atom2));
    if (promiseStatus) {
      attachPromiseStatus(promise);
    }
    return use(promise);
  }
  return value;
}
function useSetAtom(atom2, options) {
  const store = useStore(options);
  const setAtom = (0, import_react.useCallback)(
    (...args) => {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("write" in atom2)) {
        throw new Error("not writable atom");
      }
      return store.set(atom2, ...args);
    },
    [store, atom2]
  );
  return setAtom;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/jotai/atom-family-with-error-catcher.js
var atomFamilyErrorsAtom = atom(() => /* @__PURE__ */ new Set());
function atomFamilyWithErrorCatcher(initializeAtom, getKey) {
  const baseAtomFamily = atomFamily((...args) => {
    const withErrorCatcher = (childAtom) => {
      const read = (get) => {
        try {
          const value = get(childAtom);
          if (!(value instanceof Promise)) {
            return value;
          }
          return value.catch((error) => {
            get(atomFamilyErrorsAtom).add({
              atomFamily: baseAtomFamily,
              args
            });
            throw error;
          });
        } catch (error) {
          get(atomFamilyErrorsAtom).add({
            atomFamily: baseAtomFamily,
            args
          });
          throw error;
        }
      };
      return "write" in childAtom ? atom(read, (_, set, ...args2) => set(childAtom, ...args2)) : atom(read);
    };
    return initializeAtom(withErrorCatcher, ...args);
  }, getKey);
  return baseAtomFamily;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/jotai/atom-with-observable.js
var empty = Symbol("empty");
function atomWithObservable(getObservable, options) {
  const observableAtom = atom((get) => {
    const observable = getObservable(get);
    const initialValue = (() => {
      if (options === void 0) {
        return empty;
      }
      if (!("initialValue" in options)) {
        return empty;
      }
      if (options.initialValue instanceof Function) {
        return options.initialValue(get);
      }
      return options.initialValue;
    })();
    const dataAtom = atom(initialValue !== empty ? {
      value: initialValue
    } : { value: firstValueFrom(observable) });
    dataAtom.onMount = (update) => {
      const subscription = observable.subscribe({
        next: (value) => update({ value }),
        error: (error) => update({ error })
      });
      return () => {
        subscription.unsubscribe();
      };
    };
    return dataAtom;
  });
  return atom((get) => {
    const data = get(get(observableAtom));
    if ("error" in data) {
      throw data.error;
    }
    return data.value;
  });
}

// node_modules/.pnpm/jotai-effect@2.0.2_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-effect/dist/env.js
function isDev() {
  return Boolean(typeof process !== "undefined" && "development" && true);
}

// node_modules/.pnpm/jotai-effect@2.0.2_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-effect/dist/atomEffect.js
var getBuildingBlocks2 = (store) => {
  const buildingBlocks = INTERNAL_getBuildingBlocksRev1(store);
  return [
    buildingBlocks[1],
    // mountedAtoms
    buildingBlocks[3],
    // changedAtoms
    INTERNAL_initializeStoreHooks(buildingBlocks[6]),
    // storeHooks
    buildingBlocks[11],
    // ensureAtomState
    buildingBlocks[14],
    // readAtomState
    buildingBlocks[16],
    // writeAtomState
    buildingBlocks[17],
    // mountDependencies
    buildingBlocks[15],
    // invalidateDependents
    buildingBlocks[13],
    // recomputeInvalidatedAtoms
    buildingBlocks[12]
    // flushCallbacks
  ];
};
function atomEffect(effect) {
  const refAtom = atom(() => []);
  const effectAtom = atom(function effectAtomRead(get) {
    const [dependencies, atomState, mountedAtoms] = get(refAtom);
    if (mountedAtoms.has(effectAtom)) {
      dependencies.forEach(get);
      ++atomState.n;
    }
  });
  effectAtom.effect = effect;
  effectAtom.unstable_onInit = (store) => {
    const deps = /* @__PURE__ */ new Set();
    let inProgress = 0;
    let isRecursing = false;
    let hasChanged = false;
    let fromCleanup = false;
    let runCleanup;
    function runEffect() {
      if (inProgress) {
        return;
      }
      deps.clear();
      let isSync = true;
      const getter = (a) => {
        var _a;
        if (fromCleanup) {
          return store.get(a);
        }
        if (INTERNAL_isSelfAtom(effectAtom, a)) {
          const aState2 = ensureAtomState(a);
          if (!INTERNAL_isAtomStateInitialized(aState2)) {
            if (INTERNAL_hasInitialValue(a)) {
              INTERNAL_setAtomStateValueOrPromise(a, a.init, ensureAtomState);
            } else {
              throw new Error("no atom init");
            }
          }
          return INTERNAL_returnAtomValue(aState2);
        }
        const aState = readAtomState(a);
        try {
          return INTERNAL_returnAtomValue(aState);
        } finally {
          atomState.d.set(a, aState.n);
          (_a = mountedAtoms.get(a)) == null ? void 0 : _a.t.add(effectAtom);
          if (isSync) {
            deps.add(a);
          } else {
            if (mountedAtoms.has(a)) {
              mountDependencies(effectAtom);
              recomputeInvalidatedAtoms();
              flushCallbacks();
            }
          }
        }
      };
      getter.peek = store.get;
      const setter = (a, ...args) => {
        var _a;
        const aState = ensureAtomState(a);
        try {
          ++inProgress;
          if (INTERNAL_isSelfAtom(effectAtom, a)) {
            if (!INTERNAL_hasInitialValue(a)) {
              throw new Error("atom not writable");
            }
            const prevEpochNumber = aState.n;
            const v = args[0];
            INTERNAL_setAtomStateValueOrPromise(a, v, ensureAtomState);
            mountDependencies(a);
            if (prevEpochNumber !== aState.n) {
              changedAtoms.add(a);
              (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);
              invalidateDependents(a);
            }
            return void 0;
          } else {
            return writeAtomState(a, ...args);
          }
        } finally {
          if (!isSync) {
            recomputeInvalidatedAtoms();
            flushCallbacks();
          }
          --inProgress;
        }
      };
      setter.recurse = (a, ...args) => {
        if (fromCleanup) {
          if (isDev()) {
            throw new Error("set.recurse is not allowed in cleanup");
          }
          return void 0;
        }
        try {
          isRecursing = true;
          mountDependencies(effectAtom);
          return setter(a, ...args);
        } finally {
          recomputeInvalidatedAtoms();
          isRecursing = false;
          if (hasChanged) {
            hasChanged = false;
            runEffect();
          }
        }
      };
      try {
        runCleanup == null ? void 0 : runCleanup();
        const cleanup = effectAtom.effect(getter, setter);
        if (typeof cleanup !== "function") {
          return;
        }
        runCleanup = () => {
          if (inProgress) {
            return;
          }
          try {
            isSync = true;
            fromCleanup = true;
            return cleanup();
          } finally {
            isSync = false;
            fromCleanup = false;
            runCleanup = void 0;
          }
        };
      } finally {
        isSync = false;
        deps.forEach((depAtom) => {
          atomState.d.set(depAtom, ensureAtomState(depAtom).n);
        });
        mountDependencies(effectAtom);
        recomputeInvalidatedAtoms();
      }
    }
    const [mountedAtoms, changedAtoms, storeHooks, ensureAtomState, readAtomState, writeAtomState, mountDependencies, invalidateDependents, recomputeInvalidatedAtoms, flushCallbacks] = getBuildingBlocks2(store);
    const atomEffectChannel = ensureAtomEffectChannel(store);
    const atomState = ensureAtomState(effectAtom);
    atomState.v = void 0;
    Object.assign(store.get(refAtom), [deps, atomState, mountedAtoms]);
    storeHooks.m.add(effectAtom, function atomOnMount() {
      atomEffectChannel.add(runEffect);
      if (runCleanup) {
        atomEffectChannel.delete(runCleanup);
      }
    });
    storeHooks.u.add(effectAtom, function atomOnUnmount() {
      atomEffectChannel.delete(runEffect);
      if (runCleanup) {
        atomEffectChannel.add(runCleanup);
      }
    });
    storeHooks.c.add(effectAtom, function atomOnUpdate() {
      if (isRecursing) {
        hasChanged = true;
      } else {
        atomEffectChannel.add(runEffect);
      }
    });
  };
  if (isDev()) {
    Object.defineProperty(refAtom, "debugLabel", {
      get: () => effectAtom.debugLabel ? `${effectAtom.debugLabel}:ref` : void 0
    });
    refAtom.debugPrivate = true;
  }
  return effectAtom;
}
var atomEffectChannelStoreMap = /* @__PURE__ */ new WeakMap();
function ensureAtomEffectChannel(store) {
  const storeHooks = getBuildingBlocks2(store)[2];
  let atomEffectChannel = atomEffectChannelStoreMap.get(store);
  if (!atomEffectChannel) {
    atomEffectChannel = /* @__PURE__ */ new Set();
    atomEffectChannelStoreMap.set(store, atomEffectChannel);
    storeHooks.f.add(function storeOnFlush() {
      for (const fn of atomEffectChannel) {
        atomEffectChannel.delete(fn);
        fn();
      }
    });
  }
  return atomEffectChannel;
}

// node_modules/.pnpm/jotai-effect@2.0.2_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-effect/dist/withAtomEffect.js
function withAtomEffect(targetAtom, effect) {
  const effectAtom = atomEffect((get, set) => {
    const getter = (a) => a === targetWithEffect ? get(targetAtom) : get(a);
    getter.peek = get.peek;
    return targetWithEffect.effect(getter, set);
  });
  if (isDev()) {
    Object.defineProperty(effectAtom, "debugLabel", {
      get: () => `${targetWithEffect.debugLabel ?? "atomWithEffect"}:effect`
    });
    effectAtom.debugPrivate = true;
  }
  const descriptors = Object.getOwnPropertyDescriptors(targetAtom);
  descriptors.read.value = (get) => {
    try {
      return get(targetAtom);
    } finally {
      get(effectAtom);
    }
  };
  if ("write" in targetAtom && typeof targetAtom.write === "function") {
    descriptors.write.value = targetAtom.write.bind(targetAtom);
    delete descriptors.onMount;
  }
  const targetPrototype = Object.getPrototypeOf(targetAtom);
  const targetWithEffect = Object.create(targetPrototype, descriptors);
  targetWithEffect.effect = effect;
  return targetWithEffect;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/jotai/atom-with-observable-and-promise.js
var empty2 = Symbol("empty");
function atomWithObservableAndPromise(getObservable, enhanceAtom = (atomCreator) => atomCreator) {
  const sourceObservable = atom((get) => getObservable(get).pipe(shareReplay({ bufferSize: 1, refCount: true })));
  const dataAtom = atom({ value: empty2 });
  const initialDataAtom = atom({
    value: empty2
  });
  const observableAtom = withAtomEffect(enhanceAtom(atomWithObservable((get) => get(sourceObservable), {
    initialValue: (get) => {
      const value = get(initialDataAtom).value;
      return value === empty2 ? empty : value;
    }
  })), (get, set) => {
    try {
      set(dataAtom, { value: get(observableAtom) });
    } catch (error) {
      set(dataAtom, { error });
    }
  });
  const promiseAtom = enhanceAtom(atom((get) => {
    const data = get(dataAtom);
    if ("error" in data) {
      throw data.error;
    }
    if (data.value !== empty2) {
      return data.value;
    }
    const initialData = get(initialDataAtom);
    return firstValueFrom(get(sourceObservable)).then((value) => {
      initialData.value = value;
      return value;
    });
  }));
  return { promiseAtom, observableAtom };
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/jotai/atom-with-promise.js
var import_react2 = __toESM(require_react(), 1);
function atomWithPromise(getPromise) {
  const countAtom = atom(0);
  const promiseAtom = atom((get, { signal }) => {
    get(countAtom);
    const maybePromise = getPromise(get, { signal });
    const dataAtom = atom({
      value: maybePromise
    });
    dataAtom.onMount = (update) => {
      if (maybePromise instanceof Promise) {
        void maybePromise.then((value) => (0, import_react2.startTransition)(() => update({ value }))).catch((error) => (0, import_react2.startTransition)(() => update({ error })));
      }
    };
    return dataAtom;
  });
  return atom((get) => {
    const data = get(get(promiseAtom));
    if ("error" in data) {
      throw data.error;
    }
    return data.value;
  }, (_, set) => {
    set(countAtom, (count) => count + 1);
  });
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/maybe-promise-all.js
function maybePromiseAll(maybePromises) {
  return maybePromises.some((maybePromise) => maybePromise instanceof Promise) ? Promise.all(maybePromises) : maybePromises;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/contexts/config.js
var import_react3 = __toESM(require_react(), 1);
var ConfigContext = (0, import_react3.createContext)(void 0);

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-config.js
var import_react4 = __toESM(require_react(), 1);
function useConfig() {
  const config = (0, import_react4.use)(ConfigContext);
  if (config === void 0) {
    throw new BaseError("No config provided");
  }
  return config;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/contexts/query-options.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var SubscriptionContext = (0, import_react5.createContext)({ active: true });
function QueryOptionsProvider({ active, children }) {
  return (0, import_jsx_runtime.jsx)(SubscriptionContext, { value: (0, import_react5.useMemo)(() => ({ active }), [active]), children });
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-atom-value.js
var useAtomValue2 = (atom2, options) => useAtomValue(atom2, { unstable_promiseStatus: true, ...options });

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-pausable-atom-value.js
var import_react6 = __toESM(require_react(), 1);
function usePausableAtomValue(pausableAtom, options) {
  return useAtomValue2((0, import_react6.use)(SubscriptionContext).active ? pausableAtom.observableAtom : pausableAtom.promiseAtom, options);
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/contexts/chain.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var ChainIdContext = (0, import_react7.createContext)(void 0);
function ChainProvider(props) {
  return (0, import_jsx_runtime2.jsx)(ChainIdContext, { value: props.chainId, children: props.children });
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-query-options.js
var import_react8 = __toESM(require_react(), 1);
function useQueryOptions(queryOrOptions, mayBeOptions) {
  const contextChainId = (0, import_react8.use)(ChainIdContext);
  return (0, import_react8.useMemo)(() => (Array.isArray(queryOrOptions) ? queryOrOptions : [{ query: queryOrOptions, ...mayBeOptions }]).map((options) => {
    const chainId = options.chainId ?? contextChainId;
    if (chainId === void 0) {
      throw new BaseError("No chain ID provided");
    }
    return {
      chainId,
      query: options.query instanceof Query ? options.query : typeof options.query === "function" ? options.query(new Query()) || void 0 : void 0
    };
  }), [contextChainId, mayBeOptions, queryOrOptions]);
}

// node_modules/.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/vanilla/utils.mjs
var RESET = Symbol(
  (import.meta.env ? import.meta.env.MODE : void 0) !== "production" ? "RESET" : ""
);
var isPromiseLike$3 = (x) => typeof (x == null ? void 0 : x.then) === "function";
function createJSONStorage(getStringStorage = () => {
  try {
    return window.localStorage;
  } catch (e) {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      if (typeof window !== "undefined") {
        console.warn(e);
      }
    }
    return void 0;
  }
}, options) {
  var _a;
  let lastStr;
  let lastValue;
  const storage = {
    getItem: (key, initialValue) => {
      var _a2, _b;
      const parse = (str2) => {
        str2 = str2 || "";
        if (lastStr !== str2) {
          try {
            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);
          } catch (e) {
            return initialValue;
          }
          lastStr = str2;
        }
        return lastValue;
      };
      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;
      if (isPromiseLike$3(str)) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (key, newValue) => {
      var _a2;
      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(
        key,
        JSON.stringify(newValue, options == null ? void 0 : options.replacer)
      );
    },
    removeItem: (key) => {
      var _a2;
      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);
    }
  };
  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {
    let newValue;
    try {
      newValue = JSON.parse(v || "");
    } catch (e) {
      newValue = initialValue;
    }
    callback(newValue);
  });
  let subscriber;
  try {
    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;
  } catch (e) {
  }
  if (!subscriber && typeof window !== "undefined" && typeof window.addEventListener === "function" && window.Storage) {
    subscriber = (key, callback) => {
      if (!(getStringStorage() instanceof window.Storage)) {
        return () => {
        };
      }
      const storageEventCallback = (e) => {
        if (e.storageArea === getStringStorage() && e.key === key) {
          callback(e.newValue);
        }
      };
      window.addEventListener("storage", storageEventCallback);
      return () => {
        window.removeEventListener("storage", storageEventCallback);
      };
    };
  }
  if (subscriber) {
    storage.subscribe = createHandleSubscribe(subscriber);
  }
  return storage;
}
var defaultStorage = createJSONStorage();

// node_modules/.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/react/utils.mjs
var import_react9 = __toESM(require_react(), 1);
function useAtomCallback(callback, options) {
  const anAtom = (0, import_react9.useMemo)(
    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),
    [callback]
  );
  return useSetAtom(anAtom, options);
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-query-refresher.js
var import_react11 = __toESM(require_react(), 1);
function useQueryRefresher(queryOrOptions, mayBeOptions) {
  const options = useQueryOptions(
    // @ts-expect-error complex overload
    queryOrOptions,
    mayBeOptions
  );
  const config = useConfig();
  const refresh = useAtomCallback((0, import_react11.useCallback)((_, set) => {
    for (const { chainId, query: query2 } of options) {
      if (query2 === void 0) {
        return;
      }
      const atoms = getQueryInstructionPayloadAtoms(config, chainId, query2).flat();
      for (const atom2 of atoms) {
        if ("write" in atom2.promiseAtom) {
          set(atom2.promiseAtom);
        }
      }
    }
  }, [config, options]));
  return refresh;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-render-effect.js
var import_react12 = __toESM(require_react(), 1);
function useRenderEffect(effect, key) {
  const prevKey = (0, import_react12.useRef)(key);
  const currKey = (0, import_react12.useRef)(prevKey.current);
  currKey.current = key;
  if (prevKey.current !== currKey.current) {
    prevKey.current = currKey.current;
    effect();
  }
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-chain-id.js
var import_react13 = __toESM(require_react(), 1);
function useChainIds() {
  return Object.keys(useConfig().chains);
}
function useChainId() {
  const chainId = (0, import_react13.use)(ChainIdContext);
  if (chainId === void 0) {
    throw new BaseError("No chain ID provided");
  }
  return chainId;
}
function internal_useChainId({ optionalChainId = false, ...options } = {}) {
  const contextChainId = (0, import_react13.use)(ChainIdContext);
  const chainId = (options == null ? void 0 : options.chainId) ?? contextChainId;
  if (!optionalChainId && chainId === void 0) {
    throw new BaseError("No chain ID provided");
  }
  return chainId;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-client.js
function useClient(options) {
  return useAtomValue2(clientAtom(useConfig(), internal_useChainId(options)));
}
var clientAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, chainId) => withErrorCatcher(atom(() => {
  const chainConfig = config.chains[chainId];
  if (chainConfig === void 0) {
    throw new BaseError(`No config provided for ${chainId}`);
  }
  return getClient(chainConfig);
})));

// node_modules/.pnpm/jotai-derive@0.1.3_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-derive/dist/isPromise.js
function isPromise(value) {
  return value && typeof value === "object" && "then" in value;
}

// node_modules/.pnpm/jotai-derive@0.1.3_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-derive/dist/soon.js
function soon(first, second) {
  if (second) {
    return _soonImpl(first, second);
  }
  return (data) => {
    return _soonImpl(data, first);
  };
}
function _soonImpl(data, process2) {
  if (isPromise(data)) {
    if (data.status === "fulfilled") {
      return process2(data.value);
    }
    if (data.status === "rejected") {
      return Promise.reject(data.reason);
    }
    return data.then((value) => process2(value));
  }
  try {
    return process2(data);
  } catch (err) {
    return Promise.reject(err);
  }
}

// node_modules/.pnpm/jotai-derive@0.1.3_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-derive/dist/soonAll.js
function isKnown(value) {
  if (isPromise(value)) {
    return value.status === "fulfilled";
  }
  return true;
}
function soonAll(values) {
  if (values.every(isKnown)) {
    return values.map((el) => isPromise(el) ? el.value : el);
  }
  return Promise.all(values);
}

// node_modules/.pnpm/jotai-derive@0.1.3_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-derive/dist/derive.js
function derive(deps, op) {
  return atom((get) => {
    try {
      return soon(soonAll(deps.map(get)), (values) => op(...values));
    } catch (err) {
      return Promise.reject(err);
    }
  });
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-typed-api.js
function useTypedApi(options) {
  return useAtomValue2(typedApiAtom(useConfig(), internal_useChainId(options)));
}
var typedApiAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, chainId) => withErrorCatcher(atom((get) => {
  const chainConfig = config.chains[chainId];
  if (chainConfig === void 0) {
    throw new BaseError(`No config provided for chain ${chainId}`);
  }
  return soon(get(clientAtom(config, chainId)), (client) => client.getTypedApi(chainConfig.descriptor));
})));

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/utils/flat-head.js
function flatHead(value) {
  if (Array.isArray(value) && value.length === 1) {
    return value.at(0);
  }
  return value;
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/utils/stringify.js
function stringify(queryInstruction) {
  return JSON.stringify(queryInstruction, (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    if (value instanceof Binary) {
      return value.asHex();
    }
    if (isPlainObject(value)) {
      return Object.keys(value).sort().reduce(
        (result, key) => {
          result[key] = value[key];
          return result;
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        {}
      );
    }
    return value;
  });
}
function isPlainObject(value) {
  if (!hasObjectPrototype(value)) {
    return false;
  }
  const ctor = value.constructor;
  if (typeof ctor === "undefined")
    return true;
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot))
    return false;
  if (!prot.hasOwnProperty("isPrototypeOf"))
    return false;
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-query.js
var import_react14 = __toESM(require_react(), 1);
function useLazyLoadQuery(queryOrOptions, mayBeOptions) {
  const options = useQueryOptions(
    // @ts-expect-error complex overload
    queryOrOptions,
    mayBeOptions
  );
  const refresh = useQueryRefresher(queryOrOptions, mayBeOptions);
  const fetchKey = mayBeOptions !== void 0 && "fetchKey" in mayBeOptions ? mayBeOptions.fetchKey : void 0;
  useRenderEffect(() => {
    refresh();
  }, fetchKey);
  const partialData = usePausableAtomValue(queryPayloadAtom(useConfig(), (0, import_react14.useMemo)(() => options.filter((options2) => options2.query !== void 0), [options])));
  return (0, import_react14.useMemo)(() => {
    const unflattenedData = interlace(partialData, findAllIndexes(options, (options2) => options2.query === void 0).map((index) => [idle, index]));
    return !Array.isArray(queryOrOptions) ? flatHead(unflattenedData) : unflattenedData;
  }, [options, partialData, queryOrOptions]);
}
function useLazyLoadQueryWithRefresh(...args) {
  const data = useLazyLoadQuery(...args);
  const refresh = useQueryRefresher(...args);
  return [data, refresh];
}
var instructionPayloadAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, chainId, instruction) => {
  switch (preflight(instruction)) {
    case "promise": {
      const atom2 = withErrorCatcher(atomWithPromise((get, { signal }) => soon(get(typedApiAtom(config, chainId)), (api) => query(api, instruction, { signal }))));
      return {
        observableAtom: atom2,
        promiseAtom: atom2
      };
    }
    case "observable":
      return atomWithObservableAndPromise((get) => from(Promise.resolve(get(typedApiAtom(config, chainId)))).pipe(switchMap((api) => query(api, instruction))), withErrorCatcher);
  }
}, (config, chainId, instruction) => [objectId(config), chainId, stringify(instruction)].join());
function getQueryInstructionPayloadAtoms(config, chainId, query2) {
  return query2.instructions.map((instruction) => {
    if (!("multi" in instruction)) {
      return instructionPayloadAtom(config, chainId, instruction);
    }
    return instruction.args.map((args) => {
      const { multi, ...rest } = instruction;
      return instructionPayloadAtom(config, chainId, { ...rest, args });
    });
  });
}
var queryPayloadAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, params) => {
  const atoms = params.map((param) => getQueryInstructionPayloadAtoms(config, param.chainId, param.query));
  const unwrap = (atoms2, asObservable) => asObservable ? atoms2.observableAtom : atoms2.promiseAtom;
  const createAtom = (asObservable) => withErrorCatcher(atom((get) => {
    return maybePromiseAll(atoms.map((atomOrAtoms) => !Array.isArray(atomOrAtoms) ? atomOrAtoms : soon(maybePromiseAll(atomOrAtoms.map((atomOrAtoms2) => {
      if (Array.isArray(atomOrAtoms2)) {
        return maybePromiseAll(atomOrAtoms2.map((atom2) => get(unwrap(atom2, asObservable))));
      }
      return get(unwrap(atomOrAtoms2, asObservable));
    })), flatHead)));
  }));
  return { promiseAtom: createAtom(false), observableAtom: createAtom(true) };
}, (config, params) => [
  objectId(config),
  ...params.map((param) => [
    param.chainId,
    stringify(param.query.instructions)
  ])
].join());

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/components/query-renderer.js
function QueryRenderer({ query: query2, chainId, children }) {
  return children(useLazyLoadQuery(query2, { chainId }));
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/contexts/provider.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-local-store.js
var import_react15 = __toESM(require_react(), 1);
function useLocalStore() {
  const contextStore = useStore();
  return (0, import_react15.useMemo)(() => contextStore === getDefaultStore() ? createStore() : contextStore, [contextStore]);
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/utils/is-ssr.js
function isSsr() {
  return typeof window === "undefined";
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-wallets.js
function useWallets() {
  return useAtomValue2(walletsAtom(useConfig()));
}
function useConnectedWallets() {
  return usePausableAtomValue(connectedWalletsAtom(useConfig()));
}
var walletsAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config) => isSsr() ? atom(Promise.resolve([])) : withErrorCatcher(atom(() => aggregateWallets(config.wallets ?? []))));
var connectedWalletsAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config) => atomWithObservableAndPromise((get) => getConnectedWallets(get(walletsAtom(config))), withErrorCatcher));

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-wallets-initializer.js
var import_react16 = __toESM(require_react(), 1);
function useWalletsInitializer() {
  const wallets = useWallets();
  const [state, setState] = (0, import_react16.useState)(idle);
  const initialize = (0, import_react16.useCallback)(async () => {
    setState(pending);
    await initializeWallets(wallets);
  }, [wallets]);
  return [state, initialize];
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/contexts/mutation.js
var import_react17 = __toESM(require_react(), 1);
var MutationEventSubjectContext = (0, import_react17.createContext)(new Subject());

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/contexts/provider.js
var import_react18 = __toESM(require_react(), 1);
function ReactiveDotProvider({ config, children }) {
  return (0, import_jsx_runtime3.jsx)(Provider, { store: useLocalStore(), children: (0, import_jsx_runtime3.jsx)(ConfigContext, { value: config, children: (0, import_jsx_runtime3.jsxs)(MutationEventSubjectContext, { value: (0, import_react18.useMemo)(() => new Subject(), []), children: [(0, import_jsx_runtime3.jsx)(import_react18.Suspense, { children: (0, import_jsx_runtime3.jsx)(WalletsInitializer, {}) }), children] }) }) });
}
function WalletsInitializer() {
  const [_, initialize] = useWalletsInitializer();
  (0, import_react18.useEffect)(() => {
    initialize();
  }, [initialize]);
  return null;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/contexts/signer.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var SignerContext = (0, import_react19.createContext)(void 0);
function SignerProvider(props) {
  return (0, import_jsx_runtime4.jsx)(SignerContext, { value: props.signer, children: props.children });
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-chain-spec-data.js
function useChainSpecData(options) {
  return useAtomValue2(chainSpecDataAtom(useConfig(), internal_useChainId(options)));
}
var chainSpecDataAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, chainId) => withErrorCatcher(derive([clientAtom(config, chainId)], (client) => client.getChainSpecData())));

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-accounts.js
function useAccounts(options) {
  return usePausableAtomValue(accountsAtom(useConfig(), internal_useChainId({ ...options, optionalChainId: true })));
}
var accountsAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, chainId) => atomWithObservableAndPromise((get) => getAccounts(get(connectedWalletsAtom(config).observableAtom), chainId === void 0 ? void 0 : get(chainSpecDataAtom(config, chainId))), withErrorCatcher));

// node_modules/.pnpm/@reactive-dot+utils@0.10.0/node_modules/@reactive-dot/utils/build/big-int.js
var BigIntMath = Object.freeze({
  min(...values) {
    if (values.length === 0) {
      return 0n;
    }
    return values.reduce((previousValue, currentValue) => currentValue < previousValue ? currentValue : previousValue);
  },
  max(...values) {
    if (values.length === 0) {
      return 0n;
    }
    return values.reduce((previousValue, currentValue) => currentValue > previousValue ? currentValue : previousValue);
  },
  get [Symbol.toStringTag]() {
    return "BigIntMath";
  }
});

// node_modules/.pnpm/@reactive-dot+utils@0.10.0/node_modules/@reactive-dot/utils/build/denominated-number.js
var _maxDecimal, _DenominatedNumber_static, verifyDecimals_fn;
var _DenominatedNumber = class _DenominatedNumber extends Number {
  constructor(planck, decimals, denomination) {
    super();
    __publicField(this, "decimals");
    __publicField(this, "denomination");
    __publicField(this, "planck");
    /**
     * @deprecated Use {@link DenominatedNumber.mapPlanck} instead.
     */
    __publicField(this, "mapFromPlanck", this.mapPlanck);
    /**
     * @deprecated Use {@link DenominatedNumber.mapNumber} instead.
     */
    __publicField(this, "mapFromNumber", this.mapNumber);
    this.decimals = decimals;
    this.denomination = denomination;
    this.planck = BigInt(planck);
  }
  static fromNumber(number, decimals, denomination) {
    var _a;
    __privateMethod(_a = _DenominatedNumber, _DenominatedNumber_static, verifyDecimals_fn).call(_a, decimals);
    const numberString = number.toString();
    const badCharacter = numberString.match(/[^0-9.]/);
    if (badCharacter) {
      throw new Error(`Invalid character at position ${(badCharacter.index ?? 0) + 1}`);
    }
    let whole;
    let fractional;
    if (numberString.search(/\./) === -1) {
      whole = numberString;
      fractional = "";
    } else {
      const parts = numberString.split(".");
      switch (parts.length) {
        case 0:
        case 1:
          throw new Error("Fewer than two elements in split result. This must not happen here.");
        case 2:
          if (!parts[1])
            throw new Error("Fractional part missing");
          whole = parts[0];
          fractional = parts[1].replace(/0+$/, "");
          break;
        default:
          throw new Error("More than one separator found");
      }
    }
    if (fractional.length > decimals) {
      fractional = fractional.slice(0, decimals);
    }
    const quantity = `${whole}${fractional.padEnd(decimals, "0")}`;
    return new _DenominatedNumber(BigInt(quantity), decimals, denomination);
  }
  valueOf() {
    return Number(this.toString());
  }
  toString() {
    const paddedPlanck = this.planck.toString().padStart(this.decimals, "0");
    const whole = paddedPlanck.slice(0, paddedPlanck.length - this.decimals).padStart(1, "0");
    const fractional = paddedPlanck.slice(paddedPlanck.length - this.decimals).replace(/0+$/, "");
    if (fractional.length === 0) {
      return whole;
    } else {
      return `${whole || "0"}.${fractional}`;
    }
  }
  toLocaleString(locales, options) {
    if (this.denomination === void 0) {
      return this.valueOf().toLocaleString(locales, options);
    }
    const newOptions = options ?? {};
    if ((options == null ? void 0 : options.style) === void 0) {
      newOptions.style = "currency";
      newOptions.currency = "XTS";
    }
    return this.valueOf().toLocaleString(locales, newOptions).replace("XTS", this.denomination);
  }
  mapPlanck(mapper) {
    return new _DenominatedNumber(mapper(this.planck), this.decimals, this.denomination);
  }
  mapNumber(mapper) {
    return _DenominatedNumber.fromNumber(mapper(this.valueOf()), this.decimals, this.denomination);
  }
};
_maxDecimal = new WeakMap();
_DenominatedNumber_static = new WeakSet();
verifyDecimals_fn = function(fractionalDigits) {
  if (!Number.isInteger(fractionalDigits))
    throw new Error("Decimals is not an integer");
  if (fractionalDigits < 0)
    throw new Error("Decimals must not be negative");
  if (fractionalDigits > __privateGet(_DenominatedNumber, _maxDecimal)) {
    throw new Error(`Decimals must not exceed ${__privateGet(_DenominatedNumber, _maxDecimal)}`);
  }
};
__privateAdd(_DenominatedNumber, _DenominatedNumber_static);
// Large values lead to massive memory usage. Limit to something sensible.
__privateAdd(_DenominatedNumber, _maxDecimal, 100);
var DenominatedNumber = _DenominatedNumber;

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-native-token-amount.js
var import_react20 = __toESM(require_react(), 1);
function useNativeTokenAmountFromPlanck(planckOrOptions, maybeOptions) {
  const options = typeof planckOrOptions === "object" ? planckOrOptions : maybeOptions;
  const chainSpecData = useChainSpecData(options);
  const nativeTokenInfo = (0, import_react20.useMemo)(() => nativeTokenInfoFromChainSpecData(chainSpecData), [chainSpecData]);
  return (0, import_react20.useMemo)(
    () => {
      switch (typeof planckOrOptions) {
        case "bigint":
        case "number":
        case "string":
          return new DenominatedNumber(planckOrOptions, nativeTokenInfo.decimals ?? 0, nativeTokenInfo.code);
        default:
          return (planck) => new DenominatedNumber(planck, nativeTokenInfo.decimals ?? 0, nativeTokenInfo.code);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [nativeTokenInfo.code, nativeTokenInfo.decimals, typeof planckOrOptions]
  );
}
function useNativeTokenAmountFromNumber(numberOrOptions, maybeOptions) {
  const options = typeof numberOrOptions === "object" ? numberOrOptions : maybeOptions;
  const chainSpecData = useChainSpecData(options);
  const nativeTokenInfo = (0, import_react20.useMemo)(() => nativeTokenInfoFromChainSpecData(chainSpecData), [chainSpecData]);
  return (0, import_react20.useMemo)(
    () => {
      switch (typeof numberOrOptions) {
        case "number":
        case "string":
          return DenominatedNumber.fromNumber(numberOrOptions, nativeTokenInfo.decimals ?? 0, nativeTokenInfo.code);
        default:
          return (number) => DenominatedNumber.fromNumber(number, nativeTokenInfo.decimals ?? 0, nativeTokenInfo.code);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [nativeTokenInfo.code, nativeTokenInfo.decimals, typeof numberOrOptions]
  );
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/maths/spendable-balance.js
function spendableBalance({ free, reserved, frozen, existentialDeposit, includesExistentialDeposit = false }) {
  return BigIntMath.max(0n, free - BigIntMath.max(frozen - reserved, includesExistentialDeposit ? 0n : existentialDeposit));
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-balance.js
var import_react21 = __toESM(require_react(), 1);
function useSpendableBalance(addressOrAddresses, { includesExistentialDeposit = false, ...options } = {}) {
  const addresses = Array.isArray(addressOrAddresses) ? addressOrAddresses : [addressOrAddresses];
  const [existentialDeposit, accounts] = useLazyLoadQuery((builder) => builder.constant("Balances", "ExistentialDeposit").storages("System", "Account", addresses.map((address) => [address])), options);
  const nativeTokenFromPlanck = useNativeTokenAmountFromPlanck(options);
  const balances = (0, import_react21.useMemo)(() => accounts.map(({ data: { free, reserved, frozen } }) => nativeTokenFromPlanck(spendableBalance({
    free,
    reserved,
    frozen,
    existentialDeposit,
    includesExistentialDeposit
  }))), [
    accounts,
    existentialDeposit,
    includesExistentialDeposit,
    nativeTokenFromPlanck
  ]);
  return Array.isArray(addressOrAddresses) ? balances : balances[0];
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-block.js
function useBlock(tag = "finalized", options) {
  const config = useConfig();
  const chainId = internal_useChainId(options);
  return usePausableAtomValue(tag === "finalized" ? finalizedBlockAtom(config, chainId) : bestBlockAtom(config, chainId));
}
var finalizedBlockAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, chainId) => atomWithObservableAndPromise((get) => from(get(clientAtom(config, chainId))).pipe(switchMap((client) => getBlock(client, { tag: "finalized" }))), withErrorCatcher));
var bestBlockAtom = atomFamilyWithErrorCatcher((withErrorCatcher, config, chainId) => atomWithObservableAndPromise((get) => from(get(clientAtom(config, chainId))).pipe(switchMap((client) => getBlock(client, { tag: "best" }))), withErrorCatcher));

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-mutation-effect.js
var import_react22 = __toESM(require_react(), 1);
function useMutationEffect(effect) {
  const mutationEventSubject = (0, import_react22.use)(MutationEventSubjectContext);
  (0, import_react22.useEffect)(() => {
    const subscription = mutationEventSubject.subscribe({ next: effect });
    return () => subscription.unsubscribe();
  }, [mutationEventSubject, effect]);
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-async-action.js
var import_react23 = __toESM(require_react(), 1);
function useAsyncAction(action) {
  const [state, setState] = (0, import_react23.useState)(idle);
  const execute = (0, import_react23.useCallback)((...args) => {
    const resolve = (value) => setState(value);
    const reject = (reason) => setState(MutationError.from(reason));
    try {
      setState(pending);
      const result = action(...args);
      if (result instanceof Promise) {
        return result.then(resolve).catch(reject);
      } else {
        return result.subscribe({ next: resolve, error: reject });
      }
    } catch (error) {
      const mutationError = MutationError.from(error);
      setState(mutationError);
      throw mutationError;
    }
  }, [action, setState]);
  return [state, execute];
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-mutation.js
var import_react24 = __toESM(require_react(), 1);
function useMutation(action, options) {
  const config = useConfig();
  const chainId = internal_useChainId(options);
  const mutationEventSubject = (0, import_react24.use)(MutationEventSubjectContext);
  const contextSigner = (0, import_react24.use)(SignerContext);
  return useAsyncAction(useAtomCallback((0, import_react24.useCallback)((get, _set, submitOptions) => {
    const signer = (submitOptions == null ? void 0 : submitOptions.signer) ?? (options == null ? void 0 : options.signer) ?? contextSigner;
    if (signer === void 0) {
      throw new MutationError("No signer provided");
    }
    const id = globalThis.crypto.randomUUID();
    return from(Promise.resolve(get(typedApiAtom(config, chainId)))).pipe(switchMap((typedApi) => {
      const transaction = action(typedApi.tx);
      const eventProps = { id, chainId, call: transaction.decodedCall };
      mutationEventSubject.next({ ...eventProps, value: pending });
      return transaction.signSubmitAndWatch(signer, (submitOptions == null ? void 0 : submitOptions.txOptions) ?? (options == null ? void 0 : options.txOptions)).pipe(tap((value) => mutationEventSubject.next({ ...eventProps, value })), catchError((error) => {
        mutationEventSubject.next({
          ...eventProps,
          value: MutationError.from(error)
        });
        throw error;
      }));
    }));
  }, [
    action,
    chainId,
    config,
    contextSigner,
    mutationEventSubject,
    options == null ? void 0 : options.signer,
    options == null ? void 0 : options.txOptions
  ])));
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-query-error-resetter.js
var import_react25 = __toESM(require_react(), 1);
function useQueryErrorResetter() {
  return useAtomCallback((0, import_react25.useCallback)((get) => {
    const atomFamilyErrors = get(atomFamilyErrorsAtom);
    for (const error of atomFamilyErrors) {
      error.atomFamily.delete(error.args);
      atomFamilyErrors.delete(error);
    }
  }, []));
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-query-loader.js
var import_react26 = __toESM(require_react(), 1);
function useQueryLoader() {
  const config = useConfig();
  const chainId = internal_useChainId();
  const _loadQuery = (0, import_react26.useCallback)((get) => (builder, options) => {
    const query2 = builder(new Query());
    void get(queryPayloadAtom(config, [
      {
        query: query2,
        chainId: (options == null ? void 0 : options.chainId) ?? chainId
      }
    ]).observableAtom);
  }, [chainId, config]);
  const loadQuery = useAtomCallback((0, import_react26.useCallback)((get, _, builder) => _loadQuery(get)(builder), [_loadQuery]));
  return loadQuery;
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-signer.js
var import_react27 = __toESM(require_react(), 1);
function useSigner() {
  return (0, import_react27.use)(SignerContext);
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-wallet-connector.js
var import_react28 = __toESM(require_react(), 1);
function useWalletConnector(wallets) {
  const hookWallets = wallets;
  const config = useConfig();
  return useAsyncAction(useAtomCallback((0, import_react28.useCallback)(async (get, _, wallets2) => {
    const walletsToConnect = wallets2 ?? hookWallets ?? await get(walletsAtom(config));
    await connectWallet(walletsToConnect);
    return true;
  }, [config, hookWallets])));
}

// node_modules/.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/build/hooks/use-wallet-disconnector.js
var import_react29 = __toESM(require_react(), 1);
function useWalletDisconnector(wallets) {
  const hookWallets = wallets;
  const config = useConfig();
  return useAsyncAction(useAtomCallback((0, import_react29.useCallback)(async (get, _, wallets2) => {
    const walletsToDisconnect = wallets2 ?? hookWallets ?? await get(walletsAtom(config));
    await disconnectWallet(walletsToDisconnect);
    return true;
  }, [config, hookWallets])));
}
export {
  ChainProvider,
  QueryOptionsProvider,
  QueryRenderer,
  ReactiveDotProvider,
  SignerProvider,
  useAccounts,
  useBlock,
  useChainId,
  useChainIds,
  useChainSpecData,
  useClient,
  useConfig,
  useConnectedWallets,
  useLazyLoadQuery,
  useLazyLoadQueryWithRefresh,
  useMutation,
  useMutationEffect,
  useNativeTokenAmountFromNumber,
  useNativeTokenAmountFromPlanck,
  useQueryErrorResetter,
  useQueryLoader,
  useQueryRefresher,
  useSigner,
  useSpendableBalance,
  useTypedApi,
  useWalletConnector,
  useWalletDisconnector,
  useWallets
};
//# sourceMappingURL=@reactive-dot_react.js.map
