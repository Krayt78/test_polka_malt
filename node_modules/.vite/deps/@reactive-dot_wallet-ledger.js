import "./chunk-CGJMGULG.js";
import "./chunk-CH5HA4ZP.js";
import "./chunk-AKNCNGJG.js";
import "./chunk-6ZBYRXGS.js";
import {
  Binary
} from "./chunk-EVM4Y7G3.js";
import {
  BehaviorSubject,
  firstValueFrom,
  map,
  skip
} from "./chunk-2T3XQHSK.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-B4Q33VKO.js";

// node_modules/.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/errors.js
var BaseError = class extends Error {
  static from(error, message) {
    return new this(message ?? (error instanceof Error ? error.message : void 0), { cause: error });
  }
};

// node_modules/.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/storage.js
var _storage, _Storage_instances, prefixKey_fn;
var _Storage = class _Storage {
  constructor(options) {
    __privateAdd(this, _Storage_instances);
    __publicField(this, "prefix");
    __privateAdd(this, _storage);
    this.prefix = options.prefix;
    __privateSet(this, _storage, options.storage);
  }
  getItem(key) {
    return __privateGet(this, _storage).getItem(__privateMethod(this, _Storage_instances, prefixKey_fn).call(this, key));
  }
  removeItem(key) {
    return __privateGet(this, _storage).removeItem(__privateMethod(this, _Storage_instances, prefixKey_fn).call(this, key));
  }
  setItem(key, value) {
    return __privateGet(this, _storage).setItem(__privateMethod(this, _Storage_instances, prefixKey_fn).call(this, key), value);
  }
  join(path) {
    return new _Storage({
      prefix: `${this.prefix}/${path}`,
      storage: __privateGet(this, _storage)
    });
  }
};
_storage = new WeakMap();
_Storage_instances = new WeakSet();
prefixKey_fn = function(key) {
  return `${this.prefix}/${key}`;
};
var Storage = _Storage;
var defaultStorage = new Storage({
  prefix: "@reactive-dot",
  storage: globalThis.localStorage
});

// node_modules/.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/symbols.js
var idle = Symbol("idle");
var pending = Symbol("pending");

// node_modules/.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/wallets/wallet.js
var _storage2;
var Wallet = class {
  constructor(options) {
    __publicField(this, "options");
    __privateAdd(this, _storage2);
    this.options = options;
    __privateSet(this, _storage2, ((options == null ? void 0 : options.storage) ?? defaultStorage).join("wallet"));
  }
  get storage() {
    return __privateGet(this, _storage2).join(this.id);
  }
  getAccounts() {
    return firstValueFrom(this.accounts$, { defaultValue: [] });
  }
};
_storage2 = new WeakMap();

// node_modules/.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/wallets/local-wallet.js
var LocalWallet = class extends Wallet {
};

// node_modules/.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/utils/lazy.js
var empty = Symbol("empty");

// node_modules/.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/providers/light-client/provider.js
var getProviderSymbol = Symbol("getProvider");

// node_modules/.pnpm/@reactive-dot+wallet-ledger@0.16.37_@ledgerhq+hw-transport@6.31.5_polkadot-api@1.12.2_j_4a10adb11d709f105fcc111b1ade258d/node_modules/@reactive-dot/wallet-ledger/build/errors.js
var AccountMismatchError = class extends BaseError {
};

// node_modules/.pnpm/@reactive-dot+wallet-ledger@0.16.37_@ledgerhq+hw-transport@6.31.5_polkadot-api@1.12.2_j_4a10adb11d709f105fcc111b1ade258d/node_modules/@reactive-dot/wallet-ledger/build/ledger-wallet.js
var _ledgerAccounts$, _ledgerSigner, _LedgerWallet_instances, assertMatchingAccount_fn, getOrCreateLedgerSigner_fn;
var LedgerWallet = class extends LocalWallet {
  constructor(options) {
    super(options);
    __privateAdd(this, _LedgerWallet_instances);
    __publicField(this, "id", "ledger");
    __publicField(this, "name", "Ledger");
    __privateAdd(this, _ledgerAccounts$, new BehaviorSubject([]));
    __publicField(this, "accounts$", __privateGet(this, _ledgerAccounts$).pipe(map((accounts) => accounts.toSorted((a, b) => a.path - b.path).map((account) => ({
      id: account.id,
      ...account.name === void 0 ? {} : { name: account.name },
      polkadotSigner: ({ tokenSymbol, tokenDecimals }) => ({
        publicKey: account.publicKey,
        signTx: async (...args) => {
          await __privateMethod(this, _LedgerWallet_instances, assertMatchingAccount_fn).call(this, account);
          const ledgerSigner = await __privateMethod(this, _LedgerWallet_instances, getOrCreateLedgerSigner_fn).call(this);
          const polkadotSigner = await ledgerSigner.getPolkadotSigner({ tokenSymbol, decimals: tokenDecimals }, account.path);
          return polkadotSigner.signTx(...args);
        },
        signBytes: async (...args) => {
          await __privateMethod(this, _LedgerWallet_instances, assertMatchingAccount_fn).call(this, account);
          const ledgerSigner = await __privateMethod(this, _LedgerWallet_instances, getOrCreateLedgerSigner_fn).call(this);
          const polkadotSigner = await ledgerSigner.getPolkadotSigner({ tokenSymbol, decimals: tokenDecimals }, account.path);
          return polkadotSigner.signBytes(...args);
        }
      })
    })))));
    __publicField(this, "connected$", this.accounts$.pipe(map((accounts) => accounts.length > 0)));
    __privateAdd(this, _ledgerSigner);
    __publicField(this, "accountStore", {
      add: (account) => {
        __privateGet(this, _ledgerAccounts$).next(__privateGet(this, _ledgerAccounts$).value.filter((storedAccount) => storedAccount.id !== account.id).concat([account]));
      },
      clear: () => {
        __privateGet(this, _ledgerAccounts$).next([]);
      },
      delete: (identifiable) => {
        const id = typeof identifiable === "string" ? identifiable : identifiable.id;
        __privateGet(this, _ledgerAccounts$).next(__privateGet(this, _ledgerAccounts$).value.filter((storedAccount) => storedAccount.id !== id));
      },
      has: (identifiable) => {
        const id = typeof identifiable === "string" ? identifiable : identifiable.id;
        return __privateGet(this, _ledgerAccounts$).value.some((account) => account.id === id);
      },
      values: () => __privateGet(this, _ledgerAccounts$).value
    });
    __privateGet(this, _ledgerAccounts$).pipe(skip(1)).subscribe((accounts) => this.storage.setItem("accounts", JSON.stringify(accounts.map(({ id, ...account }) => ({
      ...account,
      publicKey: Binary.fromBytes(account.publicKey).asHex()
    })))));
  }
  initialize() {
    __privateGet(this, _ledgerAccounts$).next(JSON.parse(this.storage.getItem("accounts") ?? JSON.stringify([])).map((account) => ({
      ...account,
      id: account.publicKey,
      publicKey: Binary.fromHex(account.publicKey).asBytes()
    })));
  }
  async connect() {
    this.accountStore.add(await this.getConnectedAccount());
  }
  disconnect() {
    this.accountStore.clear();
  }
  /**
   * @experimental
   * @param path - The primary derivation index
   * @returns The connected Ledger's account
   */
  async getConnectedAccount(path = 0) {
    const ledgerSigner = await __privateMethod(this, _LedgerWallet_instances, getOrCreateLedgerSigner_fn).call(this);
    const publicKey = await ledgerSigner.getPubkey(path);
    return {
      id: Binary.fromBytes(publicKey).asHex(),
      publicKey,
      path
    };
  }
};
_ledgerAccounts$ = new WeakMap();
_ledgerSigner = new WeakMap();
_LedgerWallet_instances = new WeakSet();
assertMatchingAccount_fn = async function(account) {
  const ledgerSigner = await __privateMethod(this, _LedgerWallet_instances, getOrCreateLedgerSigner_fn).call(this);
  const publicKey = await ledgerSigner.getPubkey(account.path);
  if (Binary.fromBytes(account.publicKey).asHex() !== Binary.fromBytes(publicKey).asHex()) {
    throw new AccountMismatchError();
  }
};
getOrCreateLedgerSigner_fn = async function() {
  if (__privateGet(this, _ledgerSigner) !== void 0) {
    return __privateGet(this, _ledgerSigner);
  }
  if (!("Buffer" in globalThis)) {
    const { default: { Buffer } } = await import("./buffer-KUNOC3WW.js");
    globalThis.Buffer = Buffer;
  }
  const [{ default: TransportWebUSB }, { LedgerSigner }] = await Promise.all([
    import("./TransportWebUSB-QNBS7QHC.js"),
    import("./esm-Q4K6BUP4.js")
  ]);
  return __privateSet(this, _ledgerSigner, new LedgerSigner(
    // @ts-expect-error Weird bug with Ledger
    await TransportWebUSB.create()
  ));
};
export {
  AccountMismatchError,
  LedgerWallet
};
//# sourceMappingURL=@reactive-dot_wallet-ledger.js.map
