{
  "version": 3,
  "sources": ["../../.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/src/codecs.ts", "../../.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/src/get-accessible-types.ts", "../../.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/src/get-lookup.ts", "../../.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/src/get-metadata.ts", "../../.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/src/utils.ts", "../../.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/src/decode-and-collect.ts", "../../.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/src/proof.ts", "../../.pnpm/@polkadot-api+merkleize-metadata@1.1.17/node_modules/@polkadot-api/merkleize-metadata/src/main.ts"],
  "sourcesContent": ["import {\n  Bytes,\n  Codec,\n  CodecType,\n  Option,\n  ScaleEnum,\n  Struct,\n  Tuple,\n  V14Lookup,\n  Vector,\n  _void,\n  bool,\n  compact,\n  compactNumber,\n  enhanceDecoder,\n  str,\n  u16,\n  u32,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst extraInfoInner = {\n  specVersion: u32,\n  specName: str,\n  base58Prefix: u16,\n  decimals: u8,\n  tokenSymbol: str,\n}\nexport const extraInfo = Struct(extraInfoInner)\nexport type ExtraInfo = CodecType<typeof extraInfo>\n\nexport const hash = Bytes(32)\nexport const metadataDigest = ScaleEnum({\n  V0: _void,\n  V1: Struct({\n    typeInformationTreeRoot: hash,\n    extrinsicMetadataHash: hash,\n    ...extraInfoInner,\n  }),\n})\nexport type MetadataDigest = CodecType<typeof metadataDigest>\n\nexport const scalePrimitive = ScaleEnum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\nexport type ScalePrimitive = CodecType<typeof scalePrimitive>\n\nexport const typeRef = ScaleEnum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n  compactU8: _void,\n  compactU16: _void,\n  compactU32: _void,\n  compactU64: _void,\n  compactU128: _void,\n  compactU256: _void,\n  void: _void,\n  perId: compactNumber,\n})\nexport type TypeRef = CodecType<typeof typeRef>\n\nconst field = Struct({\n  name: Option(str),\n  ty: typeRef,\n  typeName: Option(str),\n})\nexport const typeDef = ScaleEnum({\n  composite: Vector(field),\n  enumeration: Struct({\n    name: str,\n    fields: Vector(field),\n    index: compactNumber,\n  }),\n  sequence: typeRef,\n  array: Struct({\n    len: u32,\n    typeParam: typeRef,\n  }),\n  tuple: Vector(typeRef),\n  bitSequence: Struct({\n    numBytes: u8,\n    leastSignificantBitFirst: bool,\n  }),\n})\nexport type TypeDef = CodecType<typeof typeDef>\n\nexport const lookupType = Struct({\n  path: Vector(str),\n  typeDef: typeDef,\n  typeId: compactNumber,\n})\nexport type LookupEntry = CodecType<typeof lookupType>\nexport type Lookup = Array<LookupEntry>\nexport const lookup: Codec<Lookup> = Vector(lookupType)\n\nexport const extrinsicMetadata = Struct({\n  version: u8,\n  addressTy: typeRef,\n  callTy: typeRef,\n  signatureTy: typeRef,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      includedInExtrinsic: typeRef,\n      includedInSignedData: typeRef,\n    }),\n  ),\n})\nexport type ExtrinsicMetadata = CodecType<typeof extrinsicMetadata>\nexport type LookupValue = V14Lookup[number]\n\nconst versionDecoder = enhanceDecoder(u8[1], (value) => ({\n  version: value & ~(1 << 7),\n  signed: !!(value & (1 << 7)),\n}))\n\nexport const extrinsicDec = Tuple.dec(\n  compact[1],\n  versionDecoder,\n  Bytes(Infinity)[1],\n)\n\nexport const proof = Struct({\n  leaves: lookup,\n  leafIdxs: Vector(u32),\n  proofs: Vector(hash),\n  extrinsic: extrinsicMetadata,\n  info: extraInfo,\n})\nexport type Proof = CodecType<typeof proof>\n", "import { UnifiedMetadata } from \"@polkadot-api/substrate-bindings\"\nimport { LookupValue } from \"./codecs\"\n\nexport const getAccessibleTypes = (\n  metadata: UnifiedMetadata<15 | 16>,\n  definitions: Map<number, LookupValue>,\n): Map<number, number> => {\n  const types = new Set<number>()\n\n  const collectTypesFromId = (id: number) => {\n    if (types.has(id)) return\n\n    const { tag, value } = definitions.get(id)!.def\n    switch (tag) {\n      case \"composite\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(({ type }) => {\n          collectTypesFromId(type)\n        })\n        break\n      case \"variant\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(({ fields }) => {\n          fields.forEach(({ type }) => {\n            collectTypesFromId(type)\n          })\n        })\n        break\n      case \"tuple\":\n        if (!value.length) break\n        types.add(id)\n        value.forEach(collectTypesFromId)\n        break\n      case \"sequence\":\n        types.add(id)\n        collectTypesFromId(value)\n        break\n      case \"array\":\n        types.add(id)\n        collectTypesFromId(value.type)\n        break\n      case \"bitSequence\": // bitSequence inner types are not stored\n        types.add(id)\n      // primitive and compact are not stored\n    }\n  }\n\n  collectTypesFromId(metadata.extrinsic.call)\n  collectTypesFromId(metadata.extrinsic.address)\n  collectTypesFromId(metadata.extrinsic.signature)\n  metadata.extrinsic.signedExtensions.forEach(({ type, additionalSigned }) => {\n    collectTypesFromId(type)\n    collectTypesFromId(additionalSigned)\n  })\n\n  const sortedTypes = [...types].sort((a, b) => a - b)\n  return new Map(sortedTypes.map((value, idx) => [value, idx]))\n}\n", "import { Lookup, LookupValue, ScalePrimitive, TypeDef, TypeRef } from \"./codecs\"\n\nconst bitSequenceBytes = {\n  u8: 1,\n  u16: 2,\n  u32: 4,\n  u64: 8,\n}\n\nconst constructTypeDef = (\n  definitions: Map<number, LookupValue>,\n  getTypeRef: (frameId: number) => TypeRef,\n  getPrimitive: (frameId: number) => ScalePrimitive[\"tag\"] | null,\n  frameId: number,\n): TypeDef[] => {\n  const {\n    def: { tag, value },\n  } = definitions.get(frameId)!\n  switch (tag) {\n    case \"composite\":\n      return [\n        {\n          tag,\n          value: value.map((f) => ({\n            name: f.name,\n            typeName: f.typeName,\n            ty: getTypeRef(f.type),\n          })),\n        },\n      ]\n    case \"variant\": {\n      return value.map((v) => ({\n        tag: \"enumeration\",\n        value: {\n          name: v.name,\n          index: v.index,\n          fields: v.fields.map((f) => ({\n            name: f.name,\n            typeName: f.typeName,\n            ty: getTypeRef(f.type),\n          })),\n        },\n      }))\n    }\n    case \"sequence\":\n      return [\n        {\n          tag,\n          value: getTypeRef(value),\n        },\n      ]\n    case \"array\":\n      return [\n        {\n          tag,\n          value: {\n            len: value.len,\n            typeParam: getTypeRef(value.type),\n          },\n        },\n      ]\n    case \"tuple\":\n      return [\n        {\n          tag,\n          value: value.map(getTypeRef),\n        },\n      ]\n    case \"bitSequence\": {\n      const primitive = getPrimitive(value.bitStoreType)\n      const numBytes = bitSequenceBytes[primitive as \"u8\"]\n      if (!numBytes) throw new Error(\"Invalid primitive for BitSequence\")\n\n      const storeOrderPath = definitions.get(value.bitOrderType)!.path\n      const leastSignificantBitFirst = storeOrderPath.includes(\"Lsb0\")\n      if (!leastSignificantBitFirst && !storeOrderPath.includes(\"Msb0\"))\n        throw new Error(\"BitOrderType not recognized\")\n\n      return [\n        {\n          tag: \"bitSequence\",\n          value: { numBytes, leastSignificantBitFirst },\n        },\n      ]\n    }\n  }\n\n  throw new Error(`FrameId(${frameId}) should have been filtered out`)\n}\n\nexport const getLookup = (\n  definitions: Map<number, LookupValue>,\n  accessibleTypes: Map<number, number>,\n  getTypeRef: (frameId: number) => TypeRef,\n  getPrimitive: (frameId: number) => ScalePrimitive[\"tag\"] | null,\n) => {\n  const typeTree: Lookup = []\n  ;[...accessibleTypes.entries()].forEach(([frameId, typeId]) => {\n    const { path } = definitions.get(frameId)!\n    constructTypeDef(definitions, getTypeRef, getPrimitive, frameId).forEach(\n      (typeDef) => {\n        typeTree.push({\n          path,\n          typeId,\n          typeDef,\n        })\n      },\n    )\n  })\n\n  typeTree.sort((a, b) => {\n    if (a.typeId !== b.typeId) return a.typeId - b.typeId // in general\n    // should only happen for variants\n    if (a.typeDef.tag !== \"enumeration\" || b.typeDef.tag !== \"enumeration\")\n      throw new Error(\"Found two types with same id\")\n    return a.typeDef.value.index - b.typeDef.value.index\n  })\n  return typeTree\n}\n", "import {\n  decAnyMetadata,\n  UnifiedMetadata,\n  type HexString,\n  unifyMetadata,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const getMetadata = (\n  input: Uint8Array | HexString,\n): UnifiedMetadata<15 | 16> => {\n  try {\n    const metadata = unifyMetadata(decAnyMetadata(input))\n    if (metadata.version <= 14) throw new Error(\"Wrong metadata version\")\n    return metadata as UnifiedMetadata<15 | 16>\n  } catch (e) {\n    throw e || new Error(\"Unable to decode metadata\")\n  }\n}\n", "import { type HexString } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex } from \"@polkadot-api/utils\"\n\nexport const mergeUint8 = (inputs: Array<Uint8Array>): Uint8Array => {\n  const len = inputs.length\n  let totalLen = 0\n  for (let i = 0; i < len; i++) totalLen += inputs[i].byteLength\n  const result = new Uint8Array(totalLen)\n\n  for (let idx = 0, at = 0; idx < len; idx++) {\n    const current = inputs[idx]\n    result.set(current, at)\n    at += current.byteLength\n  }\n\n  return result\n}\n\nexport const toBytes = (input: Uint8Array | HexString) =>\n  typeof input === \"string\" ? fromHex(input) : input\n\nexport const compactTypeRefs = {\n  null: \"void\" as const,\n  u8: \"compactU8\" as const,\n  u16: \"compactU16\" as const,\n  u32: \"compactU32\" as const,\n  u64: \"compactU64\" as const,\n  u128: \"compactU128\" as const,\n  u256: \"compactU256\" as const,\n}\n", "import {\n  HexString,\n  _void,\n  compact,\n  createDecoder,\n  i128,\n  i16,\n  i256,\n  i32,\n  i64,\n  i8,\n  str,\n  u128,\n  u16,\n  u256,\n  u32,\n  u64,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { Lookup, TypeDef, TypeRef } from \"./codecs\"\n\nconst typeRefDecoders = {\n  bool: u8,\n  char: u8,\n  str,\n  u8,\n  u16,\n  u32,\n  u64,\n  u128,\n  u256,\n  i8,\n  i16,\n  i32,\n  i64,\n  i128,\n  i256,\n  void: _void,\n  compactU8: compact,\n  compactU16: compact,\n  compactU32: compact,\n  compactU64: compact,\n  compactU128: compact,\n  compactU256: compact,\n}\n\nconst innerDecodeAndCollect = (\n  input: Uint8Array,\n  typeRef: TypeRef,\n  idToLookups: Map<number, Array<number>>,\n  lookup: Lookup,\n  collected: Set<number>,\n) => {\n  if (typeRef.tag !== \"perId\") {\n    typeRefDecoders[typeRef.tag][1](input)\n    return\n  }\n\n  const handleTypeRef = (typeRef: TypeRef) => {\n    innerDecodeAndCollect(input, typeRef, idToLookups, lookup, collected)\n  }\n\n  const lookupIdxs = idToLookups.get(typeRef.value)!\n  const [currentIdx] = lookupIdxs\n  const current = lookup[currentIdx]\n\n  if (lookupIdxs.length === 1) collected.add(currentIdx)\n\n  switch (current.typeDef.tag) {\n    case \"enumeration\": {\n      const selectedIdx = u8.dec(input)\n      const [selected, collectedIdx] = lookupIdxs\n        .map(\n          (lookupIdx) =>\n            [lookup[lookupIdx].typeDef, lookupIdx] as [\n              TypeDef & { tag: \"enumeration\" },\n              number,\n            ],\n        )\n        .find(([x]) => x.value.index === selectedIdx)!\n      collected.add(collectedIdx)\n      selected.value.fields.forEach(({ ty }) => {\n        handleTypeRef(ty)\n      })\n      break\n    }\n    case \"sequence\": {\n      const len = compact.dec(input)\n      for (let i = 0; i < len; i++) handleTypeRef(current.typeDef.value)\n      break\n    }\n    case \"array\": {\n      for (let i = 0; i < current.typeDef.value.len; i++)\n        handleTypeRef(current.typeDef.value.typeParam)\n      break\n    }\n    case \"composite\": {\n      current.typeDef.value.forEach((x) => {\n        handleTypeRef(x.ty)\n      })\n      break\n    }\n    case \"tuple\": {\n      current.typeDef.value.forEach(handleTypeRef)\n      break\n    }\n    case \"bitSequence\":\n      throw new Error(\"bitSequence is not supported\")\n  }\n}\n\nexport const decodeAndCollectKnownLeafs = (\n  data: Uint8Array | HexString,\n  typeRefs: Array<TypeRef>,\n  lookup: Lookup,\n): Array<number> => {\n  let input = new Uint8Array()\n  createDecoder((_input) => {\n    input = _input\n  })(data)\n\n  const idToLookups = new Map<number, number[]>()\n  lookup.forEach((lookup, idx) => {\n    const arr = idToLookups.get(lookup.typeId)\n    if (arr) arr.push(idx)\n    else idToLookups.set(lookup.typeId, [idx])\n  })\n\n  const result = new Set<number>()\n  typeRefs.forEach((typeRef) => {\n    innerDecodeAndCollect(input, typeRef, idToLookups, lookup, result)\n  })\n\n  return [...result].sort((a, b) => a - b)\n}\n", "const getLevelFromIdx = (idx: number) => Math.log2(idx + 1) | 0\nconst getAncestorIdx = (from: number, nLevels: number) =>\n  ((from + 1) >> nLevels) - 1\n\nexport function getProofData(\n  leaves: Array<Uint8Array>,\n  knownLeavesIdxs: Array<number>,\n) {\n  const knownLeaves = knownLeavesIdxs.map((idx) => leaves[idx])\n\n  const startingIdx = leaves.length - 1\n  const leafIdxs = knownLeavesIdxs.map((idx) => startingIdx + idx)\n\n  const proofIdxs: Array<number> = []\n  if (leafIdxs.length) {\n    const nLevels = getLevelFromIdx(leafIdxs.at(-1)!)\n    const splitPosition = Math.pow(2, nLevels) - 1\n    const splitIdx = leafIdxs.findIndex((x) => x >= splitPosition)\n    if (splitIdx > 0) {\n      leafIdxs.unshift(...leafIdxs.splice(splitIdx))\n      knownLeaves.unshift(...knownLeaves.splice(splitIdx))\n    }\n  }\n\n  let targetIdx = 0\n  const traverse = (nodeIdx: number): void => {\n    if (targetIdx === leafIdxs.length) {\n      proofIdxs.push(nodeIdx)\n      return\n    }\n\n    const target = leafIdxs[targetIdx]\n    if (target === nodeIdx) {\n      ++targetIdx\n      return\n    }\n\n    const currentLevel = getLevelFromIdx(nodeIdx)\n    const targetLevel = getLevelFromIdx(target)\n\n    if (nodeIdx !== getAncestorIdx(target, targetLevel - currentLevel)) {\n      proofIdxs.push(nodeIdx)\n      return\n    }\n\n    const leftSon = 2 * nodeIdx + 1\n    traverse(leftSon)\n    traverse(leftSon + 1)\n  }\n  traverse(0)\n\n  return {\n    leaves: knownLeaves,\n    leafIdxs,\n    proofIdxs,\n  }\n}\n", "import {\n  Blake3256,\n  HexString,\n  compact,\n  u32,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  ExtraInfo,\n  ExtrinsicMetadata,\n  LookupValue,\n  MetadataDigest,\n  ScalePrimitive,\n  TypeRef,\n  extraInfo,\n  extrinsicMetadata,\n  lookupType,\n  metadataDigest,\n  extrinsicDec,\n} from \"./codecs\"\nimport { getAccessibleTypes } from \"./get-accessible-types\"\nimport { getLookup } from \"./get-lookup\"\nimport { getMetadata } from \"./get-metadata\"\nimport { compactTypeRefs, mergeUint8, toBytes } from \"./utils\"\nimport { decodeAndCollectKnownLeafs } from \"./decode-and-collect\"\nimport { getProofData } from \"./proof\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\n\nexport interface MetadataMerkleizer {\n  /**\n   * @returns Digest value of the metadata (aka its merkleized root-hash)\n   */\n  digest: () => Uint8Array\n\n  /**\n   * Get proof for an `Extrinsic`.\n   *\n   * @param transaction         Encoded `Extrinsic`, both signed or unsigned.\n   * @param txAdditionalSigned  Optionally collect types for given\n   *                            `additionalSigned` part of signedExtensions.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsic: (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload` parts.\n   *\n   * @param callData              Call data of the transaction. It has to be\n   *                              bare; i.e.\n   *                              without prepended compact length.\n   * @param includedInExtrinsic   Extra part of the signed extensions, all of\n   *                              them concatenated.\n   * @param includedInSignedData  Additional signed part of the signed\n   *                              extensions, all of them concatenated.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicParts: (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => Uint8Array\n\n  /**\n   * Get proof for `ExtrinsicPayload`.\n   *\n   * @param extrinsicPayload  Call data, extra part of signedExtensions and\n   *                          additional signed part of signedExtensions\n   *                          concatenated. It has to be bare; i.e. without\n   *                          prepended compact length.\n   * @returns Encoded `Proof`\n   */\n  getProofForExtrinsicPayload: (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => Uint8Array\n}\n\nconst assertExpected = <T>(name: string, expected: T, received?: T): void => {\n  if (received != null && received !== expected)\n    throw new Error(\n      `${name} not expected. Received ${received} expected ${expected}`,\n    )\n}\n\nexport const merkleizeMetadata = (\n  metadataBytes: Uint8Array | HexString,\n  {\n    decimals,\n    tokenSymbol,\n    ...hinted\n  }: { decimals: number; tokenSymbol: string } & Partial<ExtraInfo>,\n): MetadataMerkleizer => {\n  const metadata = getMetadata(metadataBytes)\n\n  const checkedVersion = metadata.extrinsic.version.includes(4) ? 4 : null\n  if (checkedVersion == null) throw new Error(\"Only extrinsic v4 is supported\")\n\n  const { ss58Prefix, buildDefinition } = getDynamicBuilder(\n    getLookupFn(metadata),\n  )\n  if (ss58Prefix == null) throw new Error(\"SS58 prefix not found in metadata\")\n  assertExpected(\"SS58 prefix\", ss58Prefix, hinted.base58Prefix)\n  const version = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"Version\")\n  if (version == null) throw new Error(\"System.Version constant not found\")\n  const { spec_name: specName, spec_version: specVersion } = buildDefinition(\n    version.type,\n  ).dec(version.value)\n  if (typeof specName !== \"string\" || typeof specVersion !== \"number\")\n    throw new Error(\"Spec name or spec version not found\")\n  assertExpected(\"Spec name\", specName, hinted.specName)\n  assertExpected(\"Spec version\", specVersion, hinted.specVersion)\n\n  const info: ExtraInfo = {\n    decimals,\n    tokenSymbol,\n    specVersion,\n    specName,\n    base58Prefix: ss58Prefix,\n  }\n  const definitions = new Map<number, LookupValue>(\n    metadata.lookup.map((value) => [value.id, value]),\n  )\n  const accessibleTypes = getAccessibleTypes(metadata, definitions)\n  const getPrimitive = (frameId: number): ScalePrimitive[\"tag\"] | null => {\n    const {\n      def: { tag, value },\n    } = definitions.get(frameId)!\n\n    if (tag === \"primitive\") return value.tag\n\n    if ((tag !== \"composite\" && tag !== \"tuple\") || value.length > 1)\n      throw new Error(\"The provided definition doesn't map to a primitive\")\n\n    return value.length === 0\n      ? null // signals `void`\n      : getPrimitive(tag === \"tuple\" ? value[0] : value[0].type)\n  }\n\n  const getTypeRef = (frameId: number): TypeRef => {\n    const { def } = definitions.get(frameId)!\n\n    if (def.tag === \"primitive\") return { tag: def.value.tag, value: undefined }\n\n    if (def.tag === \"compact\") {\n      const primitive = getPrimitive(def.value)\n      const tag = compactTypeRefs[primitive as \"u8\"]\n      if (!tag) throw new Error(\"Invalid primitive for Compact\")\n      return { tag, value: undefined }\n    }\n\n    return accessibleTypes.has(frameId)\n      ? { tag: \"perId\", value: accessibleTypes.get(frameId)! }\n      : { tag: \"void\", value: undefined }\n  }\n\n  const extrinsic: ExtrinsicMetadata = {\n    version: checkedVersion,\n    addressTy: getTypeRef(metadata.extrinsic.address),\n    callTy: getTypeRef(metadata.extrinsic.call),\n    signatureTy: getTypeRef(metadata.extrinsic.signature),\n    signedExtensions: metadata.extrinsic.signedExtensions.map((se) => ({\n      identifier: se.identifier,\n      includedInExtrinsic: getTypeRef(se.type),\n      includedInSignedData: getTypeRef(se.additionalSigned),\n    })),\n  }\n\n  const lookup = getLookup(\n    definitions,\n    accessibleTypes,\n    getTypeRef,\n    getPrimitive,\n  )\n  const lookupEncoded = lookup.map(lookupType.enc)\n\n  let hashTree: Array<Uint8Array> | undefined\n  const getHashTree = (): Array<Uint8Array> => {\n    if (hashTree) return hashTree\n\n    if (!lookupEncoded.length) return (hashTree = [new Uint8Array(32).fill(0)])\n\n    hashTree = new Array(lookupEncoded.length * 2 - 1)\n\n    let leavesStartIdx = lookupEncoded.length - 1\n    for (let i = 0; i < lookupEncoded.length; i++)\n      hashTree[leavesStartIdx + i] = Blake3256(lookupEncoded[i])\n\n    for (let i = hashTree.length - 2; i > 0; i -= 2)\n      hashTree[(i - 1) / 2] = Blake3256(\n        mergeUint8([hashTree[i], hashTree[i + 1]]),\n      )\n\n    return hashTree\n  }\n\n  let digested: undefined | Uint8Array\n  const digest = () => {\n    if (digested) return digested\n    const rootLookupHash = getHashTree()[0]\n\n    const digest: MetadataDigest = {\n      tag: \"V1\",\n      value: {\n        typeInformationTreeRoot: rootLookupHash,\n        extrinsicMetadataHash: Blake3256(extrinsicMetadata.enc(extrinsic)),\n        ...info,\n      },\n    }\n\n    return (digested = Blake3256(metadataDigest.enc(digest)))\n  }\n\n  const generateProof = (knownIndexes: number[]) => {\n    const proofData = getProofData(lookupEncoded, knownIndexes)\n\n    const hashTree = getHashTree()\n    const proofs = proofData.proofIdxs.map((idx) => hashTree[idx])\n\n    return mergeUint8([\n      compact.enc(proofData.leaves.length),\n      ...proofData.leaves,\n      compact.enc(proofData.leafIdxs.length),\n      ...proofData.leafIdxs.map((x) => u32.enc(x)),\n      compact.enc(proofs.length),\n      ...proofs,\n      extrinsicMetadata.enc(extrinsic),\n      extraInfo.enc(info),\n    ])\n  }\n\n  const getProofForExtrinsicPayload = (\n    extrinsicPayload: Uint8Array | HexString,\n  ) => {\n    const typeRefs: Array<TypeRef> = [\n      extrinsic.callTy,\n      ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n      ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n    ]\n    return generateProof(\n      decodeAndCollectKnownLeafs(extrinsicPayload, typeRefs, lookup),\n    )\n  }\n\n  const getProofForExtrinsicParts = (\n    callData: Uint8Array | HexString,\n    includedInExtrinsic: Uint8Array | HexString,\n    includedInSignedData: Uint8Array | HexString,\n  ) => {\n    const bytes = mergeUint8(\n      [callData, includedInExtrinsic, includedInSignedData].map(toBytes),\n    )\n    return getProofForExtrinsicPayload(bytes)\n  }\n\n  const getProofForExtrinsic = (\n    transaction: Uint8Array | HexString,\n    txAdditionalSigned?: Uint8Array | HexString,\n  ) => {\n    let [, { version, signed }, bytes] = extrinsicDec(transaction)\n\n    if (version !== extrinsic.version)\n      throw new Error(\"Incorrect extrinsic version\")\n\n    const typeRefs: TypeRef[] = signed\n      ? [\n          extrinsic.addressTy,\n          extrinsic.signatureTy,\n          ...extrinsic.signedExtensions.map((x) => x.includedInExtrinsic),\n          extrinsic.callTy,\n        ]\n      : [extrinsic.callTy]\n\n    if (txAdditionalSigned) {\n      bytes = mergeUint8([bytes, toBytes(txAdditionalSigned)])\n      typeRefs.push(\n        ...extrinsic.signedExtensions.map((x) => x.includedInSignedData),\n      )\n    }\n\n    return generateProof(decodeAndCollectKnownLeafs(bytes, typeRefs, lookup))\n  }\n\n  return {\n    digest,\n    getProofForExtrinsic,\n    getProofForExtrinsicParts,\n    getProofForExtrinsicPayload,\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBA,IAAM,iBAAiB;EACrB,aAAa;EACb,UAAU;EACV,cAAc;EACd,UAAU;EACV,aAAa;AACf;AACa,IAAA,YAAY,OAAO,cAAc;AAGjC,IAAA,OAAO,MAAM,EAAE;AACrB,IAAM,iBAAiB,UAAU;EACtC,IAAI;EACJ,IAAI,OAAO;IACT,yBAAyB;IACzB,uBAAuB;IACvB,GAAG;EAAA,CACJ;AACH,CAAC;AAG6B,UAAU;EACtC,MAAM;EACN,MAAM;EACN,KAAK;EACL,IAAI;EACJ,KAAK;EACL,KAAK;EACL,KAAK;EACL,MAAM;EACN,MAAM;EACN,IAAI;EACJ,KAAK;EACL,KAAK;EACL,KAAK;EACL,MAAM;EACN,MAAM;AACR,CAAC;AAGM,IAAM,UAAU,UAAU;EAC/B,MAAM;EACN,MAAM;EACN,KAAK;EACL,IAAI;EACJ,KAAK;EACL,KAAK;EACL,KAAK;EACL,MAAM;EACN,MAAM;EACN,IAAI;EACJ,KAAK;EACL,KAAK;EACL,KAAK;EACL,MAAM;EACN,MAAM;EACN,WAAW;EACX,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,aAAa;EACb,aAAa;EACb,MAAM;EACN,OAAO;AACT,CAAC;AAGD,IAAM,QAAQ,OAAO;EACnB,MAAM,OAAO,GAAG;EAChB,IAAI;EACJ,UAAU,OAAO,GAAG;AACtB,CAAC;AACM,IAAM,UAAU,UAAU;EAC/B,WAAW,OAAO,KAAK;EACvB,aAAa,OAAO;IAClB,MAAM;IACN,QAAQ,OAAO,KAAK;IACpB,OAAO;EAAA,CACR;EACD,UAAU;EACV,OAAO,OAAO;IACZ,KAAK;IACL,WAAW;EAAA,CACZ;EACD,OAAO,OAAO,OAAO;EACrB,aAAa,OAAO;IAClB,UAAU;IACV,0BAA0B;EAAA,CAC3B;AACH,CAAC;AAGM,IAAM,aAAa,OAAO;EAC/B,MAAM,OAAO,GAAG;EAChB;EACA,QAAQ;AACV,CAAC;AAGY,IAAA,SAAwB,OAAO,UAAU;AAE/C,IAAM,oBAAoB,OAAO;EACtC,SAAS;EACT,WAAW;EACX,QAAQ;EACR,aAAa;EACb,kBAAkB;IAChB,OAAO;MACL,YAAY;MACZ,qBAAqB;MACrB,sBAAsB;IAAA,CACvB;EAAA;AAEL,CAAC;AAID,IAAM,iBAAiB,eAAe,GAAG,CAAC,GAAG,CAAC,WAAW;EACvD,SAAS,QAAQ;EACjB,QAAQ,CAAC,EAAE,QAAS,KAAK;AAC3B,EAAE;AAEK,IAAM,eAAe,MAAM;EAChC,QAAQ,CAAC;EACT;EACA,MAAM,QAAQ,EAAE,CAAC;AACnB;AAEO,IAAM,QAAQ,OAAO;EAC1B,QAAQ;EACR,UAAU,OAAO,GAAG;EACpB,QAAQ,OAAO,IAAI;EACnB,WAAW;EACX,MAAM;AACR,CAAC;;;ACxJY,IAAA,qBAAqB,CAChC,UACA,gBACwB;AAClB,QAAA,QAAA,oBAAY,IAAY;AAExB,QAAA,qBAAqB,CAAC,OAAe;AACrC,QAAA,MAAM,IAAI,EAAE,EAAG;AAEnB,UAAM,EAAE,KAAK,MAAA,IAAU,YAAY,IAAI,EAAE,EAAG;AAC5C,YAAQ,KAAK;MACX,KAAK;AACC,YAAA,CAAC,MAAM,OAAQ;AACnB,cAAM,IAAI,EAAE;AACZ,cAAM,QAAQ,CAAC,EAAE,KAAA,MAAW;AAC1B,6BAAmB,IAAI;QAAA,CACxB;AACD;MACF,KAAK;AACC,YAAA,CAAC,MAAM,OAAQ;AACnB,cAAM,IAAI,EAAE;AACZ,cAAM,QAAQ,CAAC,EAAE,OAAA,MAAa;AAC5B,iBAAO,QAAQ,CAAC,EAAE,KAAA,MAAW;AAC3B,+BAAmB,IAAI;UAAA,CACxB;QAAA,CACF;AACD;MACF,KAAK;AACC,YAAA,CAAC,MAAM,OAAQ;AACnB,cAAM,IAAI,EAAE;AACZ,cAAM,QAAQ,kBAAkB;AAChC;MACF,KAAK;AACH,cAAM,IAAI,EAAE;AACZ,2BAAmB,KAAK;AACxB;MACF,KAAK;AACH,cAAM,IAAI,EAAE;AACZ,2BAAmB,MAAM,IAAI;AAC7B;MACF,KAAK;AACH,cAAM,IAAI,EAAE;IAAA;EAEhB;AAGiB,qBAAA,SAAS,UAAU,IAAI;AACvB,qBAAA,SAAS,UAAU,OAAO;AAC1B,qBAAA,SAAS,UAAU,SAAS;AAC/C,WAAS,UAAU,iBAAiB,QAAQ,CAAC,EAAE,MAAM,iBAAA,MAAuB;AAC1E,uBAAmB,IAAI;AACvB,uBAAmB,gBAAgB;EAAA,CACpC;AAEK,QAAA,cAAc,CAAC,GAAG,KAAK,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAC5C,SAAA,IAAI,IAAI,YAAY,IAAI,CAAC,OAAO,QAAQ,CAAC,OAAO,GAAG,CAAC,CAAC;AAC9D;;;ACzDA,IAAM,mBAAmB;EACvB,IAAI;EACJ,KAAK;EACL,KAAK;EACL,KAAK;AACP;AAEA,IAAM,mBAAmB,CACvB,aACA,YACA,cACA,YACc;AACR,QAAA;IACJ,KAAK,EAAE,KAAK,MAAM;EAAA,IAChB,YAAY,IAAI,OAAO;AAC3B,UAAQ,KAAK;IACX,KAAK;AACI,aAAA;QACL;UACE;UACA,OAAO,MAAM,IAAI,CAAC,OAAO;YACvB,MAAM,EAAE;YACR,UAAU,EAAE;YACZ,IAAI,WAAW,EAAE,IAAI;UAAA,EACrB;QAAA;MACJ;IAEJ,KAAK,WAAW;AACP,aAAA,MAAM,IAAI,CAAC,OAAO;QACvB,KAAK;QACL,OAAO;UACL,MAAM,EAAE;UACR,OAAO,EAAE;UACT,QAAQ,EAAE,OAAO,IAAI,CAAC,OAAO;YAC3B,MAAM,EAAE;YACR,UAAU,EAAE;YACZ,IAAI,WAAW,EAAE,IAAI;UAAA,EACrB;QAAA;MACJ,EACA;IAAA;IAEJ,KAAK;AACI,aAAA;QACL;UACE;UACA,OAAO,WAAW,KAAK;QAAA;MACzB;IAEJ,KAAK;AACI,aAAA;QACL;UACE;UACA,OAAO;YACL,KAAK,MAAM;YACX,WAAW,WAAW,MAAM,IAAI;UAAA;QAClC;MACF;IAEJ,KAAK;AACI,aAAA;QACL;UACE;UACA,OAAO,MAAM,IAAI,UAAU;QAAA;MAC7B;IAEJ,KAAK,eAAe;AACZ,YAAA,YAAY,aAAa,MAAM,YAAY;AAC3C,YAAA,WAAW,iBAAiB,SAAiB;AACnD,UAAI,CAAC,SAAgB,OAAA,IAAI,MAAM,mCAAmC;AAElE,YAAM,iBAAiB,YAAY,IAAI,MAAM,YAAY,EAAG;AACtD,YAAA,2BAA2B,eAAe,SAAS,MAAM;AAC/D,UAAI,CAAC,4BAA4B,CAAC,eAAe,SAAS,MAAM;AACxD,cAAA,IAAI,MAAM,6BAA6B;AAExC,aAAA;QACL;UACE,KAAK;UACL,OAAO,EAAE,UAAU,yBAAyB;QAAA;MAC9C;IACF;EACF;AAGF,QAAM,IAAI,MAAM,WAAW,OAAO,iCAAiC;AACrE;AAEO,IAAM,YAAY,CACvB,aACA,iBACA,YACA,iBACG;AACH,QAAM,WAAmB,CAAA;AACvB,GAAA,GAAG,gBAAgB,QAAA,CAAS,EAAE,QAAQ,CAAC,CAAC,SAAS,MAAM,MAAM;AAC7D,UAAM,EAAE,KAAA,IAAS,YAAY,IAAI,OAAO;AACxC,qBAAiB,aAAa,YAAY,cAAc,OAAO,EAAE;MAC/D,CAACA,aAAY;AACX,iBAAS,KAAK;UACZ;UACA;UACA,SAAAA;QAAA,CACD;MAAA;IACH;EACF,CACD;AAEQ,WAAA,KAAK,CAAC,GAAG,MAAM;AACtB,QAAI,EAAE,WAAW,EAAE,OAAe,QAAA,EAAE,SAAS,EAAE;AAE/C,QAAI,EAAE,QAAQ,QAAQ,iBAAiB,EAAE,QAAQ,QAAQ;AACjD,YAAA,IAAI,MAAM,8BAA8B;AAChD,WAAO,EAAE,QAAQ,MAAM,QAAQ,EAAE,QAAQ,MAAM;EAAA,CAChD;AACM,SAAA;AACT;;;AC/Ga,IAAA,cAAc,CACzB,UAC6B;AACzB,MAAA;AACF,UAAM,WAAW,cAAc,eAAe,KAAK,CAAC;AACpD,QAAI,SAAS,WAAW,GAAU,OAAA,IAAI,MAAM,wBAAwB;AAC7D,WAAA;EAAA,SACA,GAAG;AACJ,UAAA,KAAK,IAAI,MAAM,2BAA2B;EAAA;AAEpD;;;ACda,IAAA,aAAa,CAAC,WAA0C;AACnE,QAAM,MAAM,OAAO;AACnB,MAAI,WAAW;AACN,WAAA,IAAI,GAAG,IAAI,KAAK,IAAiB,aAAA,OAAO,CAAC,EAAE;AAC9C,QAAA,SAAS,IAAI,WAAW,QAAQ;AAEtC,WAAS,MAAM,GAAG,KAAK,GAAG,MAAM,KAAK,OAAO;AACpC,UAAA,UAAU,OAAO,GAAG;AACnB,WAAA,IAAI,SAAS,EAAE;AACtB,UAAM,QAAQ;EAAA;AAGT,SAAA;AACT;AAEa,IAAA,UAAU,CAAC,UACtB,OAAO,UAAU,WAAW,QAAQ,KAAK,IAAI;AAExC,IAAM,kBAAkB;EAC7B,MAAM;EACN,IAAI;EACJ,KAAK;EACL,KAAK;EACL,KAAK;EACL,MAAM;EACN,MAAM;AACR;;;ACRA,IAAM,kBAAkB;EACtB,MAAM;EACN,MAAM;EACN;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM;EACN,WAAW;EACX,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,aAAa;EACb,aAAa;AACf;AAEA,IAAM,wBAAwB,CAC5B,OACAC,UACA,aACAC,SACA,cACG;AACC,MAAAD,SAAQ,QAAQ,SAAS;AAC3B,oBAAgBA,SAAQ,GAAG,EAAE,CAAC,EAAE,KAAK;AACrC;EAAA;AAGI,QAAA,gBAAgB,CAACA,cAAqB;AAC1C,0BAAsB,OAAOA,WAAS,aAAaC,SAAQ,SAAS;EAAA;AAGtE,QAAM,aAAa,YAAY,IAAID,SAAQ,KAAK;AAC1C,QAAA,CAAC,UAAU,IAAI;AACf,QAAA,UAAUC,QAAO,UAAU;AAEjC,MAAI,WAAW,WAAW,EAAG,WAAU,IAAI,UAAU;AAE7C,UAAA,QAAQ,QAAQ,KAAK;IAC3B,KAAK,eAAe;AACZ,YAAA,cAAc,GAAG,IAAI,KAAK;AAChC,YAAM,CAAC,UAAU,YAAY,IAAI,WAC9B;QACC,CAAC,cACC,CAACA,QAAO,SAAS,EAAE,SAAS,SAAS;MAAA,EAKxC,KAAK,CAAC,CAAC,CAAC,MAAM,EAAE,MAAM,UAAU,WAAW;AAC9C,gBAAU,IAAI,YAAY;AAC1B,eAAS,MAAM,OAAO,QAAQ,CAAC,EAAE,GAAA,MAAS;AACxC,sBAAc,EAAE;MAAA,CACjB;AACD;IAAA;IAEF,KAAK,YAAY;AACT,YAAA,MAAM,QAAQ,IAAI,KAAK;AACpB,eAAA,IAAI,GAAG,IAAI,KAAK,IAAmB,eAAA,QAAQ,QAAQ,KAAK;AACjE;IAAA;IAEF,KAAK,SAAS;AACZ,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,MAAM,KAAK;AAC/B,sBAAA,QAAQ,QAAQ,MAAM,SAAS;AAC/C;IAAA;IAEF,KAAK,aAAa;AAChB,cAAQ,QAAQ,MAAM,QAAQ,CAAC,MAAM;AACnC,sBAAc,EAAE,EAAE;MAAA,CACnB;AACD;IAAA;IAEF,KAAK,SAAS;AACJ,cAAA,QAAQ,MAAM,QAAQ,aAAa;AAC3C;IAAA;IAEF,KAAK;AACG,YAAA,IAAI,MAAM,8BAA8B;EAAA;AAEpD;AAEO,IAAM,6BAA6B,CACxC,MACA,UACAA,YACkB;AACd,MAAA,QAAQ,IAAI,WAAW;AAC3B,gBAAc,CAAC,WAAW;AAChB,YAAA;EAAA,CACT,EAAE,IAAI;AAED,QAAA,cAAA,oBAAkB,IAAsB;AACvC,EAAAA,QAAA,QAAQ,CAACA,UAAQ,QAAQ;AAC9B,UAAM,MAAM,YAAY,IAAIA,SAAO,MAAM;AACrC,QAAA,IAAS,KAAA,KAAK,GAAG;QAAA,aACJ,IAAIA,SAAO,QAAQ,CAAC,GAAG,CAAC;EAAA,CAC1C;AAEK,QAAA,SAAA,oBAAa,IAAY;AACtB,WAAA,QAAQ,CAACD,aAAY;AAC5B,0BAAsB,OAAOA,UAAS,aAAaC,SAAQ,MAAM;EAAA,CAClE;AAEM,SAAA,CAAC,GAAG,MAAM,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AACzC;;;ACtIA,IAAM,kBAAkB,CAAC,QAAgB,KAAK,KAAK,MAAM,CAAC,IAAI;AAC9D,IAAM,iBAAiB,CAAC,MAAc,aAClC,OAAO,KAAM,WAAW;AAEZ,SAAA,aACd,QACA,iBACA;AACA,QAAM,cAAc,gBAAgB,IAAI,CAAC,QAAQ,OAAO,GAAG,CAAC;AAEtD,QAAA,cAAc,OAAO,SAAS;AACpC,QAAM,WAAW,gBAAgB,IAAI,CAAC,QAAQ,cAAc,GAAG;AAE/D,QAAM,YAA2B,CAAA;AACjC,MAAI,SAAS,QAAQ;AACnB,UAAM,UAAU,gBAAgB,SAAS,GAAG,EAAE,CAAE;AAChD,UAAM,gBAAgB,KAAK,IAAI,GAAG,OAAO,IAAI;AAC7C,UAAM,WAAW,SAAS,UAAU,CAAC,MAAM,KAAK,aAAa;AAC7D,QAAI,WAAW,GAAG;AAChB,eAAS,QAAQ,GAAG,SAAS,OAAO,QAAQ,CAAC;AAC7C,kBAAY,QAAQ,GAAG,YAAY,OAAO,QAAQ,CAAC;IAAA;EACrD;AAGF,MAAI,YAAY;AACV,QAAA,WAAW,CAAC,YAA0B;AACtC,QAAA,cAAc,SAAS,QAAQ;AACjC,gBAAU,KAAK,OAAO;AACtB;IAAA;AAGI,UAAA,SAAS,SAAS,SAAS;AACjC,QAAI,WAAW,SAAS;AACpB,QAAA;AACF;IAAA;AAGI,UAAA,eAAe,gBAAgB,OAAO;AACtC,UAAA,cAAc,gBAAgB,MAAM;AAE1C,QAAI,YAAY,eAAe,QAAQ,cAAc,YAAY,GAAG;AAClE,gBAAU,KAAK,OAAO;AACtB;IAAA;AAGI,UAAA,UAAU,IAAI,UAAU;AAC9B,aAAS,OAAO;AAChB,aAAS,UAAU,CAAC;EAAA;AAEtB,WAAS,CAAC;AAEH,SAAA;IACL,QAAQ;IACR;IACA;EAAA;AAEJ;;;ACsBA,IAAM,iBAAiB,CAAI,MAAc,UAAa,aAAuB;AACvE,MAAA,YAAY,QAAQ,aAAa;AACnC,UAAM,IAAI;MACR,GAAG,IAAI,2BAA2B,QAAQ,aAAa,QAAQ;IAAA;AAErE;AAEa,IAAA,oBAAoB,CAC/B,eACA;EACE;EACA;EACA,GAAG;AACL,MACuB;;AACjB,QAAA,WAAW,YAAY,aAAa;AAE1C,QAAM,iBAAiB,SAAS,UAAU,QAAQ,SAAS,CAAC,IAAI,IAAI;AACpE,MAAI,kBAAkB,KAAY,OAAA,IAAI,MAAM,gCAAgC;AAEtE,QAAA,EAAE,YAAY,gBAAA,IAAoB;IACtC,YAAY,QAAQ;EAAA;AAEtB,MAAI,cAAc,KAAY,OAAA,IAAI,MAAM,mCAAmC;AAC5D,iBAAA,eAAe,YAAY,OAAO,YAAY;AAC7D,QAAM,WAAU,cAAS,QACtB,KAAK,CAAC,MAAM,EAAE,SAAS,QAAQ,MADlB,mBAEZ,UAAU,KAAK,CAAC,MAAM,EAAE,SAAS;AACrC,MAAI,WAAW,KAAY,OAAA,IAAI,MAAM,mCAAmC;AACxE,QAAM,EAAE,WAAW,UAAU,cAAc,YAAA,IAAgB;IACzD,QAAQ;EAAA,EACR,IAAI,QAAQ,KAAK;AACnB,MAAI,OAAO,aAAa,YAAY,OAAO,gBAAgB;AACnD,UAAA,IAAI,MAAM,qCAAqC;AACxC,iBAAA,aAAa,UAAU,OAAO,QAAQ;AACtC,iBAAA,gBAAgB,aAAa,OAAO,WAAW;AAE9D,QAAM,OAAkB;IACtB;IACA;IACA;IACA;IACA,cAAc;EAAA;AAEhB,QAAM,cAAc,IAAI;IACtB,SAAS,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,IAAI,KAAK,CAAC;EAAA;AAE5C,QAAA,kBAAkB,mBAAmB,UAAU,WAAW;AAC1D,QAAA,eAAe,CAAC,YAAkD;AAChE,UAAA;MACJ,KAAK,EAAE,KAAK,MAAM;IAAA,IAChB,YAAY,IAAI,OAAO;AAEvB,QAAA,QAAQ,YAAa,QAAO,MAAM;AAEtC,QAAK,QAAQ,eAAe,QAAQ,WAAY,MAAM,SAAS;AACvD,YAAA,IAAI,MAAM,oDAAoD;AAEtE,WAAO,MAAM,WAAW,IACpB,OACA,aAAa,QAAQ,UAAU,MAAM,CAAC,IAAI,MAAM,CAAC,EAAE,IAAI;EAAA;AAGvD,QAAA,aAAa,CAAC,YAA6B;AAC/C,UAAM,EAAE,IAAA,IAAQ,YAAY,IAAI,OAAO;AAEnC,QAAA,IAAI,QAAQ,YAAoB,QAAA,EAAE,KAAK,IAAI,MAAM,KAAK,OAAO,OAAU;AAEvE,QAAA,IAAI,QAAQ,WAAW;AACnB,YAAA,YAAY,aAAa,IAAI,KAAK;AAClC,YAAA,MAAM,gBAAgB,SAAiB;AAC7C,UAAI,CAAC,IAAW,OAAA,IAAI,MAAM,+BAA+B;AAClD,aAAA,EAAE,KAAK,OAAO,OAAU;IAAA;AAGjC,WAAO,gBAAgB,IAAI,OAAO,IAC9B,EAAE,KAAK,SAAS,OAAO,gBAAgB,IAAI,OAAO,EAAG,IACrD,EAAE,KAAK,QAAQ,OAAO,OAAU;EAAA;AAGtC,QAAM,YAA+B;IACnC,SAAS;IACT,WAAW,WAAW,SAAS,UAAU,OAAO;IAChD,QAAQ,WAAW,SAAS,UAAU,IAAI;IAC1C,aAAa,WAAW,SAAS,UAAU,SAAS;IACpD,kBAAkB,SAAS,UAAU,iBAAiB,IAAI,CAAC,QAAQ;MACjE,YAAY,GAAG;MACf,qBAAqB,WAAW,GAAG,IAAI;MACvC,sBAAsB,WAAW,GAAG,gBAAgB;IAAA,EACpD;EAAA;AAGJ,QAAMC,UAAS;IACb;IACA;IACA;IACA;EAAA;AAEF,QAAM,gBAAgBA,QAAO,IAAI,WAAW,GAAG;AAE3C,MAAA;AACJ,QAAM,cAAc,MAAyB;AAC3C,QAAI,SAAiB,QAAA;AAErB,QAAI,CAAC,cAAc,OAAQ,QAAQ,WAAW,CAAC,IAAI,WAAW,EAAE,EAAE,KAAK,CAAC,CAAC;AAEzE,eAAW,IAAI,MAAM,cAAc,SAAS,IAAI,CAAC;AAE7C,QAAA,iBAAiB,cAAc,SAAS;AAC5C,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ;AACxC,eAAS,iBAAiB,CAAC,IAAI,UAAU,cAAc,CAAC,CAAC;AAE3D,aAAS,IAAI,SAAS,SAAS,GAAG,IAAI,GAAG,KAAK;AAClC,gBAAA,IAAI,KAAK,CAAC,IAAI;QACtB,WAAW,CAAC,SAAS,CAAC,GAAG,SAAS,IAAI,CAAC,CAAC,CAAC;MAAA;AAGtC,WAAA;EAAA;AAGL,MAAA;AACJ,QAAM,SAAS,MAAM;AACnB,QAAI,SAAiB,QAAA;AACf,UAAA,iBAAiB,YAAY,EAAE,CAAC;AAEtC,UAAMC,UAAyB;MAC7B,KAAK;MACL,OAAO;QACL,yBAAyB;QACzB,uBAAuB,UAAU,kBAAkB,IAAI,SAAS,CAAC;QACjE,GAAG;MAAA;IACL;AAGF,WAAQ,WAAW,UAAU,eAAe,IAAIA,OAAM,CAAC;EAAA;AAGnD,QAAA,gBAAgB,CAAC,iBAA2B;AAC1C,UAAA,YAAY,aAAa,eAAe,YAAY;AAE1D,UAAMC,YAAW,YAAY;AACvB,UAAA,SAAS,UAAU,UAAU,IAAI,CAAC,QAAQA,UAAS,GAAG,CAAC;AAE7D,WAAO,WAAW;MAChB,QAAQ,IAAI,UAAU,OAAO,MAAM;MACnC,GAAG,UAAU;MACb,QAAQ,IAAI,UAAU,SAAS,MAAM;MACrC,GAAG,UAAU,SAAS,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,CAAC;MAC3C,QAAQ,IAAI,OAAO,MAAM;MACzB,GAAG;MACH,kBAAkB,IAAI,SAAS;MAC/B,UAAU,IAAI,IAAI;IAAA,CACnB;EAAA;AAGG,QAAA,8BAA8B,CAClC,qBACG;AACH,UAAM,WAA2B;MAC/B,UAAU;MACV,GAAG,UAAU,iBAAiB,IAAI,CAAC,MAAM,EAAE,mBAAmB;MAC9D,GAAG,UAAU,iBAAiB,IAAI,CAAC,MAAM,EAAE,oBAAoB;IAAA;AAE1D,WAAA;MACL,2BAA2B,kBAAkB,UAAUF,OAAM;IAAA;EAC/D;AAGF,QAAM,4BAA4B,CAChC,UACA,qBACA,yBACG;AACH,UAAM,QAAQ;MACZ,CAAC,UAAU,qBAAqB,oBAAoB,EAAE,IAAI,OAAO;IAAA;AAEnE,WAAO,4BAA4B,KAAK;EAAA;AAGpC,QAAA,uBAAuB,CAC3B,aACA,uBACG;AACC,QAAA,CAAA,EAAG,EAAE,SAAAG,UAAS,OAAA,GAAU,KAAK,IAAI,aAAa,WAAW;AAE7D,QAAIA,aAAY,UAAU;AAClB,YAAA,IAAI,MAAM,6BAA6B;AAE/C,UAAM,WAAsB,SACxB;MACE,UAAU;MACV,UAAU;MACV,GAAG,UAAU,iBAAiB,IAAI,CAAC,MAAM,EAAE,mBAAmB;MAC9D,UAAU;IAAA,IAEZ,CAAC,UAAU,MAAM;AAErB,QAAI,oBAAoB;AACtB,cAAQ,WAAW,CAAC,OAAO,QAAQ,kBAAkB,CAAC,CAAC;AAC9C,eAAA;QACP,GAAG,UAAU,iBAAiB,IAAI,CAAC,MAAM,EAAE,oBAAoB;MAAA;IACjE;AAGF,WAAO,cAAc,2BAA2B,OAAO,UAAUH,OAAM,CAAC;EAAA;AAGnE,SAAA;IACL;IACA;IACA;IACA;EAAA;AAEJ;",
  "names": ["typeDef", "typeRef", "lookup", "lookup", "digest", "hashTree", "version"]
}
