{
  "version": 3,
  "sources": ["../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/find-all-indexes.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/interlace.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/object-id.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/jotai/atom-family.ts", "../../.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/vanilla/internals.mjs", "../../.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/vanilla.mjs", "../../.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/react.mjs", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/jotai/atom-family-with-error-catcher.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/jotai/atom-with-observable.ts", "../../.pnpm/jotai-effect@2.0.2_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-effect/src/env.ts", "../../.pnpm/jotai-effect@2.0.2_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-effect/src/atomEffect.ts", "../../.pnpm/jotai-effect@2.0.2_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-effect/src/withAtomEffect.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/jotai/atom-with-observable-and-promise.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/jotai/atom-with-promise.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/maybe-promise-all.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/contexts/config.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-config.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/contexts/query-options.tsx", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-atom-value.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-pausable-atom-value.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/contexts/chain.tsx", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-query-options.ts", "../../.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/vanilla/utils.mjs", "../../.pnpm/jotai@2.12.5_@types+react@19.1.6_react@19.1.0/node_modules/jotai/esm/react/utils.mjs", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-query-refresher.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-render-effect.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-chain-id.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-client.ts", "../../.pnpm/jotai-derive@0.1.3_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-derive/dist/isPromise.js", "../../.pnpm/jotai-derive@0.1.3_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-derive/dist/soon.js", "../../.pnpm/jotai-derive@0.1.3_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-derive/dist/soonAll.js", "../../.pnpm/jotai-derive@0.1.3_jotai@2.12.5_@types+react@19.1.6_react@19.1.0_/node_modules/jotai-derive/dist/derive.js", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-typed-api.ts", "../../.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/utils/flat-head.ts", "../../.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/utils/stringify.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-query.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/components/query-renderer.tsx", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-local-store.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/utils/is-ssr.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-wallets.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-wallets-initializer.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/contexts/mutation.tsx", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/contexts/provider.tsx", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/contexts/signer.tsx", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-chain-spec-data.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-accounts.ts", "../../.pnpm/@reactive-dot+utils@0.10.0/node_modules/@reactive-dot/utils/src/big-int.ts", "../../.pnpm/@reactive-dot+utils@0.10.0/node_modules/@reactive-dot/utils/src/denominated-number.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-native-token-amount.ts", "../../.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/maths/spendable-balance.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-balance.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-block.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-mutation-effect.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-async-action.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-mutation.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-query-error-resetter.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-query-loader.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-signer.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-wallet-connector.ts", "../../.pnpm/@reactive-dot+react@0.40.4_@types+react@19.1.6_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2__react@19.1.0/node_modules/@reactive-dot/react/src/hooks/use-wallet-disconnector.ts"],
  "sourcesContent": ["export function findAllIndexes<T>(\n  array: T[],\n  predicate: (item: T) => boolean,\n): number[] {\n  return array.reduce((indexes, item, index) => {\n    if (predicate(item)) {\n      indexes.push(index);\n    }\n\n    return indexes;\n  }, [] as number[]);\n}\n", "/**\n * Given an array & a list of items and their indexes, interlace the items into the array at the specified indexes.\n *\n * @param array - The array to interlace the items into.\n * @param itemsWithIndexes - The items to interlace into the array, along with their indexes.\n * @returns The array with the items interlaced into it.\n */\nexport function interlace<T>(\n  array: readonly T[],\n  itemsWithIndexes: ReadonlyArray<readonly [T, number]>,\n): T[] {\n  const result = array.slice();\n\n  for (const [item, index] of itemsWithIndexes) {\n    result.splice(index, 0, item);\n  }\n\n  return result;\n}\n", "const objectIds = new WeakMap<Exclude<object, null>, string>();\n\nexport function objectId(object: unknown) {\n  if (object === null || typeof object !== \"object\") {\n    return object;\n  }\n\n  return (\n    objectIds.get(object) ??\n    objectIds.set(object, globalThis.crypto.randomUUID()).get(object)!\n  );\n}\n", "import { objectId } from \"../object-id.js\";\n\nexport type AtomFamily<TArguments extends unknown[], TAtomType> = {\n  (...args: TArguments): TAtomType;\n  delete: (...args: TArguments) => boolean;\n};\n\nexport function atomFamily<TArguments extends unknown[], TAtomType>(\n  initializeAtom: (...args: TArguments) => TAtomType,\n  getKey?: (...args: TArguments) => unknown,\n): AtomFamily<TArguments, TAtomType> {\n  const empty = Symbol(\"empty\");\n  const atoms = new Map<unknown, TAtomType>();\n\n  const _getKey =\n    getKey ??\n    ((...args: TArguments) =>\n      args.length === 0\n        ? empty\n        : args.length === 1\n          ? args[0]\n          : args.map(objectId).join());\n\n  return Object.assign(\n    (...args: TArguments) => {\n      const key = _getKey(...args);\n\n      return (\n        atoms.get(key) ?? atoms.set(key, initializeAtom(...args)).get(key)!\n      );\n    },\n    { delete: (...args: TArguments) => atoms.delete(_getKey(...args)) },\n  );\n}\n", "const isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst promiseStateMap = /* @__PURE__ */ new WeakMap();\nconst isPendingPromise = (value) => {\n  var _a;\n  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);\n};\nconst abortPromise = (promise) => {\n  const promiseState = promiseStateMap.get(promise);\n  if (promiseState == null ? void 0 : promiseState[0]) {\n    promiseState[0] = false;\n    promiseState[1].forEach((fn) => fn());\n  }\n};\nconst registerAbortHandler = (promise, abortHandler) => {\n  let promiseState = promiseStateMap.get(promise);\n  if (!promiseState) {\n    promiseState = [true, /* @__PURE__ */ new Set()];\n    promiseStateMap.set(promise, promiseState);\n    const settle = () => {\n      promiseState[0] = false;\n    };\n    promise.then(settle, settle);\n  }\n  promiseState[1].add(abortHandler);\n};\nconst isPromiseLike = (p) => typeof (p == null ? void 0 : p.then) === \"function\";\nconst addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst setAtomStateValueOrPromise = (atom, valueOrPromise, ensureAtomState) => {\n  const atomState = ensureAtomState(atom);\n  const hasPrevValue = \"v\" in atomState;\n  const prevValue = atomState.v;\n  if (isPromiseLike(valueOrPromise)) {\n    for (const a of atomState.d.keys()) {\n      addPendingPromiseToDependency(atom, valueOrPromise, ensureAtomState(a));\n    }\n  }\n  atomState.v = valueOrPromise;\n  delete atomState.e;\n  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n    ++atomState.n;\n    if (isPromiseLike(prevValue)) {\n      abortPromise(prevValue);\n    }\n  }\n};\nconst getMountedOrPendingDependents = (atom, atomState, mountedMap) => {\n  var _a;\n  const dependents = /* @__PURE__ */ new Set();\n  for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []) {\n    if (mountedMap.has(a)) {\n      dependents.add(a);\n    }\n  }\n  for (const atomWithPendingPromise of atomState.p) {\n    dependents.add(atomWithPendingPromise);\n  }\n  return dependents;\n};\nconst createStoreHook = () => {\n  const callbacks = /* @__PURE__ */ new Set();\n  const notify = () => {\n    callbacks.forEach((fn) => fn());\n  };\n  notify.add = (fn) => {\n    callbacks.add(fn);\n    return () => {\n      callbacks.delete(fn);\n    };\n  };\n  return notify;\n};\nconst createStoreHookForAtoms = () => {\n  const all = {};\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const notify = (atom) => {\n    var _a, _b;\n    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom));\n    (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn) => fn());\n  };\n  notify.add = (atom, fn) => {\n    const key = atom || all;\n    const fns = (callbacks.has(key) ? callbacks : callbacks.set(key, /* @__PURE__ */ new Set())).get(key);\n    fns.add(fn);\n    return () => {\n      fns == null ? void 0 : fns.delete(fn);\n      if (!fns.size) {\n        callbacks.delete(key);\n      }\n    };\n  };\n  return notify;\n};\nconst initializeStoreHooks = (storeHooks) => {\n  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\n  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\n  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\n  storeHooks.f || (storeHooks.f = createStoreHook());\n  return storeHooks;\n};\nconst BUILDING_BLOCKS = Symbol();\nconst getBuildingBlocks = (store) => store[BUILDING_BLOCKS];\nconst buildStore = (atomStateMap = /* @__PURE__ */ new WeakMap(), mountedMap = /* @__PURE__ */ new WeakMap(), invalidatedAtoms = /* @__PURE__ */ new WeakMap(), changedAtoms = /* @__PURE__ */ new Set(), mountCallbacks = /* @__PURE__ */ new Set(), unmountCallbacks = /* @__PURE__ */ new Set(), storeHooks = {}, atomRead = (atom, ...params) => atom.read(...params), atomWrite = (atom, ...params) => atom.write(...params), atomOnInit = (atom, store) => {\n  var _a;\n  return (_a = atom.unstable_onInit) == null ? void 0 : _a.call(atom, store);\n}, atomOnMount = (atom, setAtom) => {\n  var _a;\n  return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\n}, ...buildingBlockFunctions) => {\n  const ensureAtomState = buildingBlockFunctions[0] || ((atom) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\n      throw new Error(\"Atom is undefined or null\");\n    }\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      atomStateMap.set(atom, atomState);\n      atomOnInit == null ? void 0 : atomOnInit(atom, store);\n    }\n    return atomState;\n  });\n  const flushCallbacks = buildingBlockFunctions[1] || (() => {\n    const errors = [];\n    const call = (fn) => {\n      try {\n        fn();\n      } catch (e) {\n        errors.push(e);\n      }\n    };\n    do {\n      if (storeHooks.f) {\n        call(storeHooks.f);\n      }\n      const callbacks = /* @__PURE__ */ new Set();\n      const add = callbacks.add.bind(callbacks);\n      changedAtoms.forEach((atom) => {\n        var _a;\n        return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\n      });\n      changedAtoms.clear();\n      unmountCallbacks.forEach(add);\n      unmountCallbacks.clear();\n      mountCallbacks.forEach(add);\n      mountCallbacks.clear();\n      callbacks.forEach(call);\n      if (changedAtoms.size) {\n        recomputeInvalidatedAtoms();\n      }\n    } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n    if (errors.length) {\n      throw new AggregateError(errors);\n    }\n  });\n  const recomputeInvalidatedAtoms = buildingBlockFunctions[2] || (() => {\n    const topSortedReversed = [];\n    const visiting = /* @__PURE__ */ new WeakSet();\n    const visited = /* @__PURE__ */ new WeakSet();\n    const stack = Array.from(changedAtoms);\n    while (stack.length) {\n      const a = stack[stack.length - 1];\n      const aState = ensureAtomState(a);\n      if (visited.has(a)) {\n        stack.pop();\n        continue;\n      }\n      if (visiting.has(a)) {\n        if (invalidatedAtoms.get(a) === aState.n) {\n          topSortedReversed.push([a, aState]);\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\n          throw new Error(\"[Bug] invalidated atom exists\");\n        }\n        visited.add(a);\n        stack.pop();\n        continue;\n      }\n      visiting.add(a);\n      for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n        if (!visiting.has(d)) {\n          stack.push(d);\n        }\n      }\n    }\n    for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n      const [a, aState] = topSortedReversed[i];\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(a);\n        mountDependencies(a);\n      }\n      invalidatedAtoms.delete(a);\n    }\n  });\n  const readAtomState = buildingBlockFunctions[3] || ((atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    if (isAtomStateInitialized(atomState)) {\n      if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(a).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const mountDependenciesIfAsync = () => {\n      if (mountedMap.has(atom)) {\n        mountDependencies(atom);\n        recomputeInvalidatedAtoms();\n        flushCallbacks();\n      }\n    };\n    const getter = (a) => {\n      var _a2;\n      if (isSelfAtom(atom, a)) {\n        const aState2 = ensureAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, a.init, ensureAtomState);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(a);\n      try {\n        return returnAtomValue(aState);\n      } finally {\n        atomState.d.set(a, aState.n);\n        if (isPendingPromise(atomState.v)) {\n          addPendingPromiseToDependency(atom, atomState.v, aState);\n        }\n        (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\n        if (!isSync) {\n          mountDependenciesIfAsync();\n        }\n      }\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              try {\n                return writeAtomState(atom, ...args);\n              } finally {\n                recomputeInvalidatedAtoms();\n                flushCallbacks();\n              }\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    const prevEpochNumber = atomState.n;\n    try {\n      const valueOrPromise = atomRead(atom, getter, options);\n      setAtomStateValueOrPromise(atom, valueOrPromise, ensureAtomState);\n      if (isPromiseLike(valueOrPromise)) {\n        registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n        valueOrPromise.then(\n          mountDependenciesIfAsync,\n          mountDependenciesIfAsync\n        );\n      }\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n      if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\n        invalidatedAtoms.set(atom, atomState.n);\n        changedAtoms.add(atom);\n        (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, atom);\n      }\n    }\n  });\n  const invalidateDependents = buildingBlockFunctions[4] || ((atom) => {\n    const stack = [atom];\n    while (stack.length) {\n      const a = stack.pop();\n      const aState = ensureAtomState(a);\n      for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n        const dState = ensureAtomState(d);\n        invalidatedAtoms.set(d, dState.n);\n        stack.push(d);\n      }\n    }\n  });\n  const writeAtomState = buildingBlockFunctions[5] || ((atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      var _a;\n      const aState = ensureAtomState(a);\n      try {\n        if (isSelfAtom(atom, a)) {\n          if (!hasInitialValue(a)) {\n            throw new Error(\"atom not writable\");\n          }\n          const prevEpochNumber = aState.n;\n          const v = args2[0];\n          setAtomStateValueOrPromise(a, v, ensureAtomState);\n          mountDependencies(a);\n          if (prevEpochNumber !== aState.n) {\n            changedAtoms.add(a);\n            (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n            invalidateDependents(a);\n          }\n          return void 0;\n        } else {\n          return writeAtomState(a, ...args2);\n        }\n      } finally {\n        if (!isSync) {\n          recomputeInvalidatedAtoms();\n          flushCallbacks();\n        }\n      }\n    };\n    try {\n      return atomWrite(atom, getter, setter, ...args);\n    } finally {\n      isSync = false;\n    }\n  });\n  const mountDependencies = buildingBlockFunctions[6] || ((atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    const mounted = mountedMap.get(atom);\n    if (mounted && !isPendingPromise(atomState.v)) {\n      for (const [a, n] of atomState.d) {\n        if (!mounted.d.has(a)) {\n          const aState = ensureAtomState(a);\n          const aMounted = mountAtom(a);\n          aMounted.t.add(atom);\n          mounted.d.add(a);\n          if (n !== aState.n) {\n            changedAtoms.add(a);\n            (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n            invalidateDependents(a);\n          }\n        }\n      }\n      for (const a of mounted.d || []) {\n        if (!atomState.d.has(a)) {\n          mounted.d.delete(a);\n          const aMounted = unmountAtom(a);\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n      }\n    }\n  });\n  const mountAtom = buildingBlockFunctions[7] || ((atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      readAtomState(atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(a);\n        aMounted.t.add(atom);\n      }\n      mounted = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      mountedMap.set(atom, mounted);\n      (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\n      if (isActuallyWritableAtom(atom)) {\n        const processOnMount = () => {\n          let isSync = true;\n          const setAtom = (...args) => {\n            try {\n              return writeAtomState(atom, ...args);\n            } finally {\n              if (!isSync) {\n                recomputeInvalidatedAtoms();\n                flushCallbacks();\n              }\n            }\n          };\n          try {\n            const onUnmount = atomOnMount(atom, setAtom);\n            if (onUnmount) {\n              mounted.u = () => {\n                isSync = true;\n                try {\n                  onUnmount();\n                } finally {\n                  isSync = false;\n                }\n              };\n            }\n          } finally {\n            isSync = false;\n          }\n        };\n        mountCallbacks.add(processOnMount);\n      }\n    }\n    return mounted;\n  });\n  const unmountAtom = buildingBlockFunctions[8] || ((atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    let mounted = mountedMap.get(atom);\n    if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {\n      var _a2;\n      return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom);\n    })) {\n      if (mounted.u) {\n        unmountCallbacks.add(mounted.u);\n      }\n      mounted = void 0;\n      mountedMap.delete(atom);\n      (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n      return void 0;\n    }\n    return mounted;\n  });\n  const buildingBlocks = [\n    // store state\n    atomStateMap,\n    mountedMap,\n    invalidatedAtoms,\n    changedAtoms,\n    mountCallbacks,\n    unmountCallbacks,\n    storeHooks,\n    // atom interceptors\n    atomRead,\n    atomWrite,\n    atomOnInit,\n    atomOnMount,\n    // building-block functions\n    ensureAtomState,\n    flushCallbacks,\n    recomputeInvalidatedAtoms,\n    readAtomState,\n    invalidateDependents,\n    writeAtomState,\n    mountDependencies,\n    mountAtom,\n    unmountAtom\n  ];\n  const store = {\n    get: (atom) => returnAtomValue(readAtomState(atom)),\n    set: (atom, ...args) => {\n      try {\n        return writeAtomState(atom, ...args);\n      } finally {\n        recomputeInvalidatedAtoms();\n        flushCallbacks();\n      }\n    },\n    sub: (atom, listener) => {\n      const mounted = mountAtom(atom);\n      const listeners = mounted.l;\n      listeners.add(listener);\n      flushCallbacks();\n      return () => {\n        listeners.delete(listener);\n        unmountAtom(atom);\n        flushCallbacks();\n      };\n    }\n  };\n  Object.defineProperty(store, BUILDING_BLOCKS, { value: buildingBlocks });\n  return store;\n};\nconst INTERNAL_buildStoreRev1 = buildStore;\nconst INTERNAL_getBuildingBlocksRev1 = getBuildingBlocks;\nconst INTERNAL_initializeStoreHooks = initializeStoreHooks;\nconst INTERNAL_isSelfAtom = isSelfAtom;\nconst INTERNAL_hasInitialValue = hasInitialValue;\nconst INTERNAL_isActuallyWritableAtom = isActuallyWritableAtom;\nconst INTERNAL_isAtomStateInitialized = isAtomStateInitialized;\nconst INTERNAL_returnAtomValue = returnAtomValue;\nconst INTERNAL_promiseStateMap = promiseStateMap;\nconst INTERNAL_isPendingPromise = isPendingPromise;\nconst INTERNAL_abortPromise = abortPromise;\nconst INTERNAL_registerAbortHandler = registerAbortHandler;\nconst INTERNAL_isPromiseLike = isPromiseLike;\nconst INTERNAL_addPendingPromiseToDependency = addPendingPromiseToDependency;\nconst INTERNAL_setAtomStateValueOrPromise = setAtomStateValueOrPromise;\nconst INTERNAL_getMountedOrPendingDependents = getMountedOrPendingDependents;\n\nexport { INTERNAL_abortPromise, INTERNAL_addPendingPromiseToDependency, INTERNAL_buildStoreRev1, INTERNAL_getBuildingBlocksRev1, INTERNAL_getMountedOrPendingDependents, INTERNAL_hasInitialValue, INTERNAL_initializeStoreHooks, INTERNAL_isActuallyWritableAtom, INTERNAL_isAtomStateInitialized, INTERNAL_isPendingPromise, INTERNAL_isPromiseLike, INTERNAL_isSelfAtom, INTERNAL_promiseStateMap, INTERNAL_registerAbortHandler, INTERNAL_returnAtomValue, INTERNAL_setAtomStateValueOrPromise };\n", "import { INTERNAL_buildStoreRev1, INTERNAL_initializeStoreHooks } from 'jotai/vanilla/internals';\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst createDevStoreRev4 = () => {\n  let inRestoreAtom = 0;\n  const storeHooks = INTERNAL_initializeStoreHooks({});\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedAtoms = /* @__PURE__ */ new WeakMap();\n  const store = INTERNAL_buildStoreRev1(\n    atomStateMap,\n    mountedAtoms,\n    void 0,\n    void 0,\n    void 0,\n    void 0,\n    storeHooks,\n    void 0,\n    (atom, get, set, ...args) => {\n      if (inRestoreAtom) {\n        return set(atom, ...args);\n      }\n      return atom.write(get, set, ...args);\n    }\n  );\n  const debugMountedAtoms = /* @__PURE__ */ new Set();\n  storeHooks.m.add(void 0, (atom) => {\n    debugMountedAtoms.add(atom);\n    const atomState = atomStateMap.get(atom);\n    atomState.m = mountedAtoms.get(atom);\n  });\n  storeHooks.u.add(void 0, (atom) => {\n    debugMountedAtoms.delete(atom);\n    const atomState = atomStateMap.get(atom);\n    delete atomState.m;\n  });\n  const devStore = {\n    // store dev methods (these are tentative and subject to change without notice)\n    dev4_get_internal_weak_map: () => {\n      console.log(\"Deprecated: Use devstore from the devtools library\");\n      return atomStateMap;\n    },\n    dev4_get_mounted_atoms: () => debugMountedAtoms,\n    dev4_restore_atoms: (values) => {\n      const restoreAtom = {\n        read: () => null,\n        write: (_get, set) => {\n          ++inRestoreAtom;\n          try {\n            for (const [atom, value] of values) {\n              if (\"init\" in atom) {\n                set(atom, value);\n              }\n            }\n          } finally {\n            --inRestoreAtom;\n          }\n        }\n      };\n      store.set(restoreAtom);\n    }\n  };\n  return Object.assign(store, devStore);\n};\nlet overiddenCreateStore;\nfunction INTERNAL_overrideCreateStore(fn) {\n  overiddenCreateStore = fn(overiddenCreateStore);\n}\nfunction createStore() {\n  if (overiddenCreateStore) {\n    return overiddenCreateStore();\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return createDevStoreRev4();\n  }\n  return INTERNAL_buildStoreRev1();\n}\nlet defaultStore;\nfunction getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n}\n\nexport { INTERNAL_overrideCreateStore, atom, createStore, getDefaultStore };\n", "'use client';\nimport React, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\nimport { INTERNAL_registerAbortHandler } from 'jotai/vanilla/internals';\n\nconst StoreContext = createContext(\n  void 0\n);\nfunction useStore(options) {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n}\nfunction Provider({\n  children,\n  store\n}) {\n  const storeRef = useRef(void 0);\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseStatus = (promise) => {\n  if (!promise.status) {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n  }\n};\nconst use = React.use || // A shim for older React versions\n((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseStatus(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, getValue) => {\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const onAbort = () => {\n        try {\n          const nextValue = getValue();\n          if (isPromiseLike(nextValue)) {\n            continuablePromiseMap.set(nextValue, continuablePromise);\n            curr = nextValue;\n            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n            INTERNAL_registerAbortHandler(nextValue, onAbort);\n          } else {\n            resolve(nextValue);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      INTERNAL_registerAbortHandler(promise, onAbort);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const { delay, unstable_promiseStatus: promiseStatus = !React.use } = options || {};\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (promiseStatus) {\n        try {\n          const value2 = store.get(atom);\n          if (isPromiseLike(value2)) {\n            attachPromiseStatus(\n              createContinuablePromise(value2, () => store.get(atom))\n            );\n          }\n        } catch (e) {\n        }\n      }\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay, promiseStatus]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(value, () => store.get(atom));\n    if (promiseStatus) {\n      attachPromiseStatus(promise);\n    }\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n", "import { type AtomFamily, atomFamily } from \"./atom-family.js\";\nimport { type Atom, atom, type Getter, type WritableAtom } from \"jotai\";\n\nexport const atomFamilyErrorsAtom = atom(\n  () =>\n    new Set<{\n      atomFamily: AtomFamily<\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        any[],\n        unknown\n      >;\n      args: unknown;\n    }>(),\n);\n\nexport function atomFamilyWithErrorCatcher<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  TArguments extends any[],\n  TCached,\n>(\n  initializeAtom: (\n    withErrorCatcher: <TAtomType extends Atom<unknown>>(\n      atom: TAtomType,\n    ) => TAtomType,\n    ...args: TArguments\n  ) => TCached,\n  getKey?: (...args: TArguments) => unknown,\n): AtomFamily<TArguments, TCached> {\n  const baseAtomFamily = atomFamily((...args: TArguments) => {\n    const withErrorCatcher = <TAtomType extends Atom<unknown>>(\n      childAtom: TAtomType,\n    ) => {\n      const read = (get: Getter) => {\n        try {\n          const value = get(childAtom);\n\n          if (!(value instanceof Promise)) {\n            return value;\n          }\n\n          return value.catch((error) => {\n            get(atomFamilyErrorsAtom).add({\n              atomFamily: baseAtomFamily,\n              args,\n            });\n\n            throw error;\n          });\n        } catch (error) {\n          get(atomFamilyErrorsAtom).add({\n            atomFamily: baseAtomFamily,\n            args,\n          });\n\n          throw error;\n        }\n      };\n\n      return \"write\" in childAtom\n        ? atom(read, (_, set, ...args: unknown[]) =>\n            set(\n              childAtom as unknown as WritableAtom<unknown, unknown[], unknown>,\n              ...args,\n            ),\n          )\n        : atom(read);\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return initializeAtom(withErrorCatcher as any, ...args);\n  }, getKey);\n\n  return baseAtomFamily;\n}\n", "import { atom, type Getter } from \"jotai\";\nimport { type Observable, firstValueFrom } from \"rxjs\";\n\ntype Data<T> = { value: T } | { error: unknown };\n\nexport const empty = Symbol(\"empty\");\n\nexport function atomWithObservable<TValue>(\n  getObservable: (get: Getter) => Observable<TValue>,\n  options?: {\n    initialValue?: TValue | ((get: Getter) => TValue | typeof empty);\n  },\n) {\n  const observableAtom = atom((get) => {\n    const observable = getObservable(get);\n\n    const initialValue = (() => {\n      if (options === undefined) {\n        return empty;\n      }\n\n      if (!(\"initialValue\" in options)) {\n        return empty;\n      }\n\n      if (options.initialValue instanceof Function) {\n        return options.initialValue(get);\n      }\n\n      return options.initialValue;\n    })();\n\n    const dataAtom = atom<Data<TValue | Promise<TValue>>>(\n      initialValue !== empty\n        ? {\n            value: initialValue,\n          }\n        : { value: firstValueFrom(observable) },\n    );\n\n    dataAtom.onMount = (update) => {\n      const subscription = observable.subscribe({\n        next: (value) => update({ value }),\n        error: (error) => update({ error }),\n      });\n\n      return () => {\n        subscription.unsubscribe();\n      };\n    };\n\n    return dataAtom;\n  });\n\n  return atom((get) => {\n    const data = get(get(observableAtom));\n\n    if (\"error\" in data) {\n      throw data.error;\n    }\n\n    return data.value;\n  });\n}\n", "export function isDev(): boolean {\n  return Boolean(\n    typeof process !== 'undefined' &&\n      process.env?.NODE_ENV &&\n      process.env.NODE_ENV !== 'production'\n  )\n}\n", "import type { Atom, Getter, Setter, WritableAtom } from 'jotai/vanilla'\nimport { atom } from 'jotai/vanilla'\nimport type {\n  INTERNAL_AtomState as AtomState,\n  INTERNAL_buildStoreRev1 as buildStore,\n} from 'jotai/vanilla/internals'\nimport {\n  INTERNAL_getBuildingBlocksRev1 as INTERNAL_getBuildingBlocks,\n  INTERNAL_hasInitialValue as hasInitialValue,\n  INTERNAL_initializeStoreHooks as initializeStoreHooks,\n  INTERNAL_isAtomStateInitialized as isAtomStateInitialized,\n  INTERNAL_isSelfAtom as isSelfAtom,\n  INTERNAL_returnAtomValue as returnAtomValue,\n  INTERNAL_setAtomStateValueOrPromise as setAtomStateValueOrPromise,\n} from 'jotai/vanilla/internals'\nimport { isDev } from './env'\n\nconst getBuildingBlocks = (store: Store) => {\n  const buildingBlocks = INTERNAL_getBuildingBlocks(store)\n  return [\n    buildingBlocks[1], // mountedAtoms\n    buildingBlocks[3], // changedAtoms\n    initializeStoreHooks(buildingBlocks[6]), // storeHooks\n    buildingBlocks[11], // ensureAtomState\n    buildingBlocks[14], // readAtomState\n    buildingBlocks[16], // writeAtomState\n    buildingBlocks[17], // mountDependencies\n    buildingBlocks[15], // invalidateDependents\n    buildingBlocks[13], // recomputeInvalidatedAtoms\n    buildingBlocks[12], // flushCallbacks\n  ] as const\n}\n\ntype Store = ReturnType<typeof buildStore>\n\ntype AnyAtom = Atom<unknown>\n\ntype GetterWithPeek = Getter & { peek: Getter }\n\ntype SetterWithRecurse = Setter & { recurse: Setter }\n\ntype Cleanup = () => void\n\nexport type Effect = (\n  get: GetterWithPeek,\n  set: SetterWithRecurse\n) => void | Cleanup\n\ntype Ref = [\n  dependencies: Set<AnyAtom>,\n  atomState: AtomState<void>,\n  mountedAtoms: Map<AnyAtom, AtomState<void>>,\n]\n\nexport function atomEffect(effect: Effect): Atom<void> & { effect: Effect } {\n  const refAtom = atom<Partial<Ref>>(() => [])\n\n  const effectAtom = atom(function effectAtomRead(get) {\n    const [dependencies, atomState, mountedAtoms] = get(refAtom)\n    if (mountedAtoms!.has(effectAtom)) {\n      dependencies!.forEach(get)\n      ++atomState!.n\n    }\n  }) as Atom<void> & { effect: Effect }\n\n  effectAtom.effect = effect\n\n  effectAtom.unstable_onInit = (store) => {\n    const deps = new Set<AnyAtom>()\n    let inProgress = 0\n    let isRecursing = false\n    let hasChanged = false\n    let fromCleanup = false\n    let runCleanup: (() => void) | undefined\n\n    function runEffect() {\n      if (inProgress) {\n        return\n      }\n      deps.clear()\n      let isSync = true\n\n      const getter: GetterWithPeek = (a) => {\n        if (fromCleanup) {\n          return store.get(a)\n        }\n        if (isSelfAtom(effectAtom, a)) {\n          const aState = ensureAtomState(a)\n          if (!isAtomStateInitialized(aState)) {\n            if (hasInitialValue(a)) {\n              setAtomStateValueOrPromise(a, a.init, ensureAtomState)\n            } else {\n              // NOTE invalid derived atoms can reach here\n              throw new Error('no atom init')\n            }\n          }\n          return returnAtomValue(aState)\n        }\n        // a !== atom\n        const aState = readAtomState(a)\n        try {\n          return returnAtomValue(aState)\n        } finally {\n          atomState.d.set(a, aState.n)\n          mountedAtoms.get(a)?.t.add(effectAtom)\n          if (isSync) {\n            deps.add(a)\n          } else {\n            if (mountedAtoms.has(a)) {\n              mountDependencies(effectAtom)\n              recomputeInvalidatedAtoms()\n              flushCallbacks()\n            }\n          }\n        }\n      }\n\n      getter.peek = store.get\n\n      const setter: SetterWithRecurse = <V, As extends unknown[], R>(\n        a: WritableAtom<V, As, R>,\n        ...args: As\n      ) => {\n        const aState = ensureAtomState(a)\n        try {\n          ++inProgress\n          if (isSelfAtom(effectAtom, a)) {\n            if (!hasInitialValue(a)) {\n              // NOTE technically possible but restricted as it may cause bugs\n              throw new Error('atom not writable')\n            }\n            const prevEpochNumber = aState.n\n            const v = args[0] as V\n            setAtomStateValueOrPromise(a, v, ensureAtomState)\n            mountDependencies(a)\n            if (prevEpochNumber !== aState.n) {\n              changedAtoms.add(a)\n              storeHooks.c?.(a)\n              invalidateDependents(a)\n            }\n            return undefined as R\n          } else {\n            return writeAtomState(a, ...args)\n          }\n        } finally {\n          if (!isSync) {\n            recomputeInvalidatedAtoms()\n            flushCallbacks()\n          }\n          --inProgress\n        }\n      }\n\n      setter.recurse = (a, ...args) => {\n        if (fromCleanup) {\n          if (isDev()) {\n            throw new Error('set.recurse is not allowed in cleanup')\n          }\n          return undefined as any\n        }\n        try {\n          isRecursing = true\n          mountDependencies(effectAtom)\n          return setter(a, ...args)\n        } finally {\n          recomputeInvalidatedAtoms()\n          isRecursing = false\n          if (hasChanged) {\n            hasChanged = false\n            runEffect()\n          }\n        }\n      }\n\n      try {\n        runCleanup?.()\n        const cleanup = effectAtom.effect(getter, setter)\n        if (typeof cleanup !== 'function') {\n          return\n        }\n        runCleanup = () => {\n          if (inProgress) {\n            return\n          }\n          try {\n            isSync = true\n            fromCleanup = true\n            return cleanup()\n          } finally {\n            isSync = false\n            fromCleanup = false\n            runCleanup = undefined\n          }\n        }\n      } finally {\n        isSync = false\n        deps.forEach((depAtom) => {\n          atomState.d.set(depAtom, ensureAtomState(depAtom).n)\n        })\n        mountDependencies(effectAtom)\n        recomputeInvalidatedAtoms()\n      }\n    }\n\n    const [\n      mountedAtoms,\n      changedAtoms,\n      storeHooks,\n      ensureAtomState,\n      readAtomState,\n      writeAtomState,\n      mountDependencies,\n      invalidateDependents,\n      recomputeInvalidatedAtoms,\n      flushCallbacks,\n    ] = getBuildingBlocks(store)\n    const atomEffectChannel = ensureAtomEffectChannel(store)\n    const atomState = ensureAtomState(effectAtom)\n    // initialize atomState\n    atomState.v = undefined\n\n    Object.assign(store.get(refAtom), [deps, atomState, mountedAtoms])\n\n    storeHooks.m.add(effectAtom, function atomOnMount() {\n      // mounted\n      atomEffectChannel.add(runEffect)\n      if (runCleanup) {\n        atomEffectChannel.delete(runCleanup)\n      }\n    })\n\n    storeHooks.u.add(effectAtom, function atomOnUnmount() {\n      // unmounted\n      atomEffectChannel.delete(runEffect)\n      if (runCleanup) {\n        atomEffectChannel.add(runCleanup)\n      }\n    })\n\n    storeHooks.c.add(effectAtom, function atomOnUpdate() {\n      // changed\n      if (isRecursing) {\n        hasChanged = true\n      } else {\n        atomEffectChannel.add(runEffect)\n      }\n    })\n  }\n\n  if (isDev()) {\n    Object.defineProperty(refAtom, 'debugLabel', {\n      get: () =>\n        effectAtom.debugLabel ? `${effectAtom.debugLabel}:ref` : undefined,\n    })\n    refAtom.debugPrivate = true\n  }\n\n  return effectAtom\n}\n\ntype AtomEffectChannel = Set<() => void>\nconst atomEffectChannelStoreMap = new WeakMap<Store, AtomEffectChannel>()\n\nfunction ensureAtomEffectChannel(store: Store): AtomEffectChannel {\n  const storeHooks = getBuildingBlocks(store)[2]\n  let atomEffectChannel = atomEffectChannelStoreMap.get(store)\n  if (!atomEffectChannel) {\n    atomEffectChannel = new Set()\n    atomEffectChannelStoreMap.set(store, atomEffectChannel)\n    storeHooks.f.add(function storeOnFlush() {\n      // flush\n      for (const fn of atomEffectChannel!) {\n        atomEffectChannel!.delete(fn)\n        fn()\n      }\n    })\n  }\n  return atomEffectChannel\n}\n", "import type { Atom } from 'jotai/vanilla'\nimport type { Effect } from './atomEffect'\nimport { atomEffect } from './atomEffect'\nimport { isDev } from './env'\n\nexport function withAtomEffect<T extends Atom<unknown>>(\n  targetAtom: T,\n  effect: Effect\n): T & { effect: Effect } {\n  const effectAtom = atomEffect((get, set) => {\n    const getter = ((a) =>\n      a === targetWithEffect ? get(targetAtom) : get(a)) as typeof get\n    getter.peek = get.peek\n    return targetWithEffect.effect(getter, set)\n  })\n  if (isDev()) {\n    Object.defineProperty(effectAtom, 'debugLabel', {\n      get: () => `${targetWithEffect.debugLabel ?? 'atomWithEffect'}:effect`,\n    })\n    effectAtom.debugPrivate = true\n  }\n  const descriptors = Object.getOwnPropertyDescriptors(\n    targetAtom as T & { effect: Effect }\n  )\n  descriptors.read.value = (get) => {\n    try {\n      return get(targetAtom)\n    } finally {\n      get(effectAtom)\n    }\n  }\n  if ('write' in targetAtom && typeof targetAtom.write === 'function') {\n    descriptors.write!.value = targetAtom.write.bind(targetAtom)\n    delete descriptors.onMount\n  }\n  // avoid reading `init` to preserve lazy initialization\n  const targetPrototype = Object.getPrototypeOf(targetAtom)\n  const targetWithEffect = Object.create(targetPrototype, descriptors)\n  targetWithEffect.effect = effect\n  return targetWithEffect\n}\n", "import {\n  atomWithObservable,\n  empty as emptyInitial,\n} from \"./atom-with-observable.js\";\nimport { atom, type Atom, type Getter } from \"jotai\";\nimport { withAtomEffect } from \"jotai-effect\";\nimport { firstValueFrom, shareReplay, type Observable } from \"rxjs\";\n\nconst empty = Symbol(\"empty\");\n\ntype Data<T> = { value: T | Promise<T> | typeof empty } | { error: unknown };\n\nexport function atomWithObservableAndPromise<\n  TValue,\n  TAtomEnhancer extends <TAtomType extends Atom<unknown>>(\n    atomType: TAtomType,\n  ) => TAtomType,\n>(\n  getObservable: (get: Getter) => Observable<TValue>,\n  enhanceAtom: TAtomEnhancer = ((atomCreator) => atomCreator) as TAtomEnhancer,\n): {\n  observableAtom: Atom<TValue | Promise<TValue>>;\n  promiseAtom: Atom<TValue | Promise<TValue>>;\n} {\n  const sourceObservable = atom((get) =>\n    getObservable(get).pipe(shareReplay({ bufferSize: 1, refCount: true })),\n  );\n\n  const dataAtom = atom<Data<TValue>>({ value: empty });\n\n  const initialDataAtom = atom<{ value: TValue | typeof empty }>({\n    value: empty,\n  });\n\n  const observableAtom = withAtomEffect(\n    enhanceAtom(\n      atomWithObservable((get) => get(sourceObservable), {\n        initialValue: (get) => {\n          const value = get(initialDataAtom).value;\n          return value === empty ? emptyInitial : value;\n        },\n      }),\n    ),\n    (get, set) => {\n      try {\n        set(dataAtom, { value: get(observableAtom) });\n      } catch (error) {\n        set(dataAtom, { error });\n      }\n    },\n  );\n\n  const promiseAtom = enhanceAtom(\n    atom((get) => {\n      const data = get(dataAtom);\n\n      if (\"error\" in data) {\n        throw data.error;\n      }\n\n      if (data.value !== empty) {\n        return data.value;\n      }\n\n      const initialData = get(initialDataAtom);\n\n      return firstValueFrom(get(sourceObservable)).then((value) => {\n        initialData.value = value;\n        return value;\n      });\n    }),\n  );\n\n  return { promiseAtom, observableAtom };\n}\n", "import { atom, type Getter } from \"jotai\";\nimport { startTransition } from \"react\";\n\ntype Data<T> = { value: T } | { error: unknown };\n\nexport function atomWithPromise<TValue>(\n  getPromise: (\n    get: Getter,\n    options: { signal: AbortSignal },\n  ) => TValue | Promise<TValue>,\n) {\n  const countAtom = atom(0);\n\n  const promiseAtom = atom((get, { signal }) => {\n    get(countAtom);\n\n    const maybePromise = getPromise(get, { signal });\n\n    const dataAtom = atom<Data<TValue | Promise<TValue>>>({\n      value: maybePromise,\n    });\n\n    dataAtom.onMount = (update) => {\n      if (maybePromise instanceof Promise) {\n        void maybePromise\n          .then((value) => startTransition(() => update({ value })))\n          .catch((error) => startTransition(() => update({ error })));\n      }\n    };\n\n    return dataAtom;\n  });\n\n  return atom(\n    (get) => {\n      const data = get(get(promiseAtom));\n\n      if (\"error\" in data) {\n        throw data.error;\n      }\n\n      return data.value;\n    },\n    (_, set) => {\n      set(countAtom, (count) => count + 1);\n    },\n  );\n}\n", "export function maybePromiseAll<T extends unknown | Promise<unknown>>(\n  maybePromises: T[],\n) {\n  return maybePromises.some((maybePromise) => maybePromise instanceof Promise)\n    ? Promise.all(maybePromises)\n    : maybePromises;\n}\n", "import type { Config } from \"@reactive-dot/core\";\nimport { createContext } from \"react\";\n\nexport const ConfigContext = createContext<Config | undefined>(undefined);\n", "import { ConfigContext } from \"../contexts/config.js\";\nimport { BaseError } from \"@reactive-dot/core\";\nimport { use } from \"react\";\n\n/**\n * Hook for getting the current config.\n *\n * @group Hooks\n * @returns The current config\n */\nexport function useConfig() {\n  const config = use(ConfigContext);\n\n  if (config === undefined) {\n    throw new BaseError(\"No config provided\");\n  }\n\n  return config;\n}\n", "import { createContext, useMemo, type PropsWithChildren } from \"react\";\n\nexport const SubscriptionContext = createContext({ active: true });\n\ntype SubscriptionProps = PropsWithChildren<{\n  active: boolean;\n}>;\n\n/**\n * React context to control subscription options.\n *\n * @group Contexts\n * @param props - Component props\n * @returns React element\n */\nexport function QueryOptionsProvider({ active, children }: SubscriptionProps) {\n  return (\n    <SubscriptionContext value={useMemo(() => ({ active }), [active])}>\n      {children}\n    </SubscriptionContext>\n  );\n}\n", "import { useAtomValue as useAtomValueBase } from \"jotai\";\n\nexport const useAtomValue: typeof useAtomValueBase = (\n  atom: Parameters<typeof useAtomValueBase>[0],\n  options: Parameters<typeof useAtomValueBase>[1],\n) => useAtomValueBase(atom, { unstable_promiseStatus: true, ...options });\n", "import { SubscriptionContext } from \"../contexts/query-options.js\";\nimport type { atomWithObservableAndPromise } from \"../utils/jotai/atom-with-observable-and-promise.js\";\nimport { useAtomValue } from \"./use-atom-value.js\";\nimport { use } from \"react\";\n\n/**\n * @internal\n * @group Hooks\n */\nexport function usePausableAtomValue<T>(\n  pausableAtom: ReturnType<typeof atomWithObservableAndPromise<T, never>>,\n  options?: Parameters<typeof useAtomValue>[1],\n) {\n  return useAtomValue(\n    use(SubscriptionContext).active\n      ? pausableAtom.observableAtom\n      : pausableAtom.promiseAtom,\n    options,\n  );\n}\n", "import type { ChainId } from \"@reactive-dot/core\";\nimport { createContext, type PropsWithChildren } from \"react\";\n\nexport const ChainIdContext = createContext<ChainId | undefined>(undefined);\n\nexport type ChainProviderProps = PropsWithChildren<{\n  chainId: ChainId;\n}>;\n\n/**\n * React context provider for scoping to a specific chain.\n *\n * @group Contexts\n * @param props - Component props\n * @returns React element\n */\nexport function ChainProvider(props: ChainProviderProps) {\n  return (\n    <ChainIdContext value={props.chainId}>{props.children}</ChainIdContext>\n  );\n}\n", "import { ChainIdContext } from \"../contexts/chain.js\";\nimport type { QueryArgument, ChainHookOptions, QueryOptions } from \"./types.js\";\nimport { type ChainId, Query, BaseError } from \"@reactive-dot/core\";\nimport { use, useMemo } from \"react\";\n\n/**\n * @internal\n * @group Hooks\n */\nexport function useQueryOptions<\n  TChainId extends ChainId | undefined,\n  TQuery extends QueryArgument<TChainId>,\n>(\n  query: TQuery,\n  options?: ChainHookOptions<TChainId>,\n): Array<{\n  chainId: ChainId;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query: Query<any[], any> | undefined;\n}>;\n/**\n * @internal\n * @group Hooks\n */\nexport function useQueryOptions<\n  TChainIds extends Array<ChainId | undefined>,\n  const TOptions extends {\n    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;\n  },\n>(\n  options: TOptions & {\n    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;\n  },\n): Array<{\n  chainId: ChainId;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query: Query<any[], any> | undefined;\n}>;\n/**\n * @internal\n * @group Hooks\n */\nexport function useQueryOptions(\n  queryOrOptions: // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | QueryArgument<any>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | Array<ChainHookOptions<any> & { query: QueryArgument<any> }>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mayBeOptions?: ChainHookOptions<any>,\n) {\n  const contextChainId = use(ChainIdContext);\n\n  return useMemo(\n    () =>\n      (Array.isArray(queryOrOptions)\n        ? queryOrOptions\n        : [{ query: queryOrOptions, ...mayBeOptions }]\n      ).map((options) => {\n        const chainId = options.chainId ?? contextChainId;\n\n        if (chainId === undefined) {\n          throw new BaseError(\"No chain ID provided\");\n        }\n\n        return {\n          chainId,\n          query:\n            options.query instanceof Query\n              ? options.query\n              : typeof options.query === \"function\"\n                ? options.query(new Query()) || undefined\n                : undefined,\n        };\n      }),\n    [contextChainId, mayBeOptions, queryOrOptions],\n  );\n}\n", "import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"RESET\" : \"\"\n);\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  return atom(initialValue, function(get, set, action) {\n    set(this, reducer(get(this), action));\n  });\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const listeners = /* @__PURE__ */ new Set();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    notifyListeners(\"CREATE\", param, newAtom);\n    return newAtom;\n  };\n  const notifyListeners = (type, param, atom) => {\n    for (const listener of listeners) {\n      listener({ type, param, atom });\n    }\n  };\n  createAtom.unstable_listen = (callback) => {\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n    };\n  };\n  createAtom.getParams = () => atoms.keys();\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      if (!atoms.has(param)) return;\n      const [atom] = atoms.get(param);\n      atoms.delete(param);\n      notifyListeners(\"REMOVE\", param, atom);\n    } else {\n      for (const [key, [atom]] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          notifyListeners(\"REMOVE\", key, atom);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove) return;\n    for (const [key, [atom, createdAt]] of atoms) {\n      if (shouldRemove(createdAt, key)) {\n        atoms.delete(key);\n        notifyListeners(\"REMOVE\", key, atom);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$3, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst frozenAtoms = /* @__PURE__ */ new WeakSet();\nconst deepFreeze = (value) => {\n  if (typeof value !== \"object\" || value === null) {\n    return value;\n  }\n  Object.freeze(value);\n  const propNames = Object.getOwnPropertyNames(value);\n  for (const name of propNames) {\n    deepFreeze(value[name]);\n  }\n  return value;\n};\nfunction freezeAtom(anAtom) {\n  if (frozenAtoms.has(anAtom)) {\n    return anAtom;\n  }\n  frozenAtoms.add(anAtom);\n  const origRead = anAtom.read;\n  anAtom.read = function(get, options) {\n    return deepFreeze(origRead.call(this, get, options));\n  };\n  if (\"write\" in anAtom) {\n    const origWrite = anAtom.write;\n    anAtom.write = function(get, set, ...args) {\n      return origWrite.call(\n        this,\n        get,\n        (...setArgs) => {\n          if (setArgs[0] === anAtom) {\n            setArgs[1] = deepFreeze(setArgs[1]);\n          }\n          return set(...setArgs);\n        },\n        ...args\n      );\n    };\n  }\n  return anAtom;\n}\nfunction freezeAtomCreator(createAtom) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] freezeAtomCreator is deprecated, define it on users end\"\n    );\n  }\n  return (...args) => freezeAtom(createAtom(...args));\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike$3 = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n  return (unknownStorage) => {\n    const storage = {\n      ...unknownStorage,\n      getItem: (key, initialValue) => {\n        const validate = (value2) => {\n          if (!validator(value2)) {\n            return initialValue;\n          }\n          return value2;\n        };\n        const value = unknownStorage.getItem(key, initialValue);\n        if (isPromiseLike$3(value)) {\n          return value.then(validate);\n        }\n        return validate(value);\n      }\n    };\n    return storage;\n  };\n}\nfunction createJSONStorage(getStringStorage = () => {\n  try {\n    return window.localStorage;\n  } catch (e) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      if (typeof window !== \"undefined\") {\n        console.warn(e);\n      }\n    }\n    return void 0;\n  }\n}, options) {\n  var _a;\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a2, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n          } catch (e) {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;\n      if (isPromiseLike$3(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(\n        key,\n        JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n      );\n    },\n    removeItem: (key) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);\n    }\n  };\n  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {\n    let newValue;\n    try {\n      newValue = JSON.parse(v || \"\");\n    } catch (e) {\n      newValue = initialValue;\n    }\n    callback(newValue);\n  });\n  let subscriber;\n  try {\n    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;\n  } catch (e) {\n  }\n  if (!subscriber && typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    subscriber = (key, callback) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          callback(e.newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  if (subscriber) {\n    storage.subscribe = createHandleSubscribe(subscriber);\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n  const getOnInit = options == null ? void 0 : options.getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    setAtom(storage.getItem(key, initialValue));\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (isPromiseLike$3(nextValue)) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike$2 = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const unsubscribe = () => {\n      if (subscription) {\n        subscription.unsubscribe();\n        subscription = void 0;\n      }\n    };\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(unsubscribe, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (options == null ? void 0 : options.unstable_timeout) {\n          timer = setTimeout(unsubscribe, options.unstable_timeout);\n        } else {\n          unsubscribe();\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (isPromiseLike$2(result)) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst isPromiseLike$1 = (p) => typeof (p == null ? void 0 : p.then) === \"function\";\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!isPromiseLike$1(value)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached1 = loadableCache.get(promise);\n        if (cached1) {\n          return cached1;\n        }\n        promise.then(\n          (data) => {\n            loadableCache.set(promise, { state: \"hasData\", data });\n            setSelf();\n          },\n          (error) => {\n            loadableCache.set(promise, { state: \"hasError\", error });\n            setSelf();\n          }\n        );\n        const cached2 = loadableCache.get(promise);\n        if (cached2) {\n          return cached2;\n        }\n        loadableCache.set(promise, LOADING);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst isPromiseLike = (p) => typeof (p == null ? void 0 : p.then) === \"function\";\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!isPromiseLike(promise)) {\n            return { v: promise };\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            promise.then(\n              (v) => {\n                promiseResultCache.set(promise, v);\n                setSelf();\n              },\n              (e) => {\n                promiseErrorCache.set(promise, e);\n                setSelf();\n              }\n            );\n          }\n          if (promiseErrorCache.has(promise)) {\n            throw promiseErrorCache.get(promise);\n          }\n          if (promiseResultCache.has(promise)) {\n            return {\n              p: promise,\n              v: promiseResultCache.get(promise)\n            };\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v), v: prev.v };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"f\" in state) {\n            return state.f;\n          }\n          return state.v;\n        },\n        (_get, set, ...args) => set(anAtom, ...args)\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nfunction atomWithRefresh(read, write) {\n  const refreshAtom = atom(0);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    refreshAtom.debugPrivate = true;\n  }\n  return atom(\n    (get, options) => {\n      get(refreshAtom);\n      return read(get, options);\n    },\n    (get, set, ...args) => {\n      if (args.length === 0) {\n        set(refreshAtom, (c) => c + 1);\n      } else if (write) {\n        return write(get, set, ...args);\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        throw new Error(\"refresh must be called without arguments\");\n      }\n    }\n  );\n}\n\nfunction atomWithLazy(makeInitial) {\n  const a = atom(void 0);\n  delete a.init;\n  Object.defineProperty(a, \"init\", {\n    get() {\n      return makeInitial();\n    }\n  });\n  return a;\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithLazy, atomWithObservable, atomWithReducer, atomWithRefresh, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, withStorageValidator as unstable_withStorageValidator, unwrap };\n", "'use client';\nimport { useCallback, useMemo } from 'react';\nimport { useSetAtom, useAtom, useStore } from 'jotai/react';\nimport { RESET } from 'jotai/vanilla/utils';\nimport { atom } from 'jotai/vanilla';\n\nfunction useResetAtom(anAtom, options) {\n  const setAtom = useSetAtom(anAtom, options);\n  const resetAtom = useCallback(() => setAtom(RESET), [setAtom]);\n  return resetAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, options) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] useReducerAtom is deprecated and will be removed in the future. Please create your own version using the recipe. https://github.com/pmndrs/jotai/pull/2467\"\n    );\n  }\n  const [state, setState] = useAtom(anAtom, options);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction useAtomCallback(callback, options) {\n  const anAtom = useMemo(\n    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),\n    [callback]\n  );\n  return useSetAtom(anAtom, options);\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, options) {\n  const store = useStore(options);\n  const hydratedSet = getHydratedSet(store);\n  for (const [atom, value] of values) {\n    if (!hydratedSet.has(atom) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {\n      hydratedSet.add(atom);\n      store.set(atom, value);\n    }\n  }\n}\nconst getHydratedSet = (store) => {\n  let hydratedSet = hydratedMap.get(store);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(store, hydratedSet);\n  }\n  return hydratedSet;\n};\n\nexport { useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom };\n", "import type { ChainHookOptions, QueryArgument, QueryOptions } from \"./types.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { useQueryOptions } from \"./use-query-options.js\";\nimport { getQueryInstructionPayloadAtoms } from \"./use-query.js\";\nimport { type ChainId } from \"@reactive-dot/core\";\nimport type { WritableAtom } from \"jotai\";\nimport { useAtomCallback } from \"jotai/utils\";\nimport { useCallback } from \"react\";\n\n/**\n * Hook for refreshing cached query.\n *\n * @group Hooks\n * @param query - The function to create the query\n * @param options - Additional options\n * @returns The function to refresh the query\n */\nexport function useQueryRefresher<\n  TChainId extends ChainId | undefined,\n  TQuery extends QueryArgument<TChainId>,\n>(query: TQuery, options?: ChainHookOptions<TChainId>): () => void;\n/**\n * Hook for refreshing cached query.\n *\n * @param options - The query options\n * @returns The function to refresh the query\n */\nexport function useQueryRefresher<\n  TChainIds extends Array<ChainId | undefined>,\n  const TOptions extends {\n    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;\n  },\n>(\n  options: TOptions & {\n    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;\n  },\n): () => void;\n/**\n * Hook for refreshing cached query.\n *\n * @group Hooks\n * @param query - The function to create the query\n * @param options - Additional options\n * @returns The function to refresh the query\n */\nexport function useQueryRefresher(\n  queryOrOptions: // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | QueryArgument<any>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | Array<ChainHookOptions<any> & { query: QueryArgument<any> }>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mayBeOptions?: ChainHookOptions<any>,\n) {\n  const options = useQueryOptions(\n    // @ts-expect-error complex overload\n    queryOrOptions,\n    mayBeOptions,\n  );\n\n  const config = useConfig();\n\n  const refresh = useAtomCallback(\n    useCallback(\n      (_, set) => {\n        for (const { chainId, query } of options) {\n          if (query === undefined) {\n            return;\n          }\n\n          const atoms = getQueryInstructionPayloadAtoms(\n            config,\n            chainId,\n            query,\n          ).flat();\n\n          for (const atom of atoms) {\n            if (\"write\" in atom.promiseAtom) {\n              set(\n                atom.promiseAtom as WritableAtom<unknown, unknown[], unknown>,\n              );\n            }\n          }\n        }\n      },\n      [config, options],\n    ),\n  );\n\n  return refresh;\n}\n", "import { useRef } from \"react\";\n\n/**\n * @internal\n * @group Hooks\n */\nexport function useRenderEffect<T>(effect: () => void, key: T) {\n  const prevKey = useRef(key);\n  const currKey = useRef(prevKey.current);\n\n  currKey.current = key;\n\n  if (prevKey.current !== currKey.current) {\n    prevKey.current = currKey.current;\n    effect();\n  }\n}\n", "import { ChainIdContext } from \"../contexts/chain.js\";\nimport type { ChainHookOptions } from \"./types.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { type ChainId, BaseError } from \"@reactive-dot/core\";\nimport { use } from \"react\";\n\n/**\n * Hook for getting all configured chain IDs.\n *\n * @group Hooks\n * @returns All configured chain IDs\n */\nexport function useChainIds() {\n  return Object.keys(useConfig().chains) as ChainId[];\n}\n\n/**\n * Hook for getting the current chain ID.\n *\n * @group Hooks\n * @returns The current chain ID\n */\nexport function useChainId() {\n  const chainId = use(ChainIdContext);\n\n  if (chainId === undefined) {\n    throw new BaseError(\"No chain ID provided\");\n  }\n\n  return chainId as ChainId;\n}\n\n/**\n * @internal\n * @group Hooks\n */\nexport function internal_useChainId<TOptionalChainId extends boolean = false>({\n  optionalChainId = false as TOptionalChainId,\n  ...options\n}: ChainHookOptions & {\n  optionalChainId?: TOptionalChainId;\n} = {}) {\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const contextChainId = use(ChainIdContext);\n  const chainId = options?.chainId ?? contextChainId;\n\n  if (!optionalChainId && chainId === undefined) {\n    throw new BaseError(\"No chain ID provided\");\n  }\n\n  return chainId as TOptionalChainId extends false\n    ? ChainId\n    : ChainId | undefined;\n}\n", "import { atomFamilyWithErrorCatcher } from \"../utils/jotai/atom-family-with-error-catcher.js\";\nimport type { ChainHookOptions } from \"./types.js\";\nimport { useAtomValue } from \"./use-atom-value.js\";\nimport { internal_useChainId } from \"./use-chain-id.js\";\nimport { useConfig } from \"./use-config.js\";\nimport type { ChainId, Config } from \"@reactive-dot/core\";\nimport { BaseError } from \"@reactive-dot/core\";\nimport { getClient } from \"@reactive-dot/core/internal/actions.js\";\nimport { atom } from \"jotai\";\n\n/**\n * Hook for getting Polkadot-API client instance.\n *\n * @group Hooks\n * @param options - Additional options\n * @returns Polkadot-API client\n */\nexport function useClient(options?: ChainHookOptions) {\n  return useAtomValue(clientAtom(useConfig(), internal_useChainId(options)));\n}\n\n/**\n * @internal\n */\nexport const clientAtom = atomFamilyWithErrorCatcher(\n  (withErrorCatcher, config: Config, chainId: ChainId) =>\n    withErrorCatcher(\n      atom(() => {\n        const chainConfig = config.chains[chainId];\n\n        if (chainConfig === undefined) {\n          throw new BaseError(`No config provided for ${chainId}`);\n        }\n\n        return getClient(chainConfig);\n      }),\n    ),\n);\n", "export function isPromise(value) {\n    return value && typeof value === 'object' && 'then' in value;\n}\n", "import { isPromise } from './isPromise.js';\nexport function soon(first, second) {\n    if (second) {\n        // data-first\n        return _soonImpl(first, second);\n    }\n    // data-last\n    return (data) => {\n        return _soonImpl(data, first);\n    };\n}\nfunction _soonImpl(data, process) {\n    if (isPromise(data)) {\n        if (data.status === 'fulfilled') {\n            // can process the value earlier\n            return process(data.value);\n        }\n        if (data.status === 'rejected') {\n            // To keep the error handling behavior consistent, lets\n            // always return a rejected promise, even if the processing\n            // can be done in sync.\n            return Promise.reject(data.reason);\n        }\n        return data.then((value) => process(value));\n    }\n    try {\n        return process(data);\n    }\n    catch (err) {\n        // To keep the error handling behavior consistent, lets\n        // always return a rejected promise, even if the processing\n        // can be done in sync.\n        return Promise.reject(err);\n    }\n}\n", "import { isPromise } from './isPromise.js';\nfunction isKnown(value) {\n    if (isPromise(value)) {\n        return value.status === 'fulfilled'; // only if fulfilled\n    }\n    return true; // not a promise, we know the value.\n}\nexport function soonAll(values) {\n    if (values.every(isKnown)) {\n        return values.map((el) => isPromise(el) ? el.value : el);\n    }\n    return Promise.all(values);\n}\n", "import { atom } from 'jotai/vanilla';\nimport { soon } from './soon.js';\nimport { soonAll } from './soonAll.js';\n/**\n * Awaits all `deps` if necessary, then runs `op` given all deps in the same order.\n * If computing the value fails (throws), a rejected Promise is returned no matter if\n * the processing happened synchronously or not.\n */\nexport function derive(deps, op) {\n    return atom((get) => {\n        try {\n            return soon(soonAll(deps.map(get)), (values) => op(...values));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    });\n}\n", "import { atomFamilyWithErrorCatcher } from \"../utils/jotai/atom-family-with-error-catcher.js\";\nimport type { ChainHookOptions } from \"./types.js\";\nimport { useAtomValue } from \"./use-atom-value.js\";\nimport { internal_useChainId } from \"./use-chain-id.js\";\nimport { clientAtom } from \"./use-client.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { BaseError, type ChainId, type Config } from \"@reactive-dot/core\";\nimport type { ChainDescriptorOf } from \"@reactive-dot/core/internal.js\";\nimport { atom } from \"jotai\";\nimport { soon } from \"jotai-derive\";\nimport type { TypedApi } from \"polkadot-api\";\n\n/**\n * Hook for getting Polkadot-API typed API.\n *\n * @group Hooks\n * @param options - Additional options\n * @returns Polkadot-API typed API\n */\nexport function useTypedApi<TChainId extends ChainId | undefined>(\n  options?: ChainHookOptions<TChainId>,\n) {\n  return useAtomValue(\n    typedApiAtom(useConfig(), internal_useChainId(options)),\n  ) as TypedApi<ChainDescriptorOf<TChainId>>;\n}\n\n/**\n * @internal\n */\nexport const typedApiAtom = atomFamilyWithErrorCatcher(\n  (withErrorCatcher, config: Config, chainId: ChainId) =>\n    withErrorCatcher(\n      atom((get) => {\n        const chainConfig = config.chains[chainId];\n\n        if (chainConfig === undefined) {\n          throw new BaseError(`No config provided for chain ${chainId}`);\n        }\n\n        return soon(get(clientAtom(config, chainId)), (client) =>\n          client.getTypedApi(chainConfig.descriptor),\n        );\n      }),\n    ),\n);\n", "export function flatHead<T>(value: T): T extends [infer Head] ? Head : T {\n  if (Array.isArray(value) && value.length === 1) {\n    return value.at(0);\n  }\n\n  // @ts-expect-error TODO: fix this\n  return value;\n}\n", "import { Binary } from \"polkadot-api\";\n\nexport function stringify<T>(queryInstruction: T) {\n  return JSON.stringify(queryInstruction, (_, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n\n    if (value instanceof Binary) {\n      return value.asHex();\n    }\n\n    if (isPlainObject(value)) {\n      return Object.keys(value)\n        .sort()\n        .reduce(\n          (result, key) => {\n            result[key] = value[key as keyof typeof value];\n            return result;\n          },\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          {} as any,\n        );\n    }\n\n    return value;\n  });\n}\n\nfunction isPlainObject(value: unknown): value is object {\n  if (!hasObjectPrototype(value)) {\n    return false;\n  }\n\n  // If has modified constructor\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const ctor = (value as any).constructor;\n  if (typeof ctor === \"undefined\") return true;\n\n  // If has modified prototype\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) return false;\n\n  // If constructor does not have an Object-specific method\n  // eslint-disable-next-line no-prototype-builtins\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) return false;\n\n  // Most likely a plain Object\n  return true;\n}\n\nfunction hasObjectPrototype(o: unknown) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\n", "import { findAllIndexes } from \"../utils/find-all-indexes.js\";\nimport { interlace } from \"../utils/interlace.js\";\nimport { atomFamilyWithErrorCatcher } from \"../utils/jotai/atom-family-with-error-catcher.js\";\nimport { atomWithObservableAndPromise } from \"../utils/jotai/atom-with-observable-and-promise.js\";\nimport { atomWithPromise } from \"../utils/jotai/atom-with-promise.js\";\nimport { maybePromiseAll } from \"../utils/maybe-promise-all.js\";\nimport { objectId } from \"../utils/object-id.js\";\nimport type {\n  ChainHookOptions,\n  InferQueryArgumentResult,\n  QueryArgument,\n  QueryOptions,\n} from \"./types.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { usePausableAtomValue } from \"./use-pausable-atom-value.js\";\nimport { useQueryOptions } from \"./use-query-options.js\";\nimport { useQueryRefresher } from \"./use-query-refresher.js\";\nimport { useRenderEffect } from \"./use-render-effect.js\";\nimport { typedApiAtom } from \"./use-typed-api.js\";\nimport {\n  type ChainId,\n  type Config,\n  idle,\n  type Query,\n} from \"@reactive-dot/core\";\nimport {\n  flatHead,\n  type MultiInstruction,\n  type QueryInstruction,\n  stringify,\n} from \"@reactive-dot/core/internal.js\";\nimport { preflight, query } from \"@reactive-dot/core/internal/actions.js\";\nimport { atom } from \"jotai\";\nimport { soon } from \"jotai-derive\";\nimport { useMemo } from \"react\";\nimport { from, type Observable } from \"rxjs\";\nimport { switchMap } from \"rxjs/operators\";\n\ntype FetchOptions = {\n  /**\n   * A unique identifier that, when changed, forces a refresh of the current query.\n   */\n  fetchKey?: string | number;\n};\n\n/**\n * Hook for querying data from chain, and returning the response.\n *\n * @group Hooks\n * @param query - The function to create the query\n * @param options - Additional options\n * @returns The data response\n */\nexport function useLazyLoadQuery<\n  TChainId extends ChainId | undefined,\n  TQuery extends QueryArgument<TChainId>,\n>(\n  query: TQuery,\n  options?: ChainHookOptions<TChainId> & FetchOptions,\n): InferQueryArgumentResult<TChainId, TQuery>;\n/**\n * Hook for querying data from chain, and returning the response.\n *\n * @group Hooks\n * @param options - The query options\n * @returns The data response\n */\nexport function useLazyLoadQuery<\n  TChainIds extends Array<ChainId | undefined>,\n  const TOptions extends {\n    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;\n  },\n>(\n  queryOptions: TOptions & {\n    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;\n  },\n  options?: FetchOptions,\n): {\n  [P in keyof TOptions]: InferQueryArgumentResult<\n    TOptions[P][\"chainId\"],\n    TOptions[P][\"query\"]\n  >;\n};\nexport function useLazyLoadQuery(\n  queryOrOptions: // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | QueryArgument<any>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | Array<ChainHookOptions<any> & { query: QueryArgument<any> }>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mayBeOptions?: ChainHookOptions<any> | FetchOptions,\n) {\n  const options = useQueryOptions(\n    // @ts-expect-error complex overload\n    queryOrOptions,\n    mayBeOptions,\n  );\n\n  // @ts-expect-error complex types\n  const refresh = useQueryRefresher(queryOrOptions, mayBeOptions);\n\n  const fetchKey =\n    mayBeOptions !== undefined && \"fetchKey\" in mayBeOptions\n      ? mayBeOptions.fetchKey\n      : undefined;\n\n  useRenderEffect(() => {\n    refresh();\n  }, fetchKey);\n\n  const partialData = usePausableAtomValue(\n    queryPayloadAtom(\n      useConfig(),\n      useMemo(\n        () =>\n          options.filter(\n            (\n              options,\n            ): options is Omit<typeof options, \"query\"> & {\n              query: NonNullable<(typeof options)[\"query\"]>;\n            } => options.query !== undefined,\n          ),\n        [options],\n      ),\n    ),\n  );\n\n  return useMemo<unknown>(() => {\n    const unflattenedData = interlace(\n      partialData,\n      findAllIndexes(options, (options) => options.query === undefined).map(\n        (index) => [idle as unknown, index] as const,\n      ),\n    );\n\n    return !Array.isArray(queryOrOptions)\n      ? flatHead(unflattenedData)\n      : unflattenedData;\n  }, [options, partialData, queryOrOptions]);\n}\n\n/**\n * Hook for querying data from chain, returning the response & a refresher function.\n *\n * @deprecated Use {@link useLazyLoadQuery} with {@link FetchOptions.fetchKey | options.fetchKey} instead\n * @param query - The function to create the query\n * @param options - Additional options\n * @returns The data response & a function to refresh it\n */\nexport function useLazyLoadQueryWithRefresh<\n  TChainId extends ChainId | undefined,\n  TQuery extends QueryArgument<TChainId>,\n>(\n  query: TQuery,\n  options?: ChainHookOptions<TChainId>,\n): [data: InferQueryArgumentResult<TChainId, TQuery>, refresh: () => void];\n/**\n * Hook for querying data from chain, returning the response & a refresher function.\n *\n * @deprecated Use {@link useLazyLoadQuery} with {@link FetchOptions.fetchKey | options.fetchKey} instead\n * @group Hooks\n * @param query - The function to create the query\n * @param options - Additional options\n * @returns The data response & a function to refresh it\n */\nexport function useLazyLoadQueryWithRefresh<\n  TChainIds extends Array<ChainId | undefined>,\n  const TOptions extends {\n    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;\n  },\n>(\n  options: TOptions & {\n    [P in keyof TChainIds]: QueryOptions<TChainIds[P]>;\n  },\n): [\n  data: {\n    [P in keyof TOptions]: InferQueryArgumentResult<\n      TOptions[P][\"chainId\"],\n      TOptions[P][\"query\"]\n    >;\n  },\n  refresh: () => void,\n];\nexport function useLazyLoadQueryWithRefresh(\n  ...args: unknown[]\n): [unknown, unknown] {\n  // @ts-expect-error need to spread args\n  const data = useLazyLoadQuery(...args);\n  // @ts-expect-error need to spread args\n  const refresh = useQueryRefresher(...args);\n\n  return [data, refresh];\n}\n\nconst instructionPayloadAtom = atomFamilyWithErrorCatcher(\n  (\n    withErrorCatcher,\n    config: Config,\n    chainId: ChainId,\n    instruction: Exclude<\n      QueryInstruction,\n      MultiInstruction<// @ts-expect-error need any empty object here\n      // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n      {}>\n    >,\n  ) => {\n    switch (preflight(instruction)) {\n      case \"promise\": {\n        const atom = withErrorCatcher(\n          atomWithPromise((get, { signal }) =>\n            soon(get(typedApiAtom(config, chainId)), (api) =>\n              query(api, instruction, { signal }),\n            ),\n          ),\n        );\n\n        return {\n          observableAtom: atom,\n          promiseAtom: atom,\n        };\n      }\n      case \"observable\":\n        return atomWithObservableAndPromise(\n          (get) =>\n            from(Promise.resolve(get(typedApiAtom(config, chainId)))).pipe(\n              switchMap(\n                (api) => query(api, instruction) as Observable<unknown>,\n              ),\n            ),\n          withErrorCatcher,\n        );\n    }\n  },\n  (config, chainId, instruction) =>\n    [objectId(config), chainId, stringify(instruction)].join(),\n);\n\n/**\n * @internal\n */\nexport function getQueryInstructionPayloadAtoms(\n  config: Config,\n  chainId: ChainId,\n  query: Query,\n) {\n  return query.instructions.map((instruction) => {\n    if (!(\"multi\" in instruction)) {\n      return instructionPayloadAtom(config, chainId, instruction);\n    }\n\n    return instruction.args.map((args) => {\n      const { multi, ...rest } = instruction;\n\n      return instructionPayloadAtom(config, chainId, { ...rest, args });\n    });\n  });\n}\n\n/**\n * @internal\n * TODO: should be memoized within render function instead\n * https://github.com/pmndrs/jotai/discussions/1553\n */\nexport const queryPayloadAtom = atomFamilyWithErrorCatcher(\n  (\n    withErrorCatcher,\n    config: Config,\n    params: Array<{ chainId: ChainId; query: Query }>,\n  ) => {\n    const atoms = params.map((param) =>\n      getQueryInstructionPayloadAtoms(config, param.chainId, param.query),\n    );\n\n    const unwrap = (\n      atoms: ReturnType<typeof atomWithObservableAndPromise>,\n      asObservable: boolean,\n    ) => (asObservable ? atoms.observableAtom : atoms.promiseAtom);\n\n    const createAtom = (asObservable: boolean) =>\n      withErrorCatcher(\n        atom((get) => {\n          return maybePromiseAll(\n            atoms.map((atomOrAtoms) =>\n              !Array.isArray(atomOrAtoms)\n                ? atomOrAtoms\n                : soon(\n                    maybePromiseAll(\n                      atomOrAtoms.map((atomOrAtoms) => {\n                        if (Array.isArray(atomOrAtoms)) {\n                          return maybePromiseAll(\n                            atomOrAtoms.map((atom) =>\n                              get(unwrap(atom, asObservable)),\n                            ),\n                          );\n                        }\n\n                        return get(unwrap(atomOrAtoms, asObservable));\n                      }),\n                    ),\n                    flatHead,\n                  ),\n            ),\n          );\n        }),\n      );\n\n    return { promiseAtom: createAtom(false), observableAtom: createAtom(true) };\n  },\n  (config, params) =>\n    [\n      objectId(config),\n      ...params.map((param) => [\n        param.chainId,\n        stringify(param.query.instructions),\n      ]),\n    ].join(),\n);\n", "import type {\n  InferQueryArgumentResult,\n  QueryArgument,\n} from \"../hooks/types.js\";\nimport { useLazyLoadQuery } from \"../hooks/use-query.js\";\nimport type { ChainId } from \"@reactive-dot/core\";\nimport type { ReactNode } from \"react\";\n\ntype QueryRendererProps<\n  TChainId extends ChainId | undefined,\n  TQuery extends QueryArgument<TChainId>,\n> = {\n  query: TQuery;\n  chainId?: TChainId;\n  children: (result: InferQueryArgumentResult<TChainId, TQuery>) => ReactNode;\n};\n\n/**\n * Component for rendering the result of a query.\n *\n * @experimental\n * @group Components\n */\nexport function QueryRenderer<\n  TChainId extends ChainId | undefined,\n  TQuery extends QueryArgument<TChainId>,\n>({ query, chainId, children }: QueryRendererProps<TChainId, TQuery>) {\n  return children(useLazyLoadQuery(query, { chainId }));\n}\n", "import { createStore, getDefaultStore, useStore } from \"jotai\";\nimport { useMemo } from \"react\";\n\n/**\n * @internal\n * @group Hooks\n */\nexport function useLocalStore() {\n  const contextStore = useStore();\n\n  return useMemo(\n    () => (contextStore === getDefaultStore() ? createStore() : contextStore),\n    [contextStore],\n  );\n}\n", "export function isSsr() {\n  return typeof window === \"undefined\";\n}\n", "import { isSsr } from \"../utils/is-ssr.js\";\nimport { atomFamilyWithErrorCatcher } from \"../utils/jotai/atom-family-with-error-catcher.js\";\nimport { atomWithObservableAndPromise } from \"../utils/jotai/atom-with-observable-and-promise.js\";\nimport { useAtomValue } from \"./use-atom-value.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { usePausableAtomValue } from \"./use-pausable-atom-value.js\";\nimport type { Config } from \"@reactive-dot/core\";\nimport {\n  aggregateWallets,\n  getConnectedWallets,\n} from \"@reactive-dot/core/internal/actions.js\";\nimport { atom } from \"jotai\";\n\n/**\n * Hook for getting all available wallets.\n *\n * @group Hooks\n * @returns Available wallets\n */\nexport function useWallets() {\n  return useAtomValue(walletsAtom(useConfig()));\n}\n\n/**\n * Hook for getting all connected wallets.\n *\n * @group Hooks\n * @returns Connected wallets\n */\nexport function useConnectedWallets() {\n  return usePausableAtomValue(connectedWalletsAtom(useConfig()));\n}\n\n/**\n * @internal\n */\nexport const walletsAtom = atomFamilyWithErrorCatcher(\n  (withErrorCatcher, config: Config) =>\n    isSsr()\n      ? atom(Promise.resolve([]))\n      : withErrorCatcher(atom(() => aggregateWallets(config.wallets ?? []))),\n);\n\n/**\n * @internal\n */\nexport const connectedWalletsAtom = atomFamilyWithErrorCatcher(\n  (withErrorCatcher, config: Config) =>\n    atomWithObservableAndPromise(\n      (get) => getConnectedWallets(get(walletsAtom(config))),\n      withErrorCatcher,\n    ),\n);\n", "import { useWallets } from \"./use-wallets.js\";\nimport {\n  idle,\n  pending,\n  type AsyncValue,\n  type BaseError,\n} from \"@reactive-dot/core\";\nimport { initializeWallets } from \"@reactive-dot/core/internal/actions.js\";\nimport { useCallback, useState } from \"react\";\n\n/**\n * Hook for initializing wallets.\n *\n * @internal\n * @group Hooks\n * @returns The initialization state and initialize function\n */\nexport function useWalletsInitializer() {\n  const wallets = useWallets();\n\n  const [state, setState] = useState<AsyncValue<true, BaseError>>(idle);\n\n  const initialize = useCallback(async () => {\n    setState(pending);\n    await initializeWallets(wallets);\n  }, [wallets]);\n\n  return [state, initialize] as [\n    state: typeof state,\n    initialize: typeof initialize,\n  ];\n}\n", "import type { AsyncValue, idle, MutationError } from \"@reactive-dot/core\";\nimport type { MutationEvent as BaseMutationEvent } from \"@reactive-dot/core/internal.js\";\nimport type { TxEvent } from \"polkadot-api\";\nimport { createContext } from \"react\";\nimport { Subject } from \"rxjs\";\n\nexport type MutationEvent = BaseMutationEvent & {\n  value: Exclude<AsyncValue<TxEvent, MutationError>, typeof idle>;\n};\n\nexport const MutationEventSubjectContext = createContext(\n  new Subject<MutationEvent>(),\n);\n", "import { useLocalStore } from \"../hooks/use-local-store.js\";\nimport { useWalletsInitializer } from \"../hooks/use-wallets-initializer.js\";\nimport { ConfigContext } from \"./config.js\";\nimport { MutationEventSubjectContext } from \"./mutation.js\";\nimport type { Config } from \"@reactive-dot/core\";\nimport { Provider as JotaiProvider } from \"jotai\";\nimport { type PropsWithChildren, Suspense, useEffect, useMemo } from \"react\";\nimport { Subject } from \"rxjs\";\n\nexport type ReactiveDotProviderProps = PropsWithChildren<{\n  /**\n   * Global config used by ReactiveDOT.\n   */\n  config: Config;\n}>;\n\n/**\n * React context provider for ReactiveDOT.\n *\n * @group Contexts\n * @param props - Component props\n * @returns React element\n */\nexport function ReactiveDotProvider({\n  config,\n  children,\n}: ReactiveDotProviderProps) {\n  return (\n    <JotaiProvider store={useLocalStore()}>\n      <ConfigContext value={config}>\n        <MutationEventSubjectContext value={useMemo(() => new Subject(), [])}>\n          <Suspense>\n            <WalletsInitializer />\n          </Suspense>\n          {children}\n        </MutationEventSubjectContext>\n      </ConfigContext>\n    </JotaiProvider>\n  );\n}\n\nfunction WalletsInitializer() {\n  const [_, initialize] = useWalletsInitializer();\n\n  useEffect(() => {\n    initialize();\n  }, [initialize]);\n\n  return null;\n}\n", "import type { PolkadotSigner } from \"polkadot-api\";\nimport { createContext, type PropsWithChildren } from \"react\";\n\nexport const SignerContext = createContext<PolkadotSigner | undefined>(\n  undefined,\n);\n\nexport type SignerProviderProps = PropsWithChildren<{\n  /**\n   * The default signer\n   */\n  signer: PolkadotSigner | undefined;\n}>;\n\n/**\n * React context provider to assign a default signer.\n *\n * @group Contexts\n * @param props - Component props\n * @returns React element\n */\nexport function SignerProvider(props: SignerProviderProps) {\n  return <SignerContext value={props.signer}>{props.children}</SignerContext>;\n}\n", "import { atomFamilyWithErrorCatcher } from \"../utils/jotai/atom-family-with-error-catcher.js\";\nimport type { ChainHookOptions } from \"./types.js\";\nimport { useAtomValue } from \"./use-atom-value.js\";\nimport { internal_useChainId } from \"./use-chain-id.js\";\nimport { clientAtom } from \"./use-client.js\";\nimport { useConfig } from \"./use-config.js\";\nimport type { ChainId, Config } from \"@reactive-dot/core\";\nimport { derive } from \"jotai-derive\";\n\n/**\n * Hook for fetching the [JSON-RPC spec](https://paritytech.github.io/json-rpc-interface-spec/api/chainSpec.html).\n *\n * @group Hooks\n * @param options - Additional options\n * @returns The [JSON-RPC spec](https://paritytech.github.io/json-rpc-interface-spec/api/chainSpec.html)\n */\nexport function useChainSpecData(options?: ChainHookOptions) {\n  return useAtomValue(\n    chainSpecDataAtom(useConfig(), internal_useChainId(options)),\n  );\n}\n\n/**\n * @internal\n */\nexport const chainSpecDataAtom = atomFamilyWithErrorCatcher(\n  (withErrorCatcher, config: Config, chainId: ChainId) =>\n    withErrorCatcher(\n      derive([clientAtom(config, chainId)], (client) =>\n        client.getChainSpecData(),\n      ),\n    ),\n);\n", "import { atomFamilyWithErrorCatcher } from \"../utils/jotai/atom-family-with-error-catcher.js\";\nimport { atomWithObservableAndPromise } from \"../utils/jotai/atom-with-observable-and-promise.js\";\nimport type { ChainHookOptions } from \"./types.js\";\nimport { internal_useChainId } from \"./use-chain-id.js\";\nimport { chainSpecDataAtom } from \"./use-chain-spec-data.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { usePausableAtomValue } from \"./use-pausable-atom-value.js\";\nimport { connectedWalletsAtom } from \"./use-wallets.js\";\nimport { type ChainId, type Config } from \"@reactive-dot/core\";\nimport { getAccounts } from \"@reactive-dot/core/internal/actions.js\";\n\n/**\n * Hook for getting currently connected accounts.\n *\n * @group Hooks\n * @param options - Additional options\n * @returns The currently connected accounts\n */\nexport function useAccounts(options?: ChainHookOptions) {\n  return usePausableAtomValue(\n    accountsAtom(\n      useConfig(),\n      internal_useChainId({ ...options, optionalChainId: true }),\n    ),\n  );\n}\n\n/**\n * @internal\n */\nexport const accountsAtom = atomFamilyWithErrorCatcher(\n  (withErrorCatcher, config: Config, chainId: ChainId | undefined) =>\n    atomWithObservableAndPromise(\n      (get) =>\n        getAccounts(\n          get(connectedWalletsAtom(config).observableAtom),\n          chainId === undefined\n            ? undefined\n            : get(chainSpecDataAtom(config, chainId)),\n        ),\n      withErrorCatcher,\n    ),\n);\n", "export const BigIntMath = Object.freeze({\n  min(...values: bigint[]) {\n    if (values.length === 0) {\n      return 0n;\n    }\n\n    return values.reduce((previousValue, currentValue) =>\n      currentValue < previousValue ? currentValue : previousValue,\n    );\n  },\n  max(...values: bigint[]) {\n    if (values.length === 0) {\n      return 0n;\n    }\n\n    return values.reduce((previousValue, currentValue) =>\n      currentValue > previousValue ? currentValue : previousValue,\n    );\n  },\n  get [Symbol.toStringTag]() {\n    return \"BigIntMath\";\n  },\n});\n", "export class DenominatedNumber extends Number {\n  // Large values lead to massive memory usage. Limit to something sensible.\n  static #maxDecimal = 100;\n\n  readonly planck: bigint;\n\n  constructor(\n    planck: bigint | boolean | number | string,\n    readonly decimals: number,\n    readonly denomination?: string,\n  ) {\n    super();\n    this.planck = BigInt(planck);\n  }\n\n  static fromNumber(\n    number: number | string,\n    decimals: number,\n    denomination?: string,\n  ) {\n    DenominatedNumber.#verifyDecimals(decimals);\n\n    const numberString = number.toString();\n\n    const badCharacter = numberString.match(/[^0-9.]/);\n    if (badCharacter) {\n      throw new Error(\n        `Invalid character at position ${(badCharacter.index ?? 0) + 1}`,\n      );\n    }\n\n    let whole: string;\n    let fractional: string;\n\n    if (numberString.search(/\\./) === -1) {\n      // integer format, no separator\n      whole = numberString;\n      fractional = \"\";\n    } else {\n      const parts = numberString.split(\".\");\n      switch (parts.length) {\n        case 0:\n        case 1:\n          throw new Error(\n            \"Fewer than two elements in split result. This must not happen here.\",\n          );\n        case 2:\n          if (!parts[1]) throw new Error(\"Fractional part missing\");\n\n          whole = parts[0]!;\n          fractional = parts[1].replace(/0+$/, \"\");\n          break;\n        default:\n          throw new Error(\"More than one separator found\");\n      }\n    }\n\n    if (fractional.length > decimals) {\n      fractional = fractional.slice(0, decimals);\n    }\n\n    const quantity = `${whole}${fractional.padEnd(decimals, \"0\")}`;\n\n    return new DenominatedNumber(BigInt(quantity), decimals, denomination);\n  }\n\n  override valueOf() {\n    return Number(this.toString());\n  }\n\n  override toString() {\n    const paddedPlanck = this.planck.toString().padStart(this.decimals, \"0\");\n    const whole = paddedPlanck\n      .slice(0, paddedPlanck.length - this.decimals)\n      .padStart(1, \"0\");\n    const fractional = paddedPlanck\n      .slice(paddedPlanck.length - this.decimals)\n      .replace(/0+$/, \"\");\n\n    if (fractional.length === 0) {\n      return whole;\n    } else {\n      return `${whole || \"0\"}.${fractional}`;\n    }\n  }\n\n  override toLocaleString(\n    locales?: string | string[] | undefined,\n    options?: Intl.NumberFormatOptions | undefined,\n  ): string;\n  override toLocaleString(\n    locales?: Intl.LocalesArgument,\n    options?: Intl.NumberFormatOptions | undefined,\n  ): string;\n  override toLocaleString(\n    locales?: Intl.LocalesArgument | string | string[] | undefined,\n    options?: Intl.NumberFormatOptions | undefined,\n  ) {\n    if (this.denomination === undefined) {\n      return this.valueOf().toLocaleString(locales, options);\n    }\n\n    const newOptions: Intl.NumberFormatOptions = options ?? {};\n\n    if (options?.style === undefined) {\n      newOptions.style = \"currency\";\n      newOptions.currency = \"XTS\";\n    }\n\n    return this.valueOf()\n      .toLocaleString(locales, newOptions)\n      .replace(\"XTS\", this.denomination);\n  }\n\n  mapPlanck(mapper: (planck: bigint) => bigint) {\n    return new DenominatedNumber(\n      mapper(this.planck),\n      this.decimals,\n      this.denomination,\n    );\n  }\n\n  /**\n   * @deprecated Use {@link DenominatedNumber.mapPlanck} instead.\n   */\n  mapFromPlanck = this.mapPlanck;\n\n  mapNumber(mapper: (number: number) => number) {\n    return DenominatedNumber.fromNumber(\n      mapper(this.valueOf()),\n      this.decimals,\n      this.denomination,\n    );\n  }\n\n  /**\n   * @deprecated Use {@link DenominatedNumber.mapNumber} instead.\n   */\n  mapFromNumber = this.mapNumber;\n\n  static #verifyDecimals(fractionalDigits: number): void {\n    if (!Number.isInteger(fractionalDigits))\n      throw new Error(\"Decimals is not an integer\");\n    if (fractionalDigits < 0) throw new Error(\"Decimals must not be negative\");\n    if (fractionalDigits > DenominatedNumber.#maxDecimal) {\n      throw new Error(\n        `Decimals must not exceed ${DenominatedNumber.#maxDecimal}`,\n      );\n    }\n  }\n}\n", "import type { ChainHookOptions } from \"./types.js\";\nimport { useChainSpecData } from \"./use-chain-spec-data.js\";\nimport { nativeTokenInfoFromChainSpecData } from \"@reactive-dot/core/internal.js\";\nimport { DenominatedNumber } from \"@reactive-dot/utils\";\nimport { useMemo } from \"react\";\n\n/**\n * Hook for returning the native token amount from a planck value.\n *\n * @group Hooks\n * @param planck - The planck value\n * @param options - Additional options\n * @returns The native token amount\n */\nexport function useNativeTokenAmountFromPlanck(\n  planck: bigint | number | string,\n  options?: ChainHookOptions,\n): DenominatedNumber;\n/**\n * Hook for returning a function that converts planck value to native token amount.\n *\n * @group Hooks\n * @param options - Additional options\n * @returns Function for getting the native token amount from a planck value\n */\nexport function useNativeTokenAmountFromPlanck(\n  options?: ChainHookOptions,\n): (planck: bigint | number | string) => DenominatedNumber;\nexport function useNativeTokenAmountFromPlanck(\n  planckOrOptions?: bigint | number | string | ChainHookOptions,\n  maybeOptions?: ChainHookOptions,\n):\n  | DenominatedNumber\n  | ((planck: bigint | number | string) => DenominatedNumber) {\n  const options =\n    typeof planckOrOptions === \"object\" ? planckOrOptions : maybeOptions;\n\n  const chainSpecData = useChainSpecData(options);\n  const nativeTokenInfo = useMemo(\n    () => nativeTokenInfoFromChainSpecData(chainSpecData),\n    [chainSpecData],\n  );\n\n  return useMemo(\n    () => {\n      switch (typeof planckOrOptions) {\n        case \"bigint\":\n        case \"number\":\n        case \"string\":\n          return new DenominatedNumber(\n            planckOrOptions,\n            nativeTokenInfo.decimals ?? 0,\n            nativeTokenInfo.code,\n          );\n        default:\n          return (planck: bigint | number | string) =>\n            new DenominatedNumber(\n              planck,\n              nativeTokenInfo.decimals ?? 0,\n              nativeTokenInfo.code,\n            );\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [nativeTokenInfo.code, nativeTokenInfo.decimals, typeof planckOrOptions],\n  );\n}\n\n/**\n * Hook for returning the native token amount from a number value\n *\n * @group Hooks\n * @param number - The number value\n * @param options - Additional options\n * @returns The native token amount\n */\nexport function useNativeTokenAmountFromNumber(\n  number: number | string,\n  options?: ChainHookOptions,\n): DenominatedNumber;\n/**\n * Hook for returning a function that converts number value to native token amount\n *\n * @group Hooks\n * @param options - Additional options\n * @returns Function for getting the native token amount from a number value\n */\nexport function useNativeTokenAmountFromNumber(\n  options?: ChainHookOptions,\n): (number: number | string) => DenominatedNumber;\nexport function useNativeTokenAmountFromNumber(\n  numberOrOptions?: number | string | ChainHookOptions,\n  maybeOptions?: ChainHookOptions,\n): DenominatedNumber | ((planck: number) => DenominatedNumber) {\n  const options =\n    typeof numberOrOptions === \"object\" ? numberOrOptions : maybeOptions;\n\n  const chainSpecData = useChainSpecData(options);\n  const nativeTokenInfo = useMemo(\n    () => nativeTokenInfoFromChainSpecData(chainSpecData),\n    [chainSpecData],\n  );\n\n  return useMemo(\n    () => {\n      switch (typeof numberOrOptions) {\n        case \"number\":\n        case \"string\":\n          return DenominatedNumber.fromNumber(\n            numberOrOptions,\n            nativeTokenInfo.decimals ?? 0,\n            nativeTokenInfo.code,\n          );\n        default:\n          return (number: number | string) =>\n            DenominatedNumber.fromNumber(\n              number,\n              nativeTokenInfo.decimals ?? 0,\n              nativeTokenInfo.code,\n            );\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [nativeTokenInfo.code, nativeTokenInfo.decimals, typeof numberOrOptions],\n  );\n}\n", "import { BigIntMath } from \"@reactive-dot/utils\";\n\ntype SpendableBalanceParam = {\n  free: bigint;\n  reserved: bigint;\n  frozen: bigint;\n  existentialDeposit: bigint;\n  includesExistentialDeposit?: boolean;\n};\n\nexport function spendableBalance({\n  free,\n  reserved,\n  frozen,\n  existentialDeposit,\n  includesExistentialDeposit = false,\n}: SpendableBalanceParam) {\n  return BigIntMath.max(\n    0n,\n    free -\n      BigIntMath.max(\n        frozen - reserved,\n        includesExistentialDeposit ? 0n : existentialDeposit,\n      ),\n  );\n}\n", "import type { ChainHookOptions } from \"./types.js\";\nimport { useNativeTokenAmountFromPlanck } from \"./use-native-token-amount.js\";\nimport { useLazyLoadQuery } from \"./use-query.js\";\nimport { spendableBalance } from \"@reactive-dot/core/internal/maths.js\";\nimport { type DenominatedNumber } from \"@reactive-dot/utils\";\nimport type { SS58String } from \"polkadot-api\";\nimport { useMemo } from \"react\";\n\ntype SystemAccount = {\n  nonce: number;\n  consumers: number;\n  providers: number;\n  sufficients: number;\n  data: {\n    free: bigint;\n    reserved: bigint;\n    frozen: bigint;\n    flags: bigint;\n  };\n};\n\ntype Options = ChainHookOptions & {\n  includesExistentialDeposit?: boolean;\n};\n\n/**\n * Hook for getting an account's spendable balance.\n *\n * @group Hooks\n * @param address - The account's address\n * @param options - Additional options\n * @returns The account's spendable balance\n */\nexport function useSpendableBalance(\n  address: SS58String,\n  options?: Options,\n): DenominatedNumber;\n/**\n * Hook for getting accounts spendable balances.\n *\n * @param addresses  - The account-addresses\n * @param options - Additional options\n * @returns The accounts spendable balances\n */\nexport function useSpendableBalance(\n  addresses: SS58String[],\n  options?: Options,\n): DenominatedNumber[];\nexport function useSpendableBalance(\n  addressOrAddresses: SS58String | SS58String[],\n  { includesExistentialDeposit = false, ...options }: Options = {},\n): DenominatedNumber | DenominatedNumber[] {\n  const addresses = Array.isArray(addressOrAddresses)\n    ? addressOrAddresses\n    : [addressOrAddresses];\n\n  const [existentialDeposit, accounts] = useLazyLoadQuery(\n    (builder) =>\n      builder.constant(\"Balances\", \"ExistentialDeposit\").storages(\n        \"System\",\n        \"Account\",\n        addresses.map((address) => [address] as const),\n      ),\n    options,\n  ) as [bigint, SystemAccount[]];\n\n  const nativeTokenFromPlanck = useNativeTokenAmountFromPlanck(options);\n\n  const balances = useMemo(\n    () =>\n      accounts.map(({ data: { free, reserved, frozen } }) =>\n        nativeTokenFromPlanck(\n          spendableBalance({\n            free,\n            reserved,\n            frozen,\n            existentialDeposit,\n            includesExistentialDeposit,\n          }),\n        ),\n      ),\n    [\n      accounts,\n      existentialDeposit,\n      includesExistentialDeposit,\n      nativeTokenFromPlanck,\n    ],\n  );\n\n  return Array.isArray(addressOrAddresses) ? balances : balances[0]!;\n}\n", "import { atomFamilyWithErrorCatcher } from \"../utils/jotai/atom-family-with-error-catcher.js\";\nimport { atomWithObservableAndPromise } from \"../utils/jotai/atom-with-observable-and-promise.js\";\nimport type { ChainHookOptions } from \"./types.js\";\nimport { internal_useChainId } from \"./use-chain-id.js\";\nimport { clientAtom } from \"./use-client.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { usePausableAtomValue } from \"./use-pausable-atom-value.js\";\nimport { type ChainId, type Config } from \"@reactive-dot/core\";\nimport { getBlock } from \"@reactive-dot/core/internal/actions.js\";\nimport { from } from \"rxjs\";\nimport { switchMap } from \"rxjs/operators\";\n\n/**\n * Hook for fetching information about the latest block.\n *\n * @group Hooks\n * @param tag - Which block to target\n * @param options - Additional options\n * @returns The latest finalized or best block\n */\nexport function useBlock(\n  tag: \"best\" | \"finalized\" = \"finalized\",\n  options?: ChainHookOptions,\n) {\n  const config = useConfig();\n  const chainId = internal_useChainId(options);\n\n  return usePausableAtomValue(\n    tag === \"finalized\"\n      ? finalizedBlockAtom(config, chainId)\n      : bestBlockAtom(config, chainId),\n  );\n}\n\n/**\n * @internal\n */\nexport const finalizedBlockAtom = atomFamilyWithErrorCatcher(\n  (withErrorCatcher, config: Config, chainId: ChainId) =>\n    atomWithObservableAndPromise(\n      (get) =>\n        from(get(clientAtom(config, chainId))).pipe(\n          switchMap((client) => getBlock(client, { tag: \"finalized\" })),\n        ),\n      withErrorCatcher,\n    ),\n);\n\n/**\n * @internal\n */\nexport const bestBlockAtom = atomFamilyWithErrorCatcher(\n  (withErrorCatcher, config: Config, chainId: ChainId) =>\n    atomWithObservableAndPromise(\n      (get) =>\n        from(get(clientAtom(config, chainId))).pipe(\n          switchMap((client) => getBlock(client, { tag: \"best\" })),\n        ),\n      withErrorCatcher,\n    ),\n);\n", "import {\n  type MutationEvent,\n  MutationEventSubjectContext,\n} from \"../contexts/mutation.js\";\nimport { use, useEffect } from \"react\";\n\n/**\n * Hook that watches for mutation events.\n *\n * @group Hooks\n * @param effect - Callback when new mutation event is emitted\n */\nexport function useMutationEffect(effect: (event: MutationEvent) => void) {\n  const mutationEventSubject = use(MutationEventSubjectContext);\n\n  useEffect(() => {\n    const subscription = mutationEventSubject.subscribe({ next: effect });\n\n    return () => subscription.unsubscribe();\n  }, [mutationEventSubject, effect]);\n}\n", "import {\n  type AsyncValue,\n  idle,\n  MutationError,\n  pending,\n} from \"@reactive-dot/core\";\nimport { useCallback, useState } from \"react\";\nimport type { Observable } from \"rxjs\";\n\n/**\n * @internal\n * @group Hooks\n */\nexport function useAsyncAction<\n  TArgs extends unknown[],\n  TReturn extends Promise<unknown> | Observable<unknown>,\n>(action: (...args: TArgs) => TReturn) {\n  type Value =\n    TReturn extends Promise<infer Value>\n      ? Value\n      : TReturn extends Observable<infer Value>\n        ? Value\n        : never;\n\n  const [state, setState] = useState<AsyncValue<Value, MutationError>>(idle);\n\n  const execute = useCallback(\n    (...args: TArgs) => {\n      const resolve = (value: unknown) => setState(value as Value);\n\n      const reject = (reason?: unknown) => setState(MutationError.from(reason));\n\n      try {\n        setState(pending);\n\n        const result = action(...args);\n\n        if (result instanceof Promise) {\n          return result.then(resolve).catch(reject);\n        } else {\n          return result.subscribe({ next: resolve, error: reject });\n        }\n      } catch (error) {\n        const mutationError = MutationError.from(error);\n        setState(mutationError);\n        throw mutationError;\n      }\n    },\n    [action, setState],\n  );\n\n  return [state, execute] as [state: typeof state, execute: typeof execute];\n}\n", "import { MutationEventSubjectContext } from \"../contexts/mutation.js\";\nimport { SignerContext } from \"../contexts/signer.js\";\nimport type { ChainHookOptions } from \"./types.js\";\nimport { useAsyncAction } from \"./use-async-action.js\";\nimport { internal_useChainId } from \"./use-chain-id.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { typedApiAtom } from \"./use-typed-api.js\";\nimport type { ChainId } from \"@reactive-dot/core\";\nimport { MutationError, pending } from \"@reactive-dot/core\";\nimport type {\n  ChainDescriptorOf,\n  TxOptionsOf,\n} from \"@reactive-dot/core/internal.js\";\nimport { useAtomCallback } from \"jotai/utils\";\nimport type { PolkadotSigner, Transaction, TypedApi } from \"polkadot-api\";\nimport { use, useCallback } from \"react\";\nimport { from } from \"rxjs\";\nimport { catchError, switchMap, tap } from \"rxjs/operators\";\n\n/**\n * Hook for sending transactions to chains.\n *\n * @group Hooks\n * @param action - The function to create the transaction\n * @param options - Additional options\n * @returns The current transaction state & submit function\n */\nexport function useMutation<\n  TAction extends (\n    tx: TypedApi<ChainDescriptorOf<TChainId>>[\"tx\"],\n  ) => // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Transaction<any, any, any, any>,\n  TChainId extends ChainId | undefined,\n>(\n  action: TAction,\n  options?: ChainHookOptions<TChainId> & {\n    /**\n     * Override default signer\n     */\n    signer?: PolkadotSigner;\n    /**\n     * Additional transaction options\n     */\n    txOptions?: TxOptionsOf<ReturnType<TAction>>;\n  },\n) {\n  const config = useConfig();\n  const chainId = internal_useChainId(options);\n  const mutationEventSubject = use(MutationEventSubjectContext);\n  const contextSigner = use(SignerContext);\n\n  return useAsyncAction(\n    useAtomCallback(\n      useCallback(\n        (\n          get,\n          _set,\n          submitOptions?: {\n            signer?: PolkadotSigner;\n            txOptions?: TxOptionsOf<ReturnType<TAction>>;\n          },\n        ) => {\n          const signer =\n            submitOptions?.signer ?? options?.signer ?? contextSigner;\n\n          if (signer === undefined) {\n            throw new MutationError(\"No signer provided\");\n          }\n\n          const id = globalThis.crypto.randomUUID();\n\n          return from(Promise.resolve(get(typedApiAtom(config, chainId)))).pipe(\n            switchMap((typedApi) => {\n              const transaction = action(typedApi.tx);\n\n              const eventProps = { id, chainId, call: transaction.decodedCall };\n\n              mutationEventSubject.next({ ...eventProps, value: pending });\n\n              return transaction\n                .signSubmitAndWatch(\n                  signer,\n                  submitOptions?.txOptions ?? options?.txOptions,\n                )\n                .pipe(\n                  tap((value) =>\n                    mutationEventSubject.next({ ...eventProps, value }),\n                  ),\n                  catchError((error) => {\n                    mutationEventSubject.next({\n                      ...eventProps,\n                      value: MutationError.from(error),\n                    });\n                    throw error;\n                  }),\n                );\n            }),\n          );\n        },\n        [\n          action,\n          chainId,\n          config,\n          contextSigner,\n          mutationEventSubject,\n          options?.signer,\n          options?.txOptions,\n        ],\n      ),\n    ),\n  );\n}\n", "import { atomFamilyErrorsAtom } from \"../utils/jotai/atom-family-with-error-catcher.js\";\nimport { useAtomCallback } from \"jotai/utils\";\nimport { useCallback } from \"react\";\n\n/**\n * Hook for getting function to reset query error caught by error boundary\n *\n * @group Hooks\n * @returns Function to reset caught query error\n */\nexport function useQueryErrorResetter() {\n  return useAtomCallback(\n    useCallback((get) => {\n      const atomFamilyErrors = get(atomFamilyErrorsAtom);\n\n      for (const error of atomFamilyErrors) {\n        error.atomFamily.delete(error.args);\n        atomFamilyErrors.delete(error);\n      }\n    }, []),\n  );\n}\n", "import type { ChainHookOptions } from \"./types.js\";\nimport { internal_useChainId } from \"./use-chain-id.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { queryPayloadAtom } from \"./use-query.js\";\nimport { type ChainId, Query } from \"@reactive-dot/core\";\nimport type {\n  ChainDescriptorOf,\n  QueryInstruction,\n} from \"@reactive-dot/core/internal.js\";\nimport type { Getter } from \"jotai\";\nimport { useAtomCallback } from \"jotai/utils\";\nimport { useCallback } from \"react\";\n\n/**\n * Hook for loading queries without suspending.\n *\n * @group Hooks\n * @returns The function to load queries\n */\nexport function useQueryLoader() {\n  const config = useConfig();\n  const chainId = internal_useChainId();\n\n  const _loadQuery = useCallback(\n    (get: Getter) =>\n      <\n        TChainId extends ChainId | undefined,\n        TQuery extends (\n          query: Query<[], ChainDescriptorOf<TChainId>>,\n        ) => Query<QueryInstruction[], ChainDescriptorOf<TChainId>>,\n      >(\n        builder: TQuery,\n        options?: ChainHookOptions<TChainId>,\n      ) => {\n        const query = builder(new Query());\n\n        void get(\n          queryPayloadAtom(config, [\n            {\n              query,\n              chainId: options?.chainId ?? chainId,\n            },\n          ]).observableAtom,\n        );\n      },\n    [chainId, config],\n  );\n\n  const loadQuery = useAtomCallback(\n    useCallback(\n      (\n        get,\n        _,\n        builder: <TChainId extends ChainId | undefined>(\n          query: Query<[], ChainDescriptorOf<TChainId>>,\n          options?: ChainHookOptions<TChainId>,\n        ) => Query<[]>,\n      ) => _loadQuery(get)(builder),\n      [_loadQuery],\n    ),\n  );\n\n  return loadQuery as ReturnType<typeof _loadQuery>;\n}\n", "import { SignerContext } from \"../contexts/signer.js\";\nimport { use } from \"react\";\n\n/**\n * Hook for getting the current signer.\n *\n * @group Hooks\n * @returns The current signer\n */\nexport function useSigner() {\n  return use(SignerContext);\n}\n", "import { useAsyncAction } from \"./use-async-action.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { walletsAtom } from \"./use-wallets.js\";\nimport { connectWallet } from \"@reactive-dot/core/internal/actions.js\";\nimport type { Wallet } from \"@reactive-dot/core/wallets.js\";\nimport { useAtomCallback } from \"jotai/utils\";\nimport { useCallback } from \"react\";\n\n/**\n * Hook for connecting wallets\n *\n * @group Hooks\n * @param wallets - Wallets to connect to, will connect to all available wallets if none is specified\n * @returns The wallet connection state & connect function\n */\nexport function useWalletConnector(wallets?: Wallet | Wallet[]) {\n  const hookWallets = wallets;\n  const config = useConfig();\n\n  return useAsyncAction(\n    useAtomCallback(\n      useCallback(\n        async (get, _, wallets?: Wallet | Wallet[]) => {\n          const walletsToConnect =\n            wallets ?? hookWallets ?? (await get(walletsAtom(config)));\n          await connectWallet(walletsToConnect);\n          return true as const;\n        },\n        [config, hookWallets],\n      ),\n    ),\n  );\n}\n", "import { useAsyncAction } from \"./use-async-action.js\";\nimport { useConfig } from \"./use-config.js\";\nimport { walletsAtom } from \"./use-wallets.js\";\nimport { disconnectWallet } from \"@reactive-dot/core/internal/actions.js\";\nimport type { Wallet } from \"@reactive-dot/core/wallets.js\";\nimport { useAtomCallback } from \"jotai/utils\";\nimport { useCallback } from \"react\";\n\n/**\n * Hook for disconnecting wallets\n *\n * @group Hooks\n * @param wallets - Wallets to disconnect from, will disconnect from all connected wallets if none is specified\n * @returns The wallet disconnection state & disconnect function\n */\nexport function useWalletDisconnector(wallets?: Wallet | Wallet[]) {\n  const hookWallets = wallets;\n\n  const config = useConfig();\n\n  return useAsyncAction(\n    useAtomCallback(\n      useCallback(\n        async (get, _, wallets?: Wallet | Wallet[]) => {\n          const walletsToDisconnect =\n            wallets ?? hookWallets ?? (await get(walletsAtom(config)));\n          await disconnectWallet(walletsToDisconnect);\n          return true as const;\n        },\n        [config, hookWallets],\n      ),\n    ),\n  );\n}\n"],
  "mappings": "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",
  "names": ["empty", "atom", "atom", "isPromiseLike", "React", "atom", "args", "getBuildingBlocks", "aState", "empty", "import_react", "import_react", "import_react", "import_react", "_jsx", "useAtomValue", "atom", "import_react", "useAtomValue", "import_react", "_jsx", "import_react", "import_react", "import_react", "query", "atom", "import_react", "import_react", "useAtomValue", "process", "useAtomValue", "import_react", "options", "atom", "query", "atoms", "atomOrAtoms", "query", "import_react", "useAtomValue", "import_react", "import_react", "import_react", "_jsx", "_jsxs", "import_react", "_jsx", "useAtomValue", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "query", "import_react", "import_react", "wallets", "import_react", "wallets"]
}
