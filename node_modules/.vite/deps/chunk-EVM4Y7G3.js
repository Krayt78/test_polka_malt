import {
  __export
} from "./chunk-B4Q33VKO.js";

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/types/enum.mjs
var discriminant = {
  is(value, type) {
    return value.type === type;
  },
  as(value, type) {
    if (type !== value.type)
      throw new Error(
        `Enum.as(enum, ${type}) used with actual type ${value.type}`
      );
    return value;
  }
};
var Enum = Object.assign((type, value) => {
  return {
    type,
    value
  };
}, discriminant);
var _Enum = new Proxy(
  {},
  {
    get(_, prop) {
      return (value) => Enum(prop, value);
    }
  }
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/index.mjs
var esm_exports = {};
__export(esm_exports, {
  AccountId: () => AccountId,
  Bin: () => Bin,
  Binary: () => Binary,
  Blake2128: () => Blake2128,
  Blake2128Concat: () => Blake2128Concat,
  Blake2256: () => Blake2256,
  Blake3256: () => Blake3256,
  Blake3256Concat: () => Blake3256Concat,
  Bytes: () => Bytes,
  Enum: () => Enum,
  FixedSizeBinary: () => FixedSizeBinary,
  Hex: () => Hex,
  Identity: () => Identity,
  Option: () => Option2,
  Result: () => Result2,
  ScaleEnum: () => ScaleEnum,
  Self: () => Self,
  Storage: () => Storage,
  Struct: () => Struct2,
  Tuple: () => Tuple2,
  Twox128: () => Twox128,
  Twox256: () => Twox256,
  Twox64Concat: () => Twox64Concat,
  Variant: () => Variant,
  Vector: () => Vector2,
  _Enum: () => _Enum,
  _void: () => _void,
  bitSequence: () => bitSequence,
  blockHeader: () => blockHeader,
  bool: () => bool,
  char: () => char,
  compact: () => compact,
  compactBn: () => compactBn,
  compactNumber: () => compactNumber,
  createCodec: () => createCodec,
  createDecoder: () => createDecoder,
  decAnyMetadata: () => decAnyMetadata,
  enhanceCodec: () => enhanceCodec,
  enhanceDecoder: () => enhanceDecoder,
  enhanceEncoder: () => enhanceEncoder,
  ethAccount: () => ethAccount,
  fixedStr: () => fixedStr,
  fromBufferToBase58: () => fromBufferToBase58,
  getMultisigAccountId: () => getMultisigAccountId,
  getSs58AddressInfo: () => getSs58AddressInfo,
  h64: () => h64,
  i128: () => i128,
  i16: () => i16,
  i256: () => i256,
  i32: () => i32,
  i64: () => i64,
  i8: () => i8,
  metadata: () => metadata,
  selfDecoder: () => selfDecoder,
  selfEncoder: () => selfEncoder,
  sortMultisigSignatories: () => sortMultisigSignatories,
  str: () => str,
  u128: () => u128,
  u16: () => u16,
  u256: () => u256,
  u32: () => u32,
  u64: () => u64,
  u8: () => u8,
  unifyMetadata: () => unifyMetadata,
  v14: () => v14,
  v14Lookup: () => lookup,
  v15: () => v15,
  v16: () => v16
});

// node_modules/.pnpm/scale-ts@1.6.1/node_modules/scale-ts/dist/scale-ts.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var HEX_MAP = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
function fromHex(hexString) {
  const isOdd = hexString.length % 2;
  const base = (hexString[1] === "x" ? 2 : 0) + isOdd;
  const nBytes = (hexString.length - base) / 2 + isOdd;
  const bytes = new Uint8Array(nBytes);
  if (isOdd)
    bytes[0] = 0 | HEX_MAP[hexString[2]];
  for (let i = 0; i < nBytes; ) {
    const idx = base + i * 2;
    const a = HEX_MAP[hexString[idx]];
    const b = HEX_MAP[hexString[idx + 1]];
    bytes[isOdd + i++] = a << 4 | b;
  }
  return bytes;
}
var InternalUint8Array = class extends Uint8Array {
  constructor(buffer) {
    super(buffer);
    __publicField(this, "i", 0);
    __publicField(this, "v");
    this.v = new DataView(buffer);
  }
};
var toInternalBytes = (fn) => (buffer) => fn(buffer instanceof InternalUint8Array ? buffer : new InternalUint8Array(buffer instanceof Uint8Array ? buffer.buffer : typeof buffer === "string" ? fromHex(buffer).buffer : buffer));
var mergeUint8 = (inputs) => {
  const len = inputs.length;
  let totalLen = 0;
  for (let i = 0; i < len; i++)
    totalLen += inputs[i].length;
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < len; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};
function mapObject(input, mapper) {
  const keys = Object.keys(input);
  const len = keys.length;
  const result = {};
  for (let i = 0; i < len; i++) {
    const key = keys[i];
    result[key] = mapper(input[key], key);
  }
  return result;
}
var createDecoder = toInternalBytes;
var createCodec = (encoder, decoder) => {
  const result = [encoder, decoder];
  result.enc = encoder;
  result.dec = decoder;
  return result;
};
var enhanceEncoder = (encoder, mapper) => (value) => encoder(mapper(value));
var enhanceDecoder = (decoder, mapper) => (value) => mapper(decoder(value));
var enhanceCodec = ([encoder, decoder], toFrom, fromTo) => createCodec(enhanceEncoder(encoder, toFrom), enhanceDecoder(decoder, fromTo));
function decodeInt(nBytes, getter) {
  return toInternalBytes((bytes) => {
    const result = bytes.v[getter](bytes.i, true);
    bytes.i += nBytes;
    return result;
  });
}
function encodeInt(nBytes, setter) {
  return (input) => {
    const result = new Uint8Array(nBytes);
    const dv = new DataView(result.buffer);
    dv[setter](0, input, true);
    return result;
  };
}
function intCodec(nBytes, getter, setter) {
  return createCodec(encodeInt(nBytes, setter), decodeInt(nBytes, getter));
}
var u8 = intCodec(1, "getUint8", "setUint8");
var u16 = intCodec(2, "getUint16", "setUint16");
var u32 = intCodec(4, "getUint32", "setUint32");
var u64 = intCodec(8, "getBigUint64", "setBigUint64");
var i8 = intCodec(1, "getInt8", "setInt8");
var i16 = intCodec(2, "getInt16", "setInt16");
var i32 = intCodec(4, "getInt32", "setInt32");
var i64 = intCodec(8, "getBigInt64", "setBigInt64");
var x128Enc = (value) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigInt64(0, value, true);
  dv.setBigInt64(8, value >> 64n, true);
  return result;
};
var create128Dec = (method) => toInternalBytes((input) => {
  const { v, i } = input;
  const right = v.getBigUint64(i, true);
  const left = v[method](i + 8, true);
  input.i += 16;
  return left << 64n | right;
});
var u128 = createCodec(x128Enc, create128Dec("getBigUint64"));
var i128 = createCodec(x128Enc, create128Dec("getBigInt64"));
var x256Enc = (value) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigInt64(0, value, true);
  dv.setBigInt64(8, value >> 64n, true);
  dv.setBigInt64(16, value >> 128n, true);
  dv.setBigInt64(24, value >> 192n, true);
  return result;
};
var create256Dec = (method) => toInternalBytes((input) => {
  let result = input.v.getBigUint64(input.i, true);
  input.i += 8;
  result |= input.v.getBigUint64(input.i, true) << 64n;
  input.i += 8;
  result |= input.v.getBigUint64(input.i, true) << 128n;
  input.i += 8;
  result |= input.v[method](input.i, true) << 192n;
  input.i += 8;
  return result;
});
var u256 = createCodec(x256Enc, create256Dec("getBigUint64"));
var i256 = createCodec(x256Enc, create256Dec("getBigInt64"));
var bool = enhanceCodec(u8, (value) => value ? 1 : 0, Boolean);
var decoders = [u8[1], u16[1], u32[1]];
var compactDec = toInternalBytes((bytes) => {
  const init = bytes[bytes.i];
  const kind = init & 3;
  if (kind < 3)
    return decoders[kind](bytes) >>> 2;
  const nBytes = (init >>> 2) + 4;
  bytes.i++;
  let result = 0n;
  const nU64 = nBytes / 8 | 0;
  let shift = 0n;
  for (let i = 0; i < nU64; i++) {
    result = u64[1](bytes) << shift | result;
    shift += 64n;
  }
  let nReminders = nBytes % 8;
  if (nReminders > 3) {
    result = BigInt(u32[1](bytes)) << shift | result;
    shift += 32n;
    nReminders -= 4;
  }
  if (nReminders > 1) {
    result = BigInt(u16[1](bytes)) << shift | result;
    shift += 16n;
    nReminders -= 2;
  }
  if (nReminders)
    result = BigInt(u8[1](bytes)) << shift | result;
  return result;
});
var MIN_U64 = 1n << 56n;
var MIN_U32 = 1 << 24;
var MIN_U16 = 256;
var U32_MASK = 4294967295n;
var SINGLE_BYTE_MODE_LIMIT = 1 << 6;
var TWO_BYTE_MODE_LIMIT = 1 << 14;
var FOUR_BYTE_MODE_LIMIT = 1 << 30;
var compactEnc = (input) => {
  if (input < 0)
    throw new Error(`Wrong compact input (${input})`);
  const nInput = Number(input) << 2;
  if (input < SINGLE_BYTE_MODE_LIMIT)
    return u8[0](nInput);
  if (input < TWO_BYTE_MODE_LIMIT)
    return u16[0](nInput | 1);
  if (input < FOUR_BYTE_MODE_LIMIT)
    return u32[0](nInput | 2);
  let buffers = [new Uint8Array(1)];
  let bigValue = BigInt(input);
  while (bigValue >= MIN_U64) {
    buffers.push(u64[0](bigValue));
    bigValue >>= 64n;
  }
  if (bigValue >= MIN_U32) {
    buffers.push(u32[0](Number(bigValue & U32_MASK)));
    bigValue >>= 32n;
  }
  let smValue = Number(bigValue);
  if (smValue >= MIN_U16) {
    buffers.push(u16[0](smValue));
    smValue >>= 16;
  }
  smValue && buffers.push(u8[0](smValue));
  const result = mergeUint8(buffers);
  result[0] = result.length - 5 << 2 | 3;
  return result;
};
var compact = createCodec(compactEnc, compactDec);
var textEncoder = new TextEncoder();
var strEnc = (str2) => {
  const val = textEncoder.encode(str2);
  return mergeUint8([compact.enc(val.length), val]);
};
var textDecoder = new TextDecoder();
var strDec = toInternalBytes((bytes) => {
  let nElements = compact.dec(bytes);
  const dv = new DataView(bytes.buffer, bytes.i, nElements);
  bytes.i += nElements;
  return textDecoder.decode(dv);
});
var str = createCodec(strEnc, strDec);
var noop = () => {
};
var emptyArr = new Uint8Array(0);
var _void = createCodec(() => emptyArr, noop);
var BytesEnc = (nBytes) => nBytes === void 0 ? (bytes) => mergeUint8([compact.enc(bytes.length), bytes]) : (bytes) => bytes.length === nBytes ? bytes : bytes.slice(0, nBytes);
var BytesDec = (nBytes) => toInternalBytes((bytes) => {
  const len = nBytes === void 0 ? compact.dec(bytes) : nBytes !== Infinity ? nBytes : bytes.byteLength - bytes.i;
  const result = new Uint8Array(bytes.buffer.slice(bytes.i, bytes.i + len));
  bytes.i += len;
  return result;
});
var Bytes = (nBytes) => createCodec(BytesEnc(nBytes), BytesDec(nBytes));
Bytes.enc = BytesEnc;
Bytes.dec = BytesDec;
var enumEnc = (inner, x) => {
  const keys = Object.keys(inner);
  const mappedKeys = new Map((x == null ? void 0 : x.map((actualIdx, idx) => [keys[idx], actualIdx])) ?? keys.map((key, idx) => [key, idx]));
  const getKey = (key) => mappedKeys.get(key);
  return ({ tag, value }) => mergeUint8([u8.enc(getKey(tag)), inner[tag](value)]);
};
var enumDec = (inner, x) => {
  const keys = Object.keys(inner);
  const mappedKeys = new Map((x == null ? void 0 : x.map((actualIdx, idx) => [actualIdx, keys[idx]])) ?? keys.map((key, idx) => [idx, key]));
  return toInternalBytes((bytes) => {
    const idx = u8.dec(bytes);
    const tag = mappedKeys.get(idx);
    const innerDecoder = inner[tag];
    return {
      tag,
      value: innerDecoder(bytes)
    };
  });
};
var Enum2 = (inner, ...args) => createCodec(enumEnc(mapObject(inner, ([encoder]) => encoder), ...args), enumDec(mapObject(inner, ([, decoder]) => decoder), ...args));
Enum2.enc = enumEnc;
Enum2.dec = enumDec;
var OptionDec = (inner) => toInternalBytes((bytes) => u8[1](bytes) > 0 ? inner(bytes) : void 0);
var OptionEnc = (inner) => (value) => {
  const result = new Uint8Array(1);
  if (value === void 0)
    return result;
  result[0] = 1;
  return mergeUint8([result, inner(value)]);
};
var Option = (inner) => createCodec(OptionEnc(inner[0]), OptionDec(inner[1]));
Option.enc = OptionEnc;
Option.dec = OptionDec;
var ResultDec = (okDecoder, koDecoder) => toInternalBytes((bytes) => {
  const success = u8[1](bytes) === 0;
  const decoder = success ? okDecoder : koDecoder;
  const value = decoder(bytes);
  return { success, value };
});
var ResultEnc = (okEncoder, koEncoder) => ({ success, value }) => mergeUint8([
  u8[0](success ? 0 : 1),
  (success ? okEncoder : koEncoder)(value)
]);
var Result = (okCodec, koCodec) => createCodec(ResultEnc(okCodec[0], koCodec[0]), ResultDec(okCodec[1], koCodec[1]));
Result.dec = ResultDec;
Result.enc = ResultEnc;
var TupleDec = (...decoders2) => toInternalBytes((bytes) => decoders2.map((decoder) => decoder(bytes)));
var TupleEnc = (...encoders) => (values) => mergeUint8(encoders.map((enc3, idx) => enc3(values[idx])));
var Tuple = (...codecs) => createCodec(TupleEnc(...codecs.map(([encoder]) => encoder)), TupleDec(...codecs.map(([, decoder]) => decoder)));
Tuple.enc = TupleEnc;
Tuple.dec = TupleDec;
var StructEnc = (encoders) => {
  const keys = Object.keys(encoders);
  return enhanceEncoder(Tuple.enc(...Object.values(encoders)), (input) => keys.map((k) => input[k]));
};
var StructDec = (decoders2) => {
  const keys = Object.keys(decoders2);
  return enhanceDecoder(Tuple.dec(...Object.values(decoders2)), (tuple) => Object.fromEntries(tuple.map((value, idx) => [keys[idx], value])));
};
var Struct = (codecs) => createCodec(StructEnc(mapObject(codecs, (x) => x[0])), StructDec(mapObject(codecs, (x) => x[1])));
Struct.enc = StructEnc;
Struct.dec = StructDec;
var VectorEnc = (inner, size) => size >= 0 ? (value) => mergeUint8(value.map(inner)) : (value) => mergeUint8([compact.enc(value.length), mergeUint8(value.map(inner))]);
var VectorDec = (getter, size) => toInternalBytes((bytes) => {
  const nElements = size >= 0 ? size : compact.dec(bytes);
  const result = new Array(nElements);
  for (let i = 0; i < nElements; i++) {
    result[i] = getter(bytes);
  }
  return result;
});
var Vector = (inner, size) => createCodec(VectorEnc(inner[0], size), VectorDec(inner[1], size));
Vector.enc = VectorEnc;
Vector.dec = VectorDec;

// node_modules/.pnpm/@scure+base@1.2.5/node_modules/@scure/base/lib/esm/index.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf(isString, arr2) {
  if (!Array.isArray(arr2))
    return false;
  if (arr2.length === 0)
    return true;
  if (isString) {
    return arr2.every((item) => typeof item === "string");
  } else {
    return arr2.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  afn(fn);
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
var radix2carry = (from, to) => from + (to - gcd(from, to));
var powers = (() => {
  let res = [];
  for (let i = 0; i < 40; i++)
    res.push(2 ** i);
  return res;
})();
function convertRadix2(data, from, to, padding2) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from];
  const mask = powers[to] - 1;
  const res = [];
  for (const n of data) {
    anumber(n);
    if (n >= max)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var base64 = hasBase64Builtin ? {
  encode(b) {
    abytes(b);
    return b.toBase64();
  },
  decode(s) {
    astr("base64", s);
    return Uint8Array.fromBase64(s, { lastChunkHandling: "strict" });
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b) {
    abytes(b);
    return b.toBase64({ alphabet: "base64url" });
  },
  decode(s) {
    astr("base64", s);
    return Uint8Array.fromBase64(s, { alphabet: "base64url" });
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str2, limit = 90) {
    astr("bech32.decode input", str2);
    const slen = str2.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str2}). Expected (8..${limit})`);
    const lowered = str2.toLowerCase();
    if (str2 !== lowered && str2 !== str2.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str2}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str2) {
    const { prefix, words } = decode(str2, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes(data);
    return data.toHex();
  },
  decode(s) {
    astr("hex", s);
    return Uint8Array.fromHex(s);
  }
};
var hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes2(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u82(arr2) {
  return new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength);
}
function u322(arr2) {
  return new Uint32Array(arr2.buffer, arr2.byteOffset, Math.floor(arr2.byteLength / 4));
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
var swap8IfBE = isLE ? (n) => n : (n) => byteSwap(n);
function byteSwap32(arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr2[i] = byteSwap(arr2[i]);
  }
  return arr2;
}
var swap32IfBE = isLE ? (u) => u : byteSwap32;
var hasHexBuiltin2 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str2) {
  if (typeof str2 !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str2));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes2(data);
  return data;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function createOptHasher(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function createXOFer(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_blake.js
var BSIGMA = Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
function G1s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 16);
  c = c + d | 0;
  b = rotr(b ^ c, 12);
  return { a, b, c, d };
}
function G2s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 8);
  c = c + d | 0;
  b = rotr(b ^ c, 7);
  return { a, b, c, d };
}

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js
var SHA256_IV = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2.js
var B2B_IV = Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = new Uint32Array(32);
function G1b(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
  anumber2(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key, salt, personalization } = opts;
  if (key !== void 0 && (key.length < 1 || key.length > keyLen))
    throw new Error("key length must be undefined or 1.." + keyLen);
  if (salt !== void 0 && salt.length !== saltLen)
    throw new Error("salt must be undefined or " + saltLen);
  if (personalization !== void 0 && personalization.length !== persLen)
    throw new Error("personalization must be undefined or " + persLen);
}
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen) {
    super();
    this.finished = false;
    this.destroyed = false;
    this.length = 0;
    this.pos = 0;
    anumber2(blockLen);
    anumber2(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u322(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes2(data);
    const { blockLen, buffer, buffer32 } = this;
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u322(out);
    this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.buffer.set(buffer);
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    to.outputLen = outputLen;
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
    super(128, olen);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    checkBlake2Opts(olen, opts, 64, 16, 16);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes(key);
      keyLength = key.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes(salt);
      const slt = u322(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      personalization = toBytes(personalization);
      const pers = u322(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BBUF[i] = v);
    BBUF.set(B2B_IV, 16);
    let { h, l } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j = 0;
    const s = BSIGMA;
    for (let i = 0; i < 12; i++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = createOptHasher((opts) => new BLAKE2b(opts));
function compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v142, v152) {
  let j = 0;
  for (let i = 0; i < rounds; i++) {
    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));
    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));
    ({ a: v2, b: v6, c: v10, d: v142 } = G1s(v2, v6, v10, v142, msg[offset + s[j++]]));
    ({ a: v2, b: v6, c: v10, d: v142 } = G2s(v2, v6, v10, v142, msg[offset + s[j++]]));
    ({ a: v3, b: v7, c: v11, d: v152 } = G1s(v3, v7, v11, v152, msg[offset + s[j++]]));
    ({ a: v3, b: v7, c: v11, d: v152 } = G2s(v3, v7, v11, v152, msg[offset + s[j++]]));
    ({ a: v0, b: v5, c: v10, d: v152 } = G1s(v0, v5, v10, v152, msg[offset + s[j++]]));
    ({ a: v0, b: v5, c: v10, d: v152 } = G2s(v0, v5, v10, v152, msg[offset + s[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));
    ({ a: v3, b: v4, c: v9, d: v142 } = G1s(v3, v4, v9, v142, msg[offset + s[j++]]));
    ({ a: v3, b: v4, c: v9, d: v142 } = G2s(v3, v4, v9, v142, msg[offset + s[j++]]));
  }
  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 };
}
var B2S_IV = SHA256_IV;
var BLAKE2s = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 32 : opts.dkLen;
    super(64, olen);
    this.v0 = B2S_IV[0] | 0;
    this.v1 = B2S_IV[1] | 0;
    this.v2 = B2S_IV[2] | 0;
    this.v3 = B2S_IV[3] | 0;
    this.v4 = B2S_IV[4] | 0;
    this.v5 = B2S_IV[5] | 0;
    this.v6 = B2S_IV[6] | 0;
    this.v7 = B2S_IV[7] | 0;
    checkBlake2Opts(olen, opts, 32, 8, 8);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes(key);
      keyLength = key.length;
    }
    this.v0 ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes(salt);
      const slt = u322(salt);
      this.v4 ^= swap8IfBE(slt[0]);
      this.v5 ^= swap8IfBE(slt[1]);
    }
    if (personalization !== void 0) {
      personalization = toBytes(personalization);
      const pers = u322(personalization);
      this.v6 ^= swap8IfBE(pers[0]);
      this.v7 ^= swap8IfBE(pers[1]);
    }
    if (key !== void 0) {
      abytes2(key);
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  get() {
    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;
    return [v0, v1, v2, v3, v4, v5, v6, v7];
  }
  // prettier-ignore
  set(v0, v1, v2, v3, v4, v5, v6, v7) {
    this.v0 = v0 | 0;
    this.v1 = v1 | 0;
    this.v2 = v2 | 0;
    this.v3 = v3 | 0;
    this.v4 = v4 | 0;
    this.v5 = v5 | 0;
    this.v6 = v6 | 0;
    this.v7 = v7 | 0;
  }
  compress(msg, offset, isLast) {
    const { h, l } = fromBig(BigInt(this.length));
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 } = compress(BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);
    this.v0 ^= v0 ^ v8;
    this.v1 ^= v1 ^ v9;
    this.v2 ^= v2 ^ v10;
    this.v3 ^= v3 ^ v11;
    this.v4 ^= v4 ^ v12;
    this.v5 ^= v5 ^ v13;
    this.v6 ^= v6 ^ v142;
    this.v7 ^= v7 ^ v152;
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2s = createOptHasher((opts) => new BLAKE2s(opts));

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2b.js
var blake2b2 = blake2b;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/utils/ss58-util.mjs
var SS58_PREFIX = new TextEncoder().encode("SS58PRE");
var CHECKSUM_LENGTH = 2;
var getSs58AddressInfo = (address) => {
  try {
    const decoded = base58.decode(address);
    const prefixBytes = decoded.subarray(0, decoded[0] & 64 ? 2 : 1);
    const publicKey = decoded.subarray(
      prefixBytes.length,
      decoded.length - CHECKSUM_LENGTH
    );
    const checksum = decoded.subarray(prefixBytes.length + publicKey.length);
    const expectedChecksum = blake2b2(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    const isChecksumValid = checksum[0] === expectedChecksum[0] && checksum[1] === expectedChecksum[1];
    if (!isChecksumValid) return { isValid: false };
    return {
      isValid: true,
      ss58Format: prefixBytesToNumber(prefixBytes),
      publicKey: publicKey.slice()
    };
  } catch (_) {
    return { isValid: false };
  }
};
var prefixBytesToNumber = (bytes) => {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0);
};
var fromBufferToBase58 = (ss58Format) => {
  const prefixBytes = ss58Format < 64 ? Uint8Array.of(ss58Format) : Uint8Array.of(
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  );
  return (publicKey) => {
    const checksum = blake2b2(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    return base58.encode(
      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum)
    );
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/AccountId.mjs
function fromBase58ToBuffer(nBytes, _ss58Format) {
  return (address) => {
    const info = getSs58AddressInfo(address);
    if (!info.isValid) throw new Error("Invalid checksum");
    const { publicKey } = info;
    if (publicKey.length !== nBytes)
      throw new Error("Invalid public key length");
    return publicKey;
  };
}
var AccountId = (ss58Format = 42, nBytes = 32) => enhanceCodec(
  Bytes(nBytes),
  fromBase58ToBuffer(nBytes),
  fromBufferToBase58(ss58Format)
);

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/hex.mjs
var HEX_STR = "0123456789abcdef";
function toHex(bytes) {
  const result = new Array(bytes.length + 1);
  result[0] = "0x";
  for (let i = 0; i < bytes.length; ) {
    const b = bytes[i++];
    result[i] = HEX_STR[b >> 4] + HEX_STR[b & 15];
  }
  return result.join("");
}
var HEX_MAP2 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
function fromHex2(hexString) {
  const isOdd = hexString.length % 2;
  const base = (hexString[1] === "x" ? 2 : 0) + isOdd;
  const nBytes = (hexString.length - base) / 2 + isOdd;
  const bytes = new Uint8Array(nBytes);
  if (isOdd) bytes[0] = 0 | HEX_MAP2[hexString[2]];
  for (let i = 0; i < nBytes; ) {
    const idx = base + i * 2;
    const a = HEX_MAP2[hexString[idx]];
    const b = HEX_MAP2[hexString[idx + 1]];
    bytes[isOdd + i++] = a << 4 | b;
  }
  return bytes;
}

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/mapObject.mjs
function mapObject2(input, mapper) {
  return Object.fromEntries(
    Object.entries(input).map(
      ([key, value]) => [key, mapper(value, key)]
    )
  );
}

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/mergeUint8.mjs
var mergeUint82 = (...inputs) => {
  const totalLen = inputs.reduce((acc, a) => acc + a.byteLength, 0);
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < inputs.length; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/noop.mjs
var noop2 = Function.prototype;

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/AbortError.mjs
var AbortError = class extends Error {
  constructor() {
    super("Abort Error");
    this.name = "AbortError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Binary.mjs
var __defProp2 = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _bytes;
var _opaqueBytes;
var _hex;
var _opaqueHex;
var _str;
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var opaqueBytesDec = Tuple(compact, Bytes(Infinity))[1];
var Binary = class {
  constructor(data, opaque = false) {
    __privateAdd(this, _bytes);
    __privateAdd(this, _opaqueBytes, null);
    __privateAdd(this, _hex, null);
    __privateAdd(this, _opaqueHex, null);
    __privateAdd(this, _str, null);
    __publicField2(this, "asText", () => __privateGet(this, _str) ?? __privateSet(this, _str, textDecoder2.decode(__privateGet(this, _bytes))));
    __publicField2(this, "asHex", () => __privateGet(this, _hex) || __privateSet(this, _hex, toHex(__privateGet(this, _bytes))));
    __publicField2(this, "asOpaqueHex", () => __privateGet(this, _opaqueHex) || __privateSet(this, _opaqueHex, toHex(this.asBytes())));
    __publicField2(this, "asBytes", () => __privateGet(this, _bytes));
    __publicField2(this, "asOpaqueBytes", () => __privateGet(this, _opaqueBytes) || __privateSet(this, _opaqueBytes, mergeUint82(
      compact[0](__privateGet(this, _bytes).length),
      __privateGet(this, _bytes)
    )));
    if (opaque) {
      try {
        const [len, bytes] = opaqueBytesDec(data);
        if (len === bytes.length) {
          __privateSet(this, _bytes, bytes);
          __privateSet(this, _opaqueBytes, data);
          return;
        }
      } catch (_) {
      }
      throw new Error("Invalid opaque bytes");
    } else __privateSet(this, _bytes, data);
  }
  static fromText(input) {
    return new this(textEncoder2.encode(input));
  }
  static fromHex(input) {
    return new this(fromHex2(input));
  }
  static fromOpaqueHex(input) {
    return new this(fromHex2(input), true);
  }
  static fromBytes(input) {
    return new this(input);
  }
  static fromOpaqueBytes(input) {
    return new this(input, true);
  }
};
_bytes = /* @__PURE__ */ new WeakMap();
_opaqueBytes = /* @__PURE__ */ new WeakMap();
_hex = /* @__PURE__ */ new WeakMap();
_opaqueHex = /* @__PURE__ */ new WeakMap();
_str = /* @__PURE__ */ new WeakMap();
var [accountIdEncoder] = AccountId();
var FixedSizeBinary = class extends Binary {
  constructor(data) {
    super(data);
  }
  static fromArray(input) {
    return new this(new Uint8Array(input));
  }
  static fromAccountId32(input) {
    return new this(accountIdEncoder(input));
  }
};
var enc = (nBytes) => {
  const _enc = Bytes.enc(nBytes);
  return (value) => _enc(value.asBytes());
};
var dec = (nBytes) => {
  const _dec = Bytes.dec(nBytes);
  const Bin2 = nBytes == null ? Binary : FixedSizeBinary;
  return (value) => Bin2.fromBytes(_dec(value));
};
var Bin = (nBytes) => createCodec(enc(nBytes), dec(nBytes));
Bin.enc = enc;
Bin.dec = dec;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/compact.mjs
var compactNumber = enhanceCodec(compact, (v) => v, Number);
var compactBn = enhanceCodec(compact, (v) => v, BigInt);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/bitSequence.mjs
var bitSequenceDecoder = createDecoder((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = Bytes(bytesLen).dec(data);
  return { bytes, bitsLen };
});
var bitSequenceEncoder = (input) => {
  if (input.bitsLen > input.bytes.length * 8)
    throw new Error(
      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`
    );
  const lenEncoded = compactNumber.enc(input.bitsLen);
  const result = new Uint8Array(input.bytes.length + lenEncoded.length);
  result.set(lenEncoded, 0);
  result.set(input.bytes, lenEncoded.length);
  return result;
};
var bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/char.mjs
var char = enhanceCodec(
  u8,
  (str2) => str2.charCodeAt(0),
  String.fromCharCode
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Hex.mjs
var enc2 = (nBytes) => {
  const _enc = Bytes.enc(nBytes);
  return (value) => _enc(fromHex2(value));
};
var dec2 = (nBytes) => {
  const _dec = Bytes.dec(nBytes);
  return (value) => toHex(_dec(value));
};
var Hex = (nBytes) => createCodec(enc2(nBytes), dec2(nBytes));
Hex.enc = enc2;
Hex.dec = dec2;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/fixed-str.mjs
var textEncoder3 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var fixedStr = (nBytes) => enhanceCodec(
  Bytes(nBytes),
  (str2) => textEncoder3.encode(str2),
  (bytes) => textDecoder3.decode(bytes)
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Self.mjs
var selfEncoder = (value) => {
  let cache = (x) => {
    const encoder = value();
    cache = encoder;
    return encoder(x);
  };
  return (x) => cache(x);
};
var selfDecoder = (value) => {
  let cache = (x) => {
    const decoder = value();
    const result = decoder;
    cache = decoder;
    return result(x);
  };
  return (x) => cache(x);
};
var Self = (value) => createCodec(
  selfEncoder(() => value().enc),
  selfDecoder(() => value().dec)
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/with-inner.mjs
var withInner = (codec, inner) => {
  const result = codec;
  result.inner = inner;
  return result;
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Variant.mjs
var VariantEnc = (...args) => {
  const enc3 = Enum2.enc(...args);
  return withInner((v) => enc3({ tag: v.type, value: v.value }), args[0]);
};
var VariantDec = (...args) => {
  const dec3 = Enum2.dec(...args);
  return withInner((v) => {
    const { tag, value } = dec3(v);
    return Enum(tag, value);
  }, args[0]);
};
var Variant = (inner, ...args) => withInner(
  createCodec(
    VariantEnc(
      mapObject2(inner, ([encoder]) => encoder),
      ...args
    ),
    VariantDec(
      mapObject2(inner, ([, decoder]) => decoder),
      ...args
    )
  ),
  inner
);
Variant.enc = VariantEnc;
Variant.dec = VariantDec;
var ScaleEnum = (inner, ...args) => withInner(Enum2(inner, ...args), inner);
ScaleEnum.enc = (inner, ...rest) => withInner(Enum2.enc(inner, ...rest), inner);
ScaleEnum.dec = (inner, ...rest) => withInner(Enum2.dec(inner, ...rest), inner);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha3.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  clean(B);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber2(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u322(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes2(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes2(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber2(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = (() => gen(6, 144, 224 / 8))();
var sha3_256 = (() => gen(6, 136, 256 / 8))();
var sha3_384 = (() => gen(6, 104, 384 / 8))();
var sha3_512 = (() => gen(6, 72, 512 / 8))();
var keccak_224 = (() => gen(1, 144, 224 / 8))();
var keccak_256 = (() => gen(1, 136, 256 / 8))();
var keccak_384 = (() => gen(1, 104, 384 / 8))();
var keccak_512 = (() => gen(1, 72, 512 / 8))();
var genShake = (suffix, blockLen, outputLen) => createXOFer((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = (() => genShake(31, 168, 128 / 8))();
var shake256 = (() => genShake(31, 136, 256 / 8))();

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/ethAccount.mjs
var getFormattedAddress = (hexAddress) => {
  const nonChecksum = hexAddress.slice(2);
  const hashedAddress = toHex(keccak_256(nonChecksum)).slice(2);
  const result = new Array(40);
  for (let i = 0; i < 40; i++) {
    const checksumVal = parseInt(hashedAddress[i], 16);
    const char2 = nonChecksum[i];
    result[i] = checksumVal > 7 ? char2.toUpperCase() : char2;
  }
  return `0x${result.join("")}`;
};
var bytes20Dec = Bytes(20)[1];
var ethAccount = createCodec(
  (input) => {
    const bytes = fromHex2(input);
    if (bytes.length !== 20)
      throw new Error(`Invalid length found on EthAddress(${input})`);
    const hexAddress = toHex(bytes);
    if (input === hexAddress || input === hexAddress.toUpperCase()) return bytes;
    if (getFormattedAddress(hexAddress) !== input)
      throw new Error(`Invalid checksum found on EthAddress(${input})`);
    return bytes;
  },
  createDecoder((bytes) => getFormattedAddress(toHex(bytes20Dec(bytes))))
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/shaped.mjs
var Struct2 = (codecs) => withInner(Struct(codecs), codecs);
Struct2.enc = (x) => withInner(Struct.enc(x), x);
Struct2.dec = (x) => withInner(Struct.dec(x), x);
var Tuple2 = (...inner) => withInner(Tuple(...inner), inner);
Tuple2.enc = (...inner) => withInner(Tuple.enc(...inner), inner);
Tuple2.dec = (...inner) => withInner(Tuple.dec(...inner), inner);
var Vector2 = (inner, ...rest) => withInner(Vector(inner, ...rest), inner);
Vector2.enc = (inner, ...rest) => withInner(Vector.enc(inner, ...rest), inner);
Vector2.dec = (inner, ...rest) => withInner(Vector.dec(inner, ...rest), inner);
var Result2 = (ok, ko) => withInner(Result(ok, ko), { ok, ko });
Result2.enc = (ok, ko) => withInner(Result.enc(ok, ko), { ok, ko });
Result2.dec = (ok, ko) => withInner(Result.dec(ok, ko), { ok, ko });
var Option2 = (inner) => withInner(Option(inner), inner);
Option2.enc = (inner) => withInner(Option.enc(inner), inner);
Option2.dec = (inner) => withInner(Option.dec(inner), inner);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/blockHeader.mjs
var textEncoder4 = new TextEncoder();
var textDecoder4 = new TextDecoder();
var fourChars = enhanceCodec(
  Bytes(4),
  textEncoder4.encode.bind(textEncoder4),
  textDecoder4.decode.bind(textDecoder4)
);
var diggestVal = Struct2({
  engine: fourChars,
  payload: Hex()
});
var diggest = Variant(
  {
    consensus: diggestVal,
    seal: diggestVal,
    preRuntime: diggestVal,
    runtimeUpdated: _void
  },
  [4, 5, 6, 8]
);
var hex32 = Hex(32);
var blockHeader = Struct2({
  parentHash: hex32,
  number: compactNumber,
  stateRoot: hex32,
  extrinsicRoot: hex32,
  digests: Vector2(diggest)
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/docs.mjs
var docs = Vector(str);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/lookup.mjs
var oStr = Option(str);
var primitive = Enum2({
  bool: _void,
  char: _void,
  str: _void,
  u8: _void,
  u16: _void,
  u32: _void,
  u64: _void,
  u128: _void,
  u256: _void,
  i8: _void,
  i16: _void,
  i32: _void,
  i64: _void,
  i128: _void,
  i256: _void
});
var fields = Vector(
  Struct({
    name: oStr,
    type: compactNumber,
    typeName: oStr,
    docs
  })
);
var arr = Struct({
  len: u32,
  type: compactNumber
});
var bitSequence2 = Struct({
  bitStoreType: compactNumber,
  bitOrderType: compactNumber
});
var variant = Vector(
  Struct({
    name: str,
    fields,
    index: u8,
    docs
  })
);
var def = Enum2({
  composite: fields,
  variant,
  sequence: compactNumber,
  array: arr,
  tuple: Vector(compactNumber),
  primitive,
  compact: compactNumber,
  bitSequence: bitSequence2
});
var param = Struct({
  name: str,
  type: Option(compactNumber)
});
var params = Vector(param);
var entry = Struct({
  id: compactNumber,
  path: docs,
  params,
  def,
  docs
});
var lookup = Vector(entry);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/deprecation.mjs
var itemDeprecation = Enum2({
  NotDeprecated: _void,
  DeprecatedWithoutNote: _void,
  Deprecated: Struct({
    note: str,
    since: Option(str)
  })
});
var variantDeprecation = Vector(
  Struct({
    index: u8,
    deprecation: Enum2(
      {
        DeprecatedWithoutNote: _void,
        Deprecated: Struct({
          note: str,
          since: Option(str)
        })
      },
      [1, 2]
    )
  })
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/runtime-api.mjs
var runtimeApiMethod = {
  name: str,
  inputs: Vector(
    Struct({
      name: str,
      type: compactNumber
    })
  ),
  output: compactNumber,
  docs
};
var runtimeApiV15 = Struct({
  name: str,
  methods: Vector(Struct(runtimeApiMethod)),
  docs
});
var runtimeApi = Struct({
  name: str,
  methods: Vector(
    Struct({ ...runtimeApiMethod, deprecationInfo: itemDeprecation })
  ),
  docs,
  version: compactNumber,
  deprecationInfo: itemDeprecation
});
var viewFunction = Struct({
  id: Hex(32),
  ...runtimeApiMethod,
  deprecationInfo: itemDeprecation
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/pallets.mjs
var hashType = Enum2({
  Blake2128: _void,
  Blake2256: _void,
  Blake2128Concat: _void,
  Twox128: _void,
  Twox256: _void,
  Twox64Concat: _void,
  Identity: _void
});
var hashers = Vector(hashType);
var storageMap = Struct({
  hashers,
  key: compactNumber,
  value: compactNumber
});
var storageItem = {
  name: str,
  modifier: u8,
  type: Enum2({
    plain: compactNumber,
    map: storageMap
  }),
  fallback: Hex(),
  docs
};
var enumRefV14 = Option(compactNumber);
var v14Pallet = {
  name: str,
  storage: Option(
    Struct({
      prefix: str,
      items: Vector(Struct(storageItem))
    })
  ),
  calls: enumRefV14,
  events: enumRefV14,
  constants: Vector(
    Struct({
      name: str,
      type: compactNumber,
      value: Hex(),
      docs
    })
  ),
  errors: enumRefV14,
  index: u8
};
var v15Pallet = {
  ...v14Pallet,
  docs
};
var enumRef = Option(
  Struct({ type: compactNumber, deprecationInfo: variantDeprecation })
);
var v16Pallet = {
  name: str,
  storage: Option(
    Struct({
      prefix: str,
      items: Vector(
        Struct({
          ...storageItem,
          deprecationInfo: itemDeprecation
        })
      )
    })
  ),
  calls: enumRef,
  events: enumRef,
  constants: Vector(
    Struct({
      name: str,
      type: compactNumber,
      value: Hex(),
      docs,
      deprecationInfo: itemDeprecation
    })
  ),
  errors: enumRef,
  associatedTypes: Vector(
    Struct({
      name: str,
      type: compactNumber,
      docs
    })
  ),
  viewFns: Vector(viewFunction),
  index: u8,
  docs,
  deprecationInfo: itemDeprecation
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/v14.mjs
var empty = new Uint8Array();
var Always = (value) => createCodec(
  () => empty,
  () => value
);
var extrinsic = Struct({
  type: compactNumber,
  version: u8,
  signedExtensions: Vector(
    Struct({
      identifier: str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v14 = Struct({
  lookup,
  pallets: Vector(Struct({ ...v14Pallet, docs: Always([]) })),
  extrinsic,
  type: compactNumber,
  apis: Always([])
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/v15.mjs
var extrinsic2 = Struct({
  version: u8,
  address: compactNumber,
  call: compactNumber,
  signature: compactNumber,
  extra: compactNumber,
  signedExtensions: Vector(
    Struct({
      identifier: str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v15 = Struct({
  lookup,
  pallets: Vector(Struct(v15Pallet)),
  extrinsic: extrinsic2,
  type: compactNumber,
  apis: Vector(runtimeApiV15),
  outerEnums: Struct({
    call: compactNumber,
    event: compactNumber,
    error: compactNumber
  }),
  custom: Vector(Tuple(str, Struct({ type: compactNumber, value: Hex() })))
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/v16.mjs
var extrinsic3 = Struct({
  version: Vector(u8),
  address: compactNumber,
  call: compactNumber,
  signature: compactNumber,
  signedExtensionsByVersion: Vector(Tuple(u8, Vector(compactNumber))),
  signedExtensions: Vector(
    Struct({
      identifier: str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v16 = Struct({
  lookup,
  pallets: Vector(Struct(v16Pallet)),
  extrinsic: extrinsic3,
  apis: Vector(runtimeApi),
  outerEnums: Struct({
    call: compactNumber,
    event: compactNumber,
    error: compactNumber
  }),
  custom: Vector(Tuple(str, Struct({ type: compactNumber, value: Hex() })))
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/metadata.mjs
var unsupportedFn = () => {
  throw new Error("Unsupported metadata version!");
};
var unsupported = createCodec(
  unsupportedFn,
  unsupportedFn
);
var metadata = Struct({
  magicNumber: u32,
  metadata: Enum2({
    v0: unsupported,
    v1: unsupported,
    v2: unsupported,
    v3: unsupported,
    v4: unsupported,
    v5: unsupported,
    v6: unsupported,
    v7: unsupported,
    v8: unsupported,
    v9: unsupported,
    v10: unsupported,
    v11: unsupported,
    v12: unsupported,
    v13: unsupported,
    v14,
    v15,
    v16
  })
});
var opaqueBytes = Bytes();
var optionOpaque = Option(opaqueBytes);
var opaqueOpaqueBytes = Tuple(compact, opaqueBytes);
var decAnyMetadata = (input) => {
  try {
    return metadata.dec(input);
  } catch (_) {
  }
  try {
    return metadata.dec(optionOpaque.dec(input));
  } catch (_) {
  }
  try {
    return metadata.dec(opaqueBytes.dec(input));
  } catch (_) {
  }
  try {
    return metadata.dec(opaqueOpaqueBytes.dec(input)[1]);
  } catch (_) {
  }
  throw null;
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/unified.mjs
var unifyMetadata = (metadata2) => {
  if ("magicNumber" in metadata2) metadata2 = metadata2.metadata;
  if ("tag" in metadata2) {
    if (metadata2.tag !== "v14" && metadata2.tag !== "v15" && metadata2.tag !== "v16")
      throw new Error("Only metadata 14, 15, and 16 are supported");
    metadata2 = metadata2.value;
  }
  if ("signedExtensionsByVersion" in metadata2.extrinsic) {
    return { version: 16, ...metadata2 };
  }
  if ("custom" in metadata2) {
    const { lookup: lookup22, extrinsic: extrinsic22, custom, apis, pallets: pallets2, outerEnums } = metadata2;
    return {
      version: 15,
      lookup: lookup22,
      pallets: pallets2.map((p) => ({
        ...p,
        calls: p.calls != null ? { type: p.calls } : void 0,
        events: p.events != null ? { type: p.events } : void 0,
        errors: p.errors != null ? { type: p.errors } : void 0,
        viewFns: [],
        associatedTypes: []
      })),
      extrinsic: { ...extrinsic22, version: [extrinsic22.version] },
      apis,
      outerEnums,
      custom
    };
  }
  const { lookup: lookup2, extrinsic: extrinsic4, pallets } = metadata2;
  return {
    version: 14,
    lookup: lookup2,
    pallets: pallets.map((p) => ({
      ...p,
      calls: p.calls != null ? { type: p.calls } : void 0,
      events: p.events != null ? { type: p.events } : void 0,
      errors: p.errors != null ? { type: p.errors } : void 0,
      viewFns: [],
      associatedTypes: []
    })),
    extrinsic: { ...extrinsic4, version: [extrinsic4.version] },
    apis: []
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/blake2.mjs
var len32 = { dkLen: 32 };
var Blake2256 = (encoded) => blake2b2(encoded, len32);
var len16 = { dkLen: 16 };
var Blake2128 = (encoded) => blake2b2(encoded, len16);
var Blake2128Concat = (encoded) => mergeUint82(Blake2128(encoded), encoded);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake3.js
var B3_Flags = {
  CHUNK_START: 1,
  CHUNK_END: 2,
  PARENT: 4,
  ROOT: 8,
  KEYED_HASH: 16,
  DERIVE_KEY_CONTEXT: 32,
  DERIVE_KEY_MATERIAL: 64
};
var B3_IV = SHA256_IV.slice();
var B3_SIGMA = (() => {
  const Id = Array.from({ length: 16 }, (_, i) => i);
  const permute = (arr2) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr2[i]);
  const res = [];
  for (let i = 0, v = Id; i < 7; i++, v = permute(v))
    res.push(...v);
  return Uint8Array.from(res);
})();
var BLAKE3 = class _BLAKE3 extends BLAKE2 {
  constructor(opts = {}, flags = 0) {
    super(64, opts.dkLen === void 0 ? 32 : opts.dkLen);
    this.chunkPos = 0;
    this.chunksDone = 0;
    this.flags = 0 | 0;
    this.stack = [];
    this.posOut = 0;
    this.bufferOut32 = new Uint32Array(16);
    this.chunkOut = 0;
    this.enableXOF = true;
    const { key, context } = opts;
    const hasContext = context !== void 0;
    if (key !== void 0) {
      if (hasContext)
        throw new Error('Only "key" or "context" can be specified at same time');
      const k = toBytes(key).slice();
      abytes2(k, 32);
      this.IV = u322(k);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.KEYED_HASH;
    } else if (hasContext) {
      const ctx = toBytes(context);
      const contextKey = new _BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
      this.IV = u322(contextKey);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
    } else {
      this.IV = B3_IV.slice();
      this.flags = flags;
    }
    this.state = this.IV.slice();
    this.bufferOut = u82(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(counter, flags, buf, bufPos = 0) {
    const { state: s, pos } = this;
    const { h, l } = fromBig(BigInt(counter), true);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 } = compress(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);
    s[0] = v0 ^ v8;
    s[1] = v1 ^ v9;
    s[2] = v2 ^ v10;
    s[3] = v3 ^ v11;
    s[4] = v4 ^ v12;
    s[5] = v5 ^ v13;
    s[6] = v6 ^ v142;
    s[7] = v7 ^ v152;
  }
  compress(buf, bufPos = 0, isLast = false) {
    let flags = this.flags;
    if (!this.chunkPos)
      flags |= B3_Flags.CHUNK_START;
    if (this.chunkPos === 15 || isLast)
      flags |= B3_Flags.CHUNK_END;
    if (!isLast)
      this.pos = this.blockLen;
    this.b2Compress(this.chunksDone, flags, buf, bufPos);
    this.chunkPos += 1;
    if (this.chunkPos === 16 || isLast) {
      let chunk = this.state;
      this.state = this.IV.slice();
      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
        if (!(last = this.stack.pop()))
          break;
        this.buffer32.set(last, 0);
        this.buffer32.set(chunk, 8);
        this.pos = this.blockLen;
        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
        chunk = this.state;
        this.state = this.IV.slice();
      }
      this.chunksDone++;
      this.chunkPos = 0;
      this.stack.push(chunk);
    }
    this.pos = 0;
  }
  _cloneInto(to) {
    to = super._cloneInto(to);
    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
    to.state.set(state.slice());
    to.stack = stack.map((i) => Uint32Array.from(i));
    to.IV.set(IV);
    to.flags = flags;
    to.chunkPos = chunkPos;
    to.chunksDone = chunksDone;
    to.posOut = posOut;
    to.chunkOut = chunkOut;
    to.enableXOF = this.enableXOF;
    to.bufferOut32.set(this.bufferOut32);
    return to;
  }
  destroy() {
    this.destroyed = true;
    clean(this.state, this.buffer32, this.IV, this.bufferOut32);
    clean(...this.stack);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;
    const { h, l } = fromBig(BigInt(this.chunkOut++));
    swap32IfBE(buffer32);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 } = compress(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);
    out32[0] = v0 ^ v8;
    out32[1] = v1 ^ v9;
    out32[2] = v2 ^ v10;
    out32[3] = v3 ^ v11;
    out32[4] = v4 ^ v12;
    out32[5] = v5 ^ v13;
    out32[6] = v6 ^ v142;
    out32[7] = v7 ^ v152;
    out32[8] = s[0] ^ v8;
    out32[9] = s[1] ^ v9;
    out32[10] = s[2] ^ v10;
    out32[11] = s[3] ^ v11;
    out32[12] = s[4] ^ v12;
    out32[13] = s[5] ^ v13;
    out32[14] = s[6] ^ v142;
    out32[15] = s[7] ^ v152;
    swap32IfBE(buffer32);
    swap32IfBE(out32);
    this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    clean(this.buffer.subarray(this.pos));
    let flags = this.flags | B3_Flags.ROOT;
    if (this.stack.length) {
      flags |= B3_Flags.PARENT;
      swap32IfBE(this.buffer32);
      this.compress(this.buffer32, 0, true);
      swap32IfBE(this.buffer32);
      this.chunksDone = 0;
      this.pos = this.blockLen;
    } else {
      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
    }
    this.flags = flags;
    this.b2CompressOut();
  }
  writeInto(out) {
    aexists(this, false);
    abytes2(out);
    this.finish();
    const { blockLen, bufferOut } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.b2CompressOut();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber2(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.enableXOF = false;
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
};
var blake3 = createXOFer((opts) => new BLAKE3(opts));

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/blake3.mjs
var len322 = { dkLen: 32 };
var Blake3256 = (encoded) => blake3(encoded, len322);
var Blake3256Concat = (encoded) => mergeUint82(Blake3256(encoded), encoded);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/identity.mjs
var Identity = (encoded) => encoded;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/h64.mjs
var bigintFromU16 = (v0, v1, v2, v3) => new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true);
var MASK_64 = 2n ** 64n - 1n;
var rotl = (input, nBits) => input << nBits & MASK_64 | input >> 64n - nBits;
var multiply = (a, b) => a * b & MASK_64;
var add2 = (a, b) => a + b & MASK_64;
var PRIME64_1 = 11400714785074694791n;
var PRIME64_2 = 14029467366897019727n;
var PRIME64_3 = 1609587929392839161n;
var PRIME64_4 = 9650029242287828579n;
var PRIME64_5 = 2870177450012600261n;
function h64(input, seed = 0n) {
  let v1 = add2(add2(seed, PRIME64_1), PRIME64_2);
  let v2 = add2(seed, PRIME64_2);
  let v3 = seed;
  let v4 = seed - PRIME64_1;
  let totalLen = input.length;
  let memsize = 0;
  let memory = null;
  (function update() {
    let p2 = 0;
    let bEnd = p2 + totalLen;
    if (!totalLen) return;
    memory = new Uint8Array(32);
    if (totalLen < 32) {
      memory.set(input.subarray(0, totalLen), memsize);
      memsize += totalLen;
      return;
    }
    if (p2 <= bEnd - 32) {
      const limit = bEnd - 32;
      do {
        let other;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v1 = multiply(rotl(add2(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v2 = multiply(rotl(add2(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v3 = multiply(rotl(add2(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v4 = multiply(rotl(add2(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
      } while (p2 <= limit);
    }
    if (p2 < bEnd) {
      memory.set(input.subarray(p2, bEnd), memsize);
      memsize = bEnd - p2;
    }
  })();
  input = memory || input;
  let result;
  let p = 0;
  if (totalLen >= 32) {
    result = rotl(v1, 1n);
    result = add2(result, rotl(v2, 7n));
    result = add2(result, rotl(v3, 12n));
    result = add2(result, rotl(v4, 18n));
    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v1;
    result = add2(multiply(result, PRIME64_1), PRIME64_4);
    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v2;
    result = add2(multiply(result, PRIME64_1), PRIME64_4);
    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v3;
    result = add2(multiply(result, PRIME64_1), PRIME64_4);
    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v4;
    result = add2(multiply(result, PRIME64_1), PRIME64_4);
  } else {
    result = add2(seed, PRIME64_5);
  }
  result = add2(result, BigInt(totalLen));
  while (p <= memsize - 8) {
    let temp2 = bigintFromU16(
      input[p + 1] << 8 | input[p],
      input[p + 3] << 8 | input[p + 2],
      input[p + 5] << 8 | input[p + 4],
      input[p + 7] << 8 | input[p + 6]
    );
    temp2 = multiply(rotl(multiply(temp2, PRIME64_2), 31n), PRIME64_1);
    result = add2(multiply(rotl(result ^ temp2, 27n), PRIME64_1), PRIME64_4);
    p += 8;
  }
  if (p + 4 <= memsize) {
    let temp2 = multiply(
      bigintFromU16(
        input[p + 1] << 8 | input[p],
        input[p + 3] << 8 | input[p + 2],
        0,
        0
      ),
      PRIME64_1
    );
    result = add2(multiply(rotl(result ^ temp2, 23n), PRIME64_2), PRIME64_3);
    p += 4;
  }
  while (p < memsize) {
    const temp2 = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5);
    result = multiply(rotl(result ^ temp2, 11n), PRIME64_1);
  }
  let temp = result >> 33n;
  result = multiply(result ^ temp, PRIME64_2);
  temp = result >> 29n;
  result = multiply(result ^ temp, PRIME64_3);
  temp = result >> 32n;
  result ^= temp;
  return result;
}

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/twoX.mjs
var Twox128 = (input) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  return result;
};
var Twox256 = (input) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  dv.setBigUint64(16, h64(input, 2n), true);
  dv.setBigUint64(24, h64(input, 3n), true);
  return result;
};
var Twox64Concat = (encoded) => mergeUint82(u64.enc(h64(encoded)), encoded);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/storage.mjs
var textEncoder5 = new TextEncoder();
var hashers2 = /* @__PURE__ */ new Map([
  [Identity, 0],
  [Twox64Concat, 8],
  [Blake2128Concat, 16],
  [Blake2128, -16],
  [Blake2256, -32],
  [Twox128, -16],
  [Twox256, -32]
]);
var Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder5.encode(pallet));
  return (name, ...encoders) => {
    const palletItemEncoded = mergeUint82(
      palledEncoded,
      Twox128(textEncoder5.encode(name))
    );
    const palletItemEncodedHex = toHex(palletItemEncoded);
    const dec3 = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (encoders.length === 0) return [];
      const argsKey = fromHex2(key.slice(palletItemEncodedHex.length));
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < encoders.length; i++) {
        const [codec, hasher] = encoders[i];
        const hBytes = hashers2.get(hasher);
        if (hBytes == null) throw new Error("Unknown hasher");
        if (hBytes < 0) {
          const opaqueBytes2 = hBytes * -1;
          result[i] = toHex(argsKey.slice(cur, cur + opaqueBytes2));
          cur += opaqueBytes2;
        } else {
          cur += hBytes;
          result[i] = codec.dec(argsKey.slice(cur));
          cur += codec.enc(result[i]).length;
        }
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc22 }, hash]) => (val) => hash(enc22(val))
    );
    const enc3 = (...args) => toHex(
      mergeUint82(palletItemEncoded, ...args.map((val, idx) => fns[idx](val)))
    );
    return {
      enc: enc3,
      dec: dec3
    };
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/utils/multisig.mjs
var PREFIX = Binary.fromText("modlpy/utilisuba").asBytes();
var getMultisigAccountId = ({
  threshold,
  signatories
}) => {
  const sortedSignatories = sortMultisigSignatories(signatories);
  const payload = mergeUint82(
    PREFIX,
    compact.enc(sortedSignatories.length),
    ...sortedSignatories,
    u16.enc(threshold)
  );
  return Blake2256(payload);
};
var sortMultisigSignatories = (signatories) => signatories.slice().sort((a, b) => {
  for (let i = 0; ; i++) {
    const overA = i >= a.length;
    const overB = i >= b.length;
    if (overA && overB) return 0;
    else if (overA) return -1;
    else if (overB) return 1;
    else if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
  }
});

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/dist/esm/lookups.mjs
var isBytes3 = (value, nBytes) => value.type === "array" && value.len === nBytes && value.value.type === "primitive" && value.value.value === "u8";
var _void2 = { type: "void" };
var _denormalizeLookup = (lookupData, customMap = () => null) => {
  const lookups = /* @__PURE__ */ new Map();
  const from = /* @__PURE__ */ new Set();
  const withCache2 = (fn) => {
    return (id) => {
      let entry2 = lookups.get(id);
      if (entry2) return entry2;
      if (from.has(id)) {
        const entry22 = {
          id
        };
        lookups.set(id, entry22);
        return entry22;
      }
      from.add(id);
      const value = fn(id);
      entry2 = lookups.get(id);
      if (entry2) {
        Object.assign(entry2, value);
      } else {
        entry2 = {
          id,
          ...value
        };
        lookups.set(id, entry2);
      }
      from.delete(id);
      return entry2;
    };
  };
  let isAccountId32SearchOn = true;
  let isAccountId20SearchOn = true;
  const getLookupEntryDef = withCache2((id) => {
    const custom = customMap(lookupData[id]);
    if (custom) return custom;
    const { def: def2, path, params: params2 } = lookupData[id];
    if (def2.tag === "composite") {
      if (def2.value.length === 0) return _void2;
      if (def2.value.length === 1) {
        const inner = getLookupEntryDef(def2.value[0].type);
        if (isAccountId32SearchOn && path.at(-1) === "AccountId32" && isBytes3(inner, 32)) {
          isAccountId32SearchOn = false;
          return { type: "AccountId32" };
        }
        if (isAccountId20SearchOn && path.at(-1) === "AccountId20" && isBytes3(inner, 20)) {
          isAccountId20SearchOn = false;
          return { type: "AccountId20" };
        }
        return inner;
      }
      return getComplexVar(def2.value);
    }
    if (def2.tag === "variant") {
      if (path.length === 1 && path[0] === "Option" && params2.length === 1 && params2[0].name === "T") {
        const value = getLookupEntryDef(params2[0].type);
        return value.type === "void" ? (
          // Option<void> would return a Codec<undefined> which makes no sense
          // Therefore, we better treat it as a bool
          { type: "primitive", value: "bool" }
        ) : {
          type: "option",
          value
        };
      }
      if (path.length === 1 && path[0] === "Result" && params2.length === 2 && params2[0].name === "T" && params2[1].name === "E") {
        return {
          type: "result",
          value: {
            ok: getLookupEntryDef(params2[0].type),
            ko: getLookupEntryDef(params2[1].type)
          }
        };
      }
      if (def2.value.length === 0) return _void2;
      const enumValue = {};
      const enumDocs = {};
      def2.value.forEach((x) => {
        const key = x.name;
        enumDocs[key] = x.docs;
        if (x.fields.length === 0) {
          enumValue[key] = { ..._void2, idx: x.index };
          return;
        }
        if (x.fields.length === 1 && !x.fields[0].name) {
          enumValue[key] = {
            type: "lookupEntry",
            value: getLookupEntryDef(x.fields[0].type),
            idx: x.index
          };
          return;
        }
        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index };
      });
      return {
        type: "enum",
        value: enumValue,
        innerDocs: enumDocs
      };
    }
    if (def2.tag === "sequence")
      return {
        type: "sequence",
        value: getLookupEntryDef(def2.value)
      };
    if (def2.tag === "array") {
      const { len } = def2.value;
      const value = getLookupEntryDef(def2.value.type);
      return !len || value.type === "void" ? _void2 : len > 1 ? {
        type: "array",
        value,
        len: def2.value.len
      } : value;
    }
    if (def2.tag === "tuple") {
      if (def2.value.length === 0) return _void2;
      return def2.value.length > 1 ? getArrayOrTuple(
        def2.value.map((x) => getLookupEntryDef(x)),
        def2.value.map((x) => lookupData[x].docs)
      ) : getLookupEntryDef(def2.value[0]);
    }
    if (def2.tag === "primitive") {
      return {
        type: "primitive",
        value: def2.value.tag
      };
    }
    if (def2.tag === "compact") {
      const translated = getLookupEntryDef(def2.value);
      if (translated.type === "void") return _void2;
      const isBig = Number(translated.value.slice(1)) > 32;
      return {
        type: "compact",
        isBig,
        size: translated.value
      };
    }
    return {
      type: def2.tag
    };
  });
  const getComplexVar = (input) => {
    let allKey = true;
    const values = {};
    const innerDocs = {};
    input.forEach((x, idx) => {
      allKey = allKey && !!x.name;
      const key = x.name || idx;
      const value = getLookupEntryDef(x.type);
      if (value.type !== "void") {
        values[key] = value;
        innerDocs[key] = x.docs;
      }
    });
    return allKey ? {
      type: "struct",
      value: values,
      innerDocs
    } : getArrayOrTuple(Object.values(values), Object.values(innerDocs));
  };
  const getArrayOrTuple = (values, innerDocs) => {
    if (values.every((v) => v.id === values[0].id) && innerDocs.every((doc) => !doc.length)) {
      const [value] = values;
      return value.type === "void" ? _void2 : {
        type: "array",
        value: values[0],
        len: values.length
      };
    }
    return {
      type: "tuple",
      value: values,
      innerDocs
    };
  };
  return getLookupEntryDef;
};
var getLookupFn = (metadata2) => {
  const getLookupEntryDef = _denormalizeLookup(metadata2.lookup, ({ def: def2 }) => {
    if (def2.tag === "composite") {
      const moduleErrorLength = getModuleErrorLength(def2);
      if (moduleErrorLength) {
        return {
          type: "enum",
          innerDocs: {},
          value: Object.fromEntries(
            metadata2.pallets.map((p) => [
              p.name,
              p.errors == null ? { ..._void2, idx: p.index } : {
                type: "lookupEntry",
                value: getLookupEntryDef(p.errors.type),
                idx: p.index
              }
            ])
          ),
          byteLength: moduleErrorLength
        };
      }
    }
    return null;
  });
  function getModuleErrorLength(def2) {
    const preChecks = def2.value.length === 2 && def2.value[0].name === "index" && def2.value[1].name === "error";
    if (!preChecks) return null;
    const index = getLookupEntryDef(def2.value[0].type);
    const error = getLookupEntryDef(def2.value[1].type);
    return index.type === "primitive" && index.value === "u8" && error.type === "array" && error.value.type === "primitive" && error.value.value === "u8" ? 1 + error.len : null;
  }
  const getCall = () => {
    if ("call" in metadata2.extrinsic) {
      return metadata2.extrinsic.call;
    }
    const extrinsic4 = metadata2.lookup[metadata2.extrinsic.type];
    const call = extrinsic4 == null ? void 0 : extrinsic4.params.find((p) => p.name === "Call");
    return (call == null ? void 0 : call.type) ?? null;
  };
  return Object.assign(getLookupEntryDef, { metadata: metadata2, call: getCall() });
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/dist/esm/with-cache.mjs
var withCache = (fn, onEnterCircular, onExitCircular) => (input, cache, stack, ...rest) => {
  const { id } = input;
  if (cache.has(id)) return cache.get(id);
  if (stack.has(id)) {
    const res = onEnterCircular(() => cache.get(id), input, ...rest);
    cache.set(id, res);
    return res;
  }
  stack.add(id);
  let result = fn(input, cache, stack, ...rest);
  stack.delete(id);
  if (cache.has(id))
    result = onExitCircular(result, cache.get(id), input, ...rest);
  cache.set(id, result);
  return result;
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/dist/esm/lookup-codec-builder.mjs
var _bytes2 = Bin();
var _buildCodec = (input, cache, stack, _accountId) => {
  if (input.type === "primitive") return esm_exports[input.value];
  if (input.type === "void") return _void;
  if (input.type === "AccountId32") return _accountId;
  if (input.type === "AccountId20") return ethAccount;
  if (input.type === "compact")
    return input.isBig ? compactBn : compactNumber;
  if (input.type === "bitSequence") return bitSequence;
  const buildNextCodec = (nextInput) => buildCodec(nextInput, cache, stack, _accountId);
  const buildVector = (inner2, len) => {
    const innerCodec = buildNextCodec(inner2);
    return len ? Vector2(innerCodec, len) : Vector2(innerCodec);
  };
  const buildTuple = (value) => Tuple2(...value.map(buildNextCodec));
  const buildStruct = (value) => {
    const inner2 = Object.fromEntries(
      Object.entries(value).map(([key, value2]) => [key, buildNextCodec(value2)])
    );
    return Struct2(inner2);
  };
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return _bytes2;
  }
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8")
      return Bin(input.len);
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence") return buildVector(input.value);
  if (input.type === "tuple") return buildTuple(input.value);
  if (input.type === "struct") return buildStruct(input.value);
  if (input.type === "option") return Option2(buildNextCodec(input.value));
  if (input.type === "result")
    return Result2(
      buildNextCodec(input.value.ok),
      buildNextCodec(input.value.ko)
    );
  const dependencies = Object.values(input.value).map((v) => {
    switch (v.type) {
      case "void":
        return _void;
      case "lookupEntry":
        return buildNextCodec(v.value);
      case "tuple":
        return buildTuple(v.value);
      case "struct":
        return buildStruct(v.value);
      case "array":
        return buildVector(v.value, v.len);
    }
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => {
      return [key, dependencies[idx]];
    })
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  const variantCodec = areIndexesSorted ? Variant(inner) : Variant(inner, indexes);
  return input.byteLength ? fixedSizeCodec(variantCodec, input.byteLength) : variantCodec;
};
var buildCodec = withCache(_buildCodec, Self, (res) => res);
var getLookupCodecBuilder = (lookup2, accountId = AccountId()) => {
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildCodec(lookup2(id), cache, /* @__PURE__ */ new Set(), accountId);
  return (id) => buildDefinition(id);
};
var fixedSizeCodec = (codec, size) => {
  const allBytes = Bytes(size);
  return createCodec(
    (value) => allBytes.enc(codec.enc(value)),
    (data) => codec.dec(allBytes.dec(data))
  );
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/dist/esm/dynamic-builder.mjs
var nullCodec = enhanceCodec(
  _void,
  () => void 0,
  () => null
);
var getDynamicBuilder = (getLookupEntryDef) => {
  var _a;
  const { metadata: metadata2 } = getLookupEntryDef;
  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef);
  const prefix = (_a = metadata2.pallets.find((x) => x.name === "System")) == null ? void 0 : _a.constants.find((x) => x.name === "SS58Prefix");
  let ss58Prefix;
  if (prefix) {
    try {
      const prefixVal = buildDefinition(prefix.type).dec(prefix.value);
      if (typeof prefixVal === "number") {
        ss58Prefix = prefixVal;
        buildDefinition = getLookupCodecBuilder(
          getLookupEntryDef,
          AccountId(prefixVal)
        );
      }
    } catch (_) {
    }
  }
  const storagePallets = /* @__PURE__ */ new Map();
  const buildStorage = (pallet, entry2) => {
    let storagePallet = storagePallets.get(pallet);
    if (!storagePallet)
      storagePallets.set(pallet, storagePallet = Storage(pallet));
    const storageEntry = metadata2.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry2);
    const withNullVoid = (codec) => codec === _void ? nullCodec : codec;
    const storageWithFallback = (len, value2, ...args) => {
      const keys = storagePallet(...args);
      const [, ...encodersWithHash] = args;
      return {
        args: Tuple2(...encodersWithHash.map(([codec]) => codec)),
        keys,
        value: value2,
        len,
        fallback: storageEntry.modifier === 1 ? value2.dec(storageEntry.fallback) : void 0
      };
    };
    if (storageEntry.type.tag === "plain")
      return storageWithFallback(
        0,
        withNullVoid(buildDefinition(storageEntry.type.value)),
        entry2
      );
    const { key, value, hashers: hashers3 } = storageEntry.type.value;
    const val = withNullVoid(buildDefinition(value));
    const hashes = hashers3.map((x) => esm_exports[x.tag]);
    const hashArgs = (() => {
      if (hashes.length === 1) {
        return [[buildDefinition(key), hashes[0]]];
      }
      const keyDef = getLookupEntryDef(key);
      switch (keyDef.type) {
        case "array":
          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash]);
        case "tuple":
          return keyDef.value.map((x, idx) => [
            buildDefinition(x.id),
            hashes[idx]
          ]);
        default:
          throw new Error("Invalid key type");
      }
    })();
    return storageWithFallback(hashes.length, val, entry2, ...hashArgs);
  };
  const buildEnumEntry = (entry2) => {
    switch (entry2.type) {
      case "void":
        return _void;
      case "lookupEntry":
        return buildDefinition(entry2.value.id);
      case "tuple":
        return Tuple2(
          ...Object.values(entry2.value).map((l) => buildDefinition(l.id))
        );
      case "struct":
        return Struct2(
          mapObject2(entry2.value, (x) => buildDefinition(x.id))
        );
      case "array":
        return Vector2(buildDefinition(entry2.value.id), entry2.len);
    }
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata2.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const buildVariant = (type) => (pallet, name) => {
    const palletEntry = metadata2.pallets.find((x) => x.name === pallet);
    const lookup2 = getLookupEntryDef(palletEntry[type].type);
    if (lookup2.type !== "enum") throw null;
    const entry2 = lookup2.value[name];
    return {
      location: [palletEntry.index, entry2.idx],
      codec: buildEnumEntry(lookup2.value[name])
    };
  };
  const buildViewFn = (pallet, entry2) => {
    var _a2;
    const fn = (_a2 = metadata2.pallets.find((x) => x.name === pallet)) == null ? void 0 : _a2.viewFns.find((x) => x.name === entry2);
    if (!fn) throw null;
    return {
      args: Tuple2(...fn.inputs.map((x) => buildDefinition(x.type))),
      value: buildDefinition(fn.output)
    };
  };
  const buildRuntimeCall = (api, method) => {
    var _a2;
    const entry2 = (_a2 = metadata2.apis.find((x) => x.name === api)) == null ? void 0 : _a2.methods.find((x) => x.name === method);
    if (!entry2) throw null;
    return {
      args: Tuple2(...entry2.inputs.map((x) => buildDefinition(x.type))),
      value: buildDefinition(entry2.output)
    };
  };
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildViewFn,
    buildRuntimeCall,
    buildCall: buildVariant("calls"),
    buildConstant,
    ss58Prefix
  };
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/dist/esm/checksum-builder.mjs
var textEncoder6 = new TextEncoder();
var encodeText = textEncoder6.encode.bind(textEncoder6);
var runtimePrimitiveIds = {
  undefined: 0n,
  number: 1n,
  string: 2n,
  bigint: 3n,
  boolean: 4n,
  bitSequence: 5n,
  // {bitsLen: number, bytes: Uint8Array}
  byteSequence: 6n,
  // Binary
  accountId32: 7n,
  // SS58String
  accountId20: 8n
  // EthAccount
};
var metadataPrimitiveIds = {
  bool: runtimePrimitiveIds.boolean,
  char: runtimePrimitiveIds.string,
  str: runtimePrimitiveIds.string,
  u8: runtimePrimitiveIds.number,
  u16: runtimePrimitiveIds.number,
  u32: runtimePrimitiveIds.number,
  u64: runtimePrimitiveIds.bigint,
  u128: runtimePrimitiveIds.bigint,
  u256: runtimePrimitiveIds.bigint,
  i8: runtimePrimitiveIds.number,
  i16: runtimePrimitiveIds.number,
  i32: runtimePrimitiveIds.number,
  i64: runtimePrimitiveIds.bigint,
  i128: runtimePrimitiveIds.bigint,
  i256: runtimePrimitiveIds.bigint
};

// node_modules/.pnpm/@polkadot-api+signers-common@0.1.9/node_modules/@polkadot-api/signers-common/dist/esm/v4.mjs
var versionCodec = enhanceEncoder(
  u8.enc,
  (value) => +!!value.signed << 7 | value.version
);
var unkownSignerType = () => new Error("Unkown signer");
var getSignerType = (metadata2) => {
  const { extrinsic: extrinsic4 } = metadata2;
  const getLookup = getLookupFn(metadata2);
  let address;
  let signature;
  if ("address" in extrinsic4) {
    address = getLookup(extrinsic4.address);
    signature = getLookup(extrinsic4.signature);
  } else {
    const extProps = Object.fromEntries(
      metadata2.lookup[extrinsic4.type].params.filter((x) => x.type != null).map((x) => [x.name, getLookup(x.type)])
    );
    address = extProps["Address"];
    signature = extProps["Signature"];
    if (!address || !signature) throw unkownSignerType();
  }
  if (address.type === "AccountId20" && signature.type === "array" && signature.len === 65 && signature.value.type === "primitive" && signature.value.value === "u8")
    return [1, []];
  if (signature.type !== "enum" || ["Ecdsa", "Ed25519", "Sr25519"].some((x) => !(x in signature.value)))
    throw unkownSignerType();
  if (address.type === "enum") {
    const id = address.value["Id"];
    if (id.type === "lookupEntry" && id.value.type === "AccountId32")
      return [0, [id.idx]];
  } else if (address.type === "AccountId32") return [0, []];
  throw unkownSignerType();
};
var signingTypeId = {
  Ed25519: 0,
  Sr25519: 1,
  Ecdsa: 2
};
var createV4Tx = (metadata2, publicKey, signed, extra, callData, signingType) => {
  const [signerType, addressPrefix] = getSignerType(metadata2);
  const preResult = mergeUint82(
    versionCodec({ signed: true, version: 4 }),
    // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`
    signerType === 1 ? publicKey : new Uint8Array([...addressPrefix, ...publicKey]),
    signerType === 1 || !signingType ? signed : new Uint8Array([signingTypeId[signingType], ...signed]),
    ...extra,
    callData
  );
  return mergeUint82(compact.enc(preResult.length), preResult);
};

// node_modules/.pnpm/@polkadot-api+signers-common@0.1.9/node_modules/@polkadot-api/signers-common/dist/esm/sign-bytes.mjs
var [preBytes, postBytes] = ["<Bytes>", "</Bytes>"].map(
  (str2) => Binary.fromText(str2).asBytes()
);
var getSignBytes = (sign) => async (data) => {
  let isPadded = true;
  let i;
  for (i = 0; isPadded && i < preBytes.length; i++)
    isPadded = preBytes[i] === data[i];
  isPadded = isPadded && i === preBytes.length;
  const postDataStart = data.length - postBytes.length;
  for (i = 0; isPadded && i < postBytes.length; i++)
    isPadded = postBytes[i] === data[postDataStart + i];
  isPadded = isPadded && i === postBytes.length;
  return sign(isPadded ? data : mergeUint82(preBytes, data, postBytes));
};

export {
  createDecoder,
  enhanceEncoder,
  enhanceDecoder,
  enhanceCodec,
  u8,
  u16,
  u32,
  u64,
  i8,
  i16,
  i32,
  i64,
  u128,
  i128,
  u256,
  i256,
  bool,
  compact,
  str,
  _void,
  Bytes,
  blake2b2 as blake2b,
  AccountId,
  toHex,
  fromHex2 as fromHex,
  mapObject2 as mapObject,
  mergeUint82 as mergeUint8,
  noop2 as noop,
  AbortError,
  Binary,
  FixedSizeBinary,
  compactNumber,
  compactBn,
  Self,
  Enum,
  _Enum,
  Variant,
  ScaleEnum,
  ethAccount,
  Struct2 as Struct,
  Tuple2 as Tuple,
  Vector2 as Vector,
  Option2 as Option,
  blockHeader,
  metadata,
  decAnyMetadata,
  unifyMetadata,
  Blake2256,
  Blake3256,
  getLookupFn,
  getDynamicBuilder,
  createV4Tx,
  getSignBytes
};
/*! Bundled license information:

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-EVM4Y7G3.js.map
