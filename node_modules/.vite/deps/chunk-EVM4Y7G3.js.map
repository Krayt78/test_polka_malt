{
  "version": 3,
  "sources": ["../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/types/enum.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/index.mjs", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/internal/toInternalBytes.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/internal/mergeUint8.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/internal/mapObject.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/utils.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/fixed-width-ints.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/bool.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/compact.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/str.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/void.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Bytes.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Enum.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Option.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Result.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Tuple.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Struct.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Vector.ts", "../../.pnpm/@scure+base@1.2.5/node_modules/@scure/base/index.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/crypto.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/utils.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_blake.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_md.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_u64.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/blake2.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/blake2b.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/utils/ss58-util.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/AccountId.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/hex.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/mapObject.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/mergeUint8.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/noop.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/AbortError.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/Binary.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/compact.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/bitSequence.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/char.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/Hex.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/fixed-str.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/Self.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/with-inner.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/Variant.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/sha3.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/ethAccount.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/shaped.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/blockHeader.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/docs.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/lookup.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/deprecation.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/runtime-api.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/pallets.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/v14.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/v15.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/v16.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/metadata.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/unified.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/blake2.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/blake3.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/blake3.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/identity.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/h64.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/twoX.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/storage.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.13.0/node_modules/@polkadot-api/substrate-bindings/src/utils/multisig.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/src/lookups.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/src/with-cache.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/src/lookup-codec-builder.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/src/dynamic-builder.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.12.1/node_modules/@polkadot-api/metadata-builders/src/checksum-builder.ts", "../../.pnpm/@polkadot-api+signers-common@0.1.9/node_modules/@polkadot-api/signers-common/src/v4.ts", "../../.pnpm/@polkadot-api+signers-common@0.1.9/node_modules/@polkadot-api/signers-common/src/sign-bytes.ts"],
  "sourcesContent": ["export type Enum<T extends {}> = {\n  [K in keyof T & string]: {\n    type: K\n    value: T[K]\n  }\n}[keyof T & string]\n\nexport type EnumVariant<\n  T extends { type: string; value?: any },\n  K extends T[\"type\"],\n> = T & {\n  type: K\n}\n\nexport type ExtractEnumValue<\n  T extends { type: string; value?: any },\n  K extends string,\n> = EnumVariant<T, K>[\"value\"]\n\ntype ValueArg<V> = undefined extends V ? [value?: V] : [value: V]\n\ninterface Discriminant {\n  is<T extends { type: string; value: any }, K extends T[\"type\"]>(\n    value: T,\n    type: K,\n  ): value is T & { type: K }\n  as<T extends { type: string; value: any }, K extends T[\"type\"]>(\n    value: T,\n    type: K,\n  ): ExtractEnumValue<T, K>\n}\nconst discriminant: Discriminant = {\n  is<T extends { type: string; value: any }, K extends T[\"type\"]>(\n    value: T,\n    type: K,\n  ): value is T & { type: K } {\n    return value.type === type\n  },\n  as(value, type) {\n    if (type !== value.type)\n      throw new Error(\n        `Enum.as(enum, ${type}) used with actual type ${value.type}`,\n      )\n    return value\n  },\n}\ninterface EnumFn extends Discriminant {\n  <T extends { type: string; value: any }, K extends T[\"type\"]>(\n    type: K,\n    ...[value]: ValueArg<ExtractEnumValue<T, K>>\n  ): EnumVariant<T, K>\n}\nexport const Enum: EnumFn = Object.assign((type: string, value?: any) => {\n  return {\n    type,\n    value,\n  } as any\n}, discriminant)\n\n// well-known enums\nexport type GetEnum<T extends Enum<any>> = {\n  [K in T[\"type\"]]: (\n    ...args: ExtractEnumValue<T, K> extends undefined\n      ? []\n      : [value: ExtractEnumValue<T, K>]\n  ) => EnumVariant<T, K>\n}\nexport const _Enum = new Proxy(\n  {},\n  {\n    get(_, prop: string) {\n      return (value: string) => Enum(prop, value)\n    },\n  },\n)\n\n// type Bar = Enum<{\n//   Kaka: 1\n//   Bar: 2\n// }>\n\n// type FooInput = Enum<{\n//   foo: \"foo\" | undefined\n//   bar: Bar\n//   baz: number\n//   wtf: boolean\n// }>\n\n// declare function foo(foo: FooInput): void\n// foo(Enum(\"bar\", Enum(\"Bar\", 2)))\n\n// const InputEnum: GetEnum<FooInput> = null as any;\n// InputEnum.bar(Enum('Bar', 2))\n", "export { AccountId } from './codecs/scale/AccountId.mjs';\nexport { Bin, Binary, FixedSizeBinary } from './codecs/scale/Binary.mjs';\nexport { bitSequence } from './codecs/scale/bitSequence.mjs';\nexport { char } from './codecs/scale/char.mjs';\nexport { compactBn, compactNumber } from './codecs/scale/compact.mjs';\nexport { Hex } from './codecs/scale/Hex.mjs';\nexport { fixedStr } from './codecs/scale/fixed-str.mjs';\nexport { Bytes, _void, bool, compact, createCodec, createDecoder, enhanceCodec, enhanceDecoder, enhanceEncoder, i128, i16, i256, i32, i64, i8, str, u128, u16, u256, u32, u64, u8 } from 'scale-ts';\nexport { Self, selfDecoder, selfEncoder } from './codecs/scale/Self.mjs';\nexport { ScaleEnum, Variant } from './codecs/scale/Variant.mjs';\nexport { ethAccount } from './codecs/scale/ethAccount.mjs';\nexport { Option, Result, Struct, Tuple, Vector } from './codecs/scale/shaped.mjs';\nexport { blockHeader } from './codecs/blockHeader.mjs';\nexport { decAnyMetadata, metadata } from './codecs/metadata/metadata.mjs';\nexport { v14 } from './codecs/metadata/v14.mjs';\nexport { v15 } from './codecs/metadata/v15.mjs';\nexport { v16 } from './codecs/metadata/v16.mjs';\nexport { unifyMetadata } from './codecs/metadata/unified.mjs';\nexport { lookup as v14Lookup } from './codecs/metadata/lookup.mjs';\nexport { Blake2128, Blake2128Concat, Blake2256 } from './hashes/blake2.mjs';\nexport { Blake3256, Blake3256Concat } from './hashes/blake3.mjs';\nexport { Identity } from './hashes/identity.mjs';\nexport { Twox128, Twox256, Twox64Concat } from './hashes/twoX.mjs';\nexport { h64 } from './hashes/h64.mjs';\nexport { Storage } from './storage.mjs';\nexport { Enum, _Enum } from './types/enum.mjs';\nexport { fromBufferToBase58, getSs58AddressInfo } from './utils/ss58-util.mjs';\nexport { getMultisigAccountId, sortMultisigSignatories } from './utils/multisig.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { Decoder } from \"../types\"\n\n// https://jsben.ch/URe1X\nconst HEX_MAP: Record<string, number> = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n}\nexport function fromHex(hexString: string): Uint8Array {\n  const isOdd = hexString.length % 2\n  /* istanbul ignore next */\n  const base = (hexString[1] === \"x\" ? 2 : 0) + isOdd\n  const nBytes = (hexString.length - base) / 2 + isOdd\n  const bytes = new Uint8Array(nBytes)\n\n  if (isOdd) bytes[0] = 0 | HEX_MAP[hexString[2]]\n\n  for (let i = 0; i < nBytes; ) {\n    const idx = base + i * 2\n    const a = HEX_MAP[hexString[idx]]\n    const b = HEX_MAP[hexString[idx + 1]]\n    bytes[isOdd + i++] = (a << 4) | b\n  }\n\n  return bytes\n}\n\nclass InternalUint8Array extends Uint8Array {\n  i: number = 0\n  v: DataView\n\n  constructor(buffer: ArrayBuffer) {\n    super(buffer)\n    this.v = new DataView(buffer)\n  }\n}\n\nexport const toInternalBytes =\n  <T>(fn: (input: InternalUint8Array) => T): Decoder<T> =>\n  (buffer: string | ArrayBuffer | Uint8Array | InternalUint8Array) =>\n    fn(\n      buffer instanceof InternalUint8Array\n        ? buffer\n        : new InternalUint8Array(\n            buffer instanceof Uint8Array\n              ? buffer.buffer\n              : typeof buffer === \"string\"\n              ? fromHex(buffer).buffer\n              : buffer,\n          ),\n    )\n", "export const mergeUint8 = (inputs: Array<Uint8Array>): Uint8Array => {\n  const len = inputs.length\n  let totalLen = 0\n  for (let i = 0; i < len; i++) totalLen += inputs[i].length\n  const result = new Uint8Array(totalLen)\n\n  for (let idx = 0, at = 0; idx < len; idx++) {\n    const current = inputs[idx]\n    result.set(current, at)\n    at += current.byteLength\n  }\n\n  return result\n}\n", "export function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k: K) => O,\n): Record<K, O>\n\nexport function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k?: K) => O,\n): Record<K, O> {\n  const keys = Object.keys(input) as Array<K>\n  const len = keys.length\n\n  const result: Record<K, O> = {} as any\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    result[key] = mapper(input[key], key)\n  }\n\n  return result\n}\n", "import type { Codec, Decoder, Encoder } from \"./types\"\nimport { toInternalBytes } from \"./internal\"\n\nexport const createDecoder: <T>(fn: (input: Uint8Array) => T) => Decoder<T> =\n  toInternalBytes as any\n\nexport const createCodec = <T>(\n  encoder: Encoder<T>,\n  decoder: Decoder<T>,\n): Codec<T> => {\n  const result = [encoder, decoder] as any\n  result.enc = encoder\n  result.dec = decoder\n  return result\n}\n\nexport const enhanceEncoder =\n  <I, O>(encoder: Encoder<I>, mapper: (value: O) => I): Encoder<O> =>\n  (value) =>\n    encoder(mapper(value))\n\nexport const enhanceDecoder =\n  <I, O>(decoder: Decoder<I>, mapper: (value: I) => O): Decoder<O> =>\n  (value) =>\n    mapper(decoder(value))\n\nexport const enhanceCodec = <I, O>(\n  [encoder, decoder]: Codec<I>,\n  toFrom: (value: O) => I,\n  fromTo: (value: I) => O,\n): Codec<O> =>\n  createCodec(enhanceEncoder(encoder, toFrom), enhanceDecoder(decoder, fromTo))\n", "import { createCodec } from \"../utils\"\nimport { Codec, Decoder, Encoder } from \"../types\"\nimport { toInternalBytes } from \"../internal\"\n\nfunction decodeInt(nBytes: 8, getter: keyof DataView): Decoder<bigint>\nfunction decodeInt(nBytes: number, getter: keyof DataView): Decoder<number>\nfunction decodeInt(\n  nBytes: number,\n  getter: keyof DataView,\n): Decoder<number> | Decoder<bigint> {\n  return toInternalBytes((bytes) => {\n    const result = (bytes.v[getter] as any)(bytes.i, true) as number\n    bytes.i += nBytes\n    return result\n  })\n}\n\nfunction encodeInt(nBytes: 8, setter: keyof DataView): Encoder<bigint>\nfunction encodeInt(nBytes: number, setter: keyof DataView): Encoder<number>\nfunction encodeInt(\n  nBytes: number,\n  setter: keyof DataView,\n): Encoder<number> | Encoder<bigint> {\n  return (input: number | bigint) => {\n    const result = new Uint8Array(nBytes)\n    const dv = new DataView(result.buffer)\n    ;(dv[setter] as any)(0, input, true)\n    return result\n  }\n}\n\nfunction intCodec(\n  nBytes: 8,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<bigint>\nfunction intCodec(\n  nBytes: number,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<number>\nfunction intCodec(\n  nBytes: number,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<bigint> | Codec<number> {\n  return createCodec(encodeInt(nBytes, setter), decodeInt(nBytes, getter))\n}\n\nexport const u8 = intCodec(1, \"getUint8\", \"setUint8\")\nexport const u16 = intCodec(2, \"getUint16\", \"setUint16\")\nexport const u32 = intCodec(4, \"getUint32\", \"setUint32\")\nexport const u64 = intCodec(8, \"getBigUint64\", \"setBigUint64\")\nexport const i8 = intCodec(1, \"getInt8\", \"setInt8\")\nexport const i16 = intCodec(2, \"getInt16\", \"setInt16\")\nexport const i32 = intCodec(4, \"getInt32\", \"setInt32\")\nexport const i64 = intCodec(8, \"getBigInt64\", \"setBigInt64\")\n\nconst x128Enc: Encoder<bigint> = (value) => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n  dv.setBigInt64(0, value, true)\n  dv.setBigInt64(8, value >> 64n, true)\n  return result\n}\n\nconst create128Dec = (\n  method: \"getBigInt64\" | \"getBigUint64\",\n): Decoder<bigint> =>\n  toInternalBytes((input) => {\n    const { v, i } = input\n    const right = v.getBigUint64(i, true)\n    const left = v[method](i + 8, true)\n    input.i += 16\n    return (left << 64n) | right\n  })\n\nexport const u128 = createCodec(x128Enc, create128Dec(\"getBigUint64\"))\nexport const i128 = createCodec(x128Enc, create128Dec(\"getBigInt64\"))\n\nconst x256Enc: Encoder<bigint> = (value) => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n  dv.setBigInt64(0, value, true)\n  dv.setBigInt64(8, value >> 64n, true)\n  dv.setBigInt64(16, value >> 128n, true)\n  dv.setBigInt64(24, value >> 192n, true)\n  return result\n}\n\nconst create256Dec = (\n  method: \"getBigInt64\" | \"getBigUint64\",\n): Decoder<bigint> =>\n  toInternalBytes((input) => {\n    let result = input.v.getBigUint64(input.i, true)\n    input.i += 8\n\n    result |= input.v.getBigUint64(input.i, true) << 64n\n    input.i += 8\n\n    result |= input.v.getBigUint64(input.i, true) << 128n\n    input.i += 8\n\n    result |= input.v[method](input.i, true) << 192n\n    input.i += 8\n\n    return result\n  })\nexport const u256 = createCodec(x256Enc, create256Dec(\"getBigUint64\"))\nexport const i256 = createCodec(x256Enc, create256Dec(\"getBigInt64\"))\n", "import { Codec } from \"../types\"\nimport { enhanceCodec } from \"../\"\nimport { u8 } from \"./fixed-width-ints\"\n\nexport const bool: Codec<boolean> = enhanceCodec(\n  u8,\n  (value: boolean) => (value ? 1 : 0),\n  Boolean,\n)\n", "import { createCodec } from \"../\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { u8, u16, u32, u64 } from \"./fixed-width-ints\"\nimport { Decoder, Encoder, Codec } from \"../types\"\n\nconst decoders = [u8[1], u16[1], u32[1]] as const\nconst compactDec: Decoder<number | bigint> = toInternalBytes<number | bigint>(\n  (bytes) => {\n    const init = bytes[bytes.i]\n\n    const kind = init & 3\n    if (kind < 3) return decoders[kind](bytes) >>> 2\n\n    const nBytes = (init >>> 2) + 4\n    bytes.i++\n\n    let result = 0n\n\n    const nU64 = (nBytes / 8) | 0\n    let shift = 0n\n    for (let i = 0; i < nU64; i++) {\n      result = (u64[1](bytes) << shift) | result\n      shift += 64n\n    }\n\n    let nReminders = nBytes % 8\n    if (nReminders > 3) {\n      result = (BigInt(u32[1](bytes)) << shift) | result\n      shift += 32n\n      nReminders -= 4\n    }\n\n    if (nReminders > 1) {\n      result = (BigInt(u16[1](bytes)) << shift) | result\n      shift += 16n\n      nReminders -= 2\n    }\n\n    if (nReminders) result = (BigInt(u8[1](bytes)) << shift) | result\n\n    return result\n  },\n)\n\nconst MIN_U64 = 1n << 56n\nconst MIN_U32 = 1 << 24\nconst MIN_U16 = 256\nconst U32_MASK = 4294967295n\n\nconst SINGLE_BYTE_MODE_LIMIT = 1 << 6\nconst TWO_BYTE_MODE_LIMIT = 1 << 14\nconst FOUR_BYTE_MODE_LIMIT = 1 << 30\n\nconst compactEnc: Encoder<number | bigint> = (input) => {\n  if (input < 0) throw new Error(`Wrong compact input (${input})`)\n\n  const nInput = Number(input) << 2\n  if (input < SINGLE_BYTE_MODE_LIMIT) return u8[0](nInput)\n  if (input < TWO_BYTE_MODE_LIMIT) return u16[0](nInput | 1)\n  if (input < FOUR_BYTE_MODE_LIMIT) return u32[0](nInput | 2)\n\n  let buffers: Array<Uint8Array> = [new Uint8Array(1)]\n  let bigValue = BigInt(input)\n  while (bigValue >= MIN_U64) {\n    buffers.push(u64[0](bigValue))\n    bigValue >>= 64n\n  }\n\n  if (bigValue >= MIN_U32) {\n    buffers.push(u32[0](Number(bigValue & U32_MASK)))\n    bigValue >>= 32n\n  }\n\n  let smValue = Number(bigValue)\n  if (smValue >= MIN_U16) {\n    buffers.push(u16[0](smValue))\n    smValue >>= 16\n  }\n\n  smValue && buffers.push(u8[0](smValue))\n\n  const result = mergeUint8(buffers)\n  result[0] = ((result.length - 5) << 2) | 3\n\n  return result\n}\n\nexport const compact: Codec<number | bigint> = createCodec(\n  compactEnc,\n  compactDec,\n)\n", "import { createCodec, Decoder, Encoder } from \"../\"\nimport { toInternalBytes, mergeUint8 } from \"../internal\"\nimport { compact } from \"./compact\"\n\nconst textEncoder = new TextEncoder()\nconst strEnc: Encoder<string> = (str) => {\n  const val = textEncoder.encode(str)\n  return mergeUint8([compact.enc(val.length), val])\n}\n\nconst textDecoder = new TextDecoder()\nconst strDec: Decoder<string> = toInternalBytes((bytes) => {\n  let nElements = compact.dec(bytes) as number\n  const dv = new DataView(bytes.buffer, bytes.i, nElements)\n  bytes.i += nElements\n  return textDecoder.decode(dv)\n})\n\nexport const str = createCodec(strEnc, strDec)\n", "import { Codec } from \"../types\"\nimport { createCodec } from \"../\"\n\nconst noop = (() => {}) as () => undefined\nconst emptyArr = new Uint8Array(0)\nexport const _void: Codec<undefined> = createCodec(() => emptyArr, noop)\n", "import { Encoder, Decoder, Codec } from \"../types\"\nimport { createCodec } from \"../\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { compact } from \"./compact\"\n\nconst BytesEnc = (nBytes?: number): Encoder<Uint8Array> =>\n  nBytes === undefined\n    ? (bytes) => mergeUint8([compact.enc(bytes.length), bytes])\n    : (bytes) => (bytes.length === nBytes ? bytes : bytes.slice(0, nBytes))\n\nconst BytesDec = (nBytes?: number): Decoder<Uint8Array> =>\n  toInternalBytes((bytes) => {\n    const len =\n      nBytes === undefined\n        ? (compact.dec(bytes) as number)\n        : nBytes !== Infinity\n        ? nBytes\n        : bytes.byteLength - bytes.i\n\n    const result = new Uint8Array(bytes.buffer.slice(bytes.i, bytes.i + len))\n    bytes.i += len\n    return result\n  })\n\nexport const Bytes = (nBytes?: number): Codec<Uint8Array> =>\n  createCodec(BytesEnc(nBytes), BytesDec(nBytes))\n\nBytes.enc = BytesEnc\nBytes.dec = BytesDec\n", "import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  StringRecord,\n} from \"../types\"\nimport { toInternalBytes, mapObject, mergeUint8 } from \"../internal\"\nimport { createCodec, u8 } from \"../\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> = UnionToIntersection<\n  T extends any ? () => T : never\n> extends () => infer R\n  ? R\n  : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\nconst enumEnc = <O extends StringRecord<Encoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O>,\n): Encoder<\n  {\n    [K in keyof O]: { tag: K; value: EncoderType<O[K]> }\n  }[keyof O]\n> => {\n  const keys = Object.keys(inner)\n  const mappedKeys = new Map<keyof O, number>(\n    x?.map((actualIdx, idx) => [keys[idx], actualIdx]) ??\n      keys.map((key, idx) => [key, idx]),\n  )\n  const getKey = (key: keyof O) => mappedKeys.get(key)!\n\n  return ({ tag, value }) =>\n    mergeUint8([u8.enc(getKey(tag)), (inner as any)[tag](value)])\n}\n\nconst enumDec = <O extends StringRecord<Decoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O>,\n): Decoder<\n  {\n    [K in keyof O]: { tag: K; value: DecoderType<O[K]> }\n  }[keyof O]\n> => {\n  const keys = Object.keys(inner)\n  const mappedKeys = new Map<number, string>(\n    x?.map((actualIdx, idx) => [actualIdx, keys[idx]]) ??\n      keys.map((key, idx) => [idx, key]),\n  )\n\n  return toInternalBytes((bytes) => {\n    const idx = u8.dec(bytes)\n    const tag = mappedKeys.get(idx)!\n    const innerDecoder = inner[tag]\n    return {\n      tag,\n      value: innerDecoder(bytes),\n    }\n  })\n}\n\nexport const Enum = <O extends StringRecord<Codec<any>>>(\n  inner: O,\n  ...args: [indexes?: RestrictedLenTuple<number, O>]\n): Codec<\n  {\n    [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n  }[keyof O]\n> =>\n  createCodec(\n    enumEnc(\n      mapObject(inner, ([encoder]) => encoder) as StringRecord<\n        O[keyof O][\"enc\"]\n      >,\n      ...(args as any[]),\n    ) as Encoder<\n      {\n        [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n      }[keyof O]\n    >,\n    enumDec(\n      mapObject(inner, ([, decoder]) => decoder) as StringRecord<\n        O[keyof O][\"dec\"]\n      >,\n      ...(args as any[]),\n    ) as Decoder<\n      {\n        [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n      }[keyof O]\n    >,\n  )\n\nEnum.enc = enumEnc\nEnum.dec = enumDec\n", "import { Decoder, Encoder, Codec } from \"../types\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { createCodec } from \"../utils\"\nimport { u8 } from \"./fixed-width-ints\"\n\nconst OptionDec = <T>(inner: Decoder<T>): Decoder<T | undefined> =>\n  toInternalBytes<T | undefined>((bytes) =>\n    u8[1](bytes) > 0 ? inner(bytes) : undefined,\n  )\n\nconst OptionEnc =\n  <T>(inner: Encoder<T>): Encoder<T | undefined> =>\n  (value) => {\n    const result = new Uint8Array(1)\n    if (value === undefined) return result\n    result[0] = 1\n    return mergeUint8([result, inner(value)])\n  }\n\nexport const Option = <T>(inner: Codec<T>): Codec<T | undefined> =>\n  createCodec(OptionEnc(inner[0]), OptionDec(inner[1]))\n\nOption.enc = OptionEnc\nOption.dec = OptionDec\n", "import { createCodec } from \"../utils\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { Decoder, Encoder, Codec } from \"../types\"\nimport { u8 } from \"./fixed-width-ints\"\n\nexport type ResultPayload<OK, KO> =\n  | { success: true; value: OK }\n  | { success: false; value: KO }\n\nconst ResultDec = <OK, KO>(\n  okDecoder: Decoder<OK>,\n  koDecoder: Decoder<KO>,\n): Decoder<ResultPayload<OK, KO>> =>\n  toInternalBytes((bytes) => {\n    const success = u8[1](bytes) === 0\n    const decoder = success ? okDecoder : koDecoder\n    const value = decoder(bytes)\n    return { success, value } as ResultPayload<OK, KO>\n  })\n\nconst ResultEnc =\n  <OK, KO>(\n    okEncoder: Encoder<OK>,\n    koEncoder: Encoder<KO>,\n  ): Encoder<ResultPayload<OK, KO>> =>\n  ({ success, value }) =>\n    mergeUint8([\n      u8[0](success ? 0 : 1),\n      (success ? okEncoder : koEncoder)(value as any),\n    ])\n\nexport const Result = <OK, KO>(\n  okCodec: Codec<OK>,\n  koCodec: Codec<KO>,\n): Codec<ResultPayload<OK, KO>> =>\n  createCodec(\n    ResultEnc(okCodec[0], koCodec[0]),\n    ResultDec(okCodec[1], koCodec[1]),\n  )\n\nResult.dec = ResultDec\nResult.enc = ResultEnc\n", "import { Codec, Decoder, Encoder } from \"../types\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { createCodec } from \"../utils\"\n\nconst TupleDec = <A extends Array<Decoder<any>>>(\n  ...decoders: A\n): Decoder<{ [K in keyof A]: A[K] extends Decoder<infer D> ? D : unknown }> =>\n  toInternalBytes((bytes) => decoders.map((decoder) => decoder(bytes)) as any)\n\nconst TupleEnc =\n  <A extends Array<Encoder<any>>>(\n    ...encoders: A\n  ): Encoder<{ [K in keyof A]: A[K] extends Encoder<infer D> ? D : unknown }> =>\n  (values) =>\n    mergeUint8(encoders.map((enc, idx) => enc(values[idx])))\n\nexport const Tuple = <A extends Array<Codec<any>>>(\n  ...codecs: A\n): Codec<{ [K in keyof A]: A[K] extends Codec<infer D> ? D : unknown }> =>\n  createCodec(\n    TupleEnc(...codecs.map(([encoder]) => encoder)),\n    TupleDec(...codecs.map(([, decoder]) => decoder)),\n  ) as any\n\nTuple.enc = TupleEnc\nTuple.dec = TupleDec\n", "import { mapObject } from \"../internal\"\nimport {\n  Codec,\n  EncoderType,\n  DecoderType,\n  CodecType,\n  Decoder,\n  Encoder,\n  StringRecord,\n} from \"../types\"\nimport { createCodec, enhanceDecoder, enhanceEncoder } from \"../utils\"\nimport { Tuple } from \"./Tuple\"\n\nconst StructEnc = <A extends StringRecord<Encoder<any>>>(\n  encoders: A,\n): Encoder<{ [K in keyof A]: EncoderType<A[K]> }> => {\n  const keys = Object.keys(encoders)\n  return enhanceEncoder(\n    Tuple.enc(...Object.values(encoders)),\n    (input: { [K in keyof A]: EncoderType<A[K]> }) => keys.map((k) => input[k]),\n  )\n}\n\nconst StructDec = <A extends StringRecord<Decoder<any>>>(\n  decoders: A,\n): Decoder<{ [K in keyof A]: DecoderType<A[K]> }> => {\n  const keys = Object.keys(decoders)\n  return enhanceDecoder(\n    Tuple.dec(...Object.values(decoders)),\n    (tuple: Array<any>) =>\n      Object.fromEntries(tuple.map((value, idx) => [keys[idx], value])) as any,\n  )\n}\n\nexport const Struct = <A extends StringRecord<Codec<any>>>(\n  codecs: A,\n): Codec<{ [K in keyof A]: CodecType<A[K]> }> =>\n  createCodec(\n    StructEnc(\n      mapObject(codecs, (x) => x[0]) as StringRecord<A[keyof A][0]>,\n    ) as any,\n    StructDec(\n      mapObject(codecs, (x) => x[1]) as StringRecord<A[keyof A][1]>,\n    ) as any,\n  )\n\nStruct.enc = StructEnc\nStruct.dec = StructDec\n", "import { toInternalBytes, mergeUint8 } from \"../internal\"\nimport { createCodec } from \"../utils\"\nimport { Codec, Decoder, Encoder } from \"../types\"\nimport { compact } from \"./compact\"\n\nconst VectorEnc = <T>(inner: Encoder<T>, size?: number): Encoder<Array<T>> =>\n  size! >= 0\n    ? (value) => mergeUint8(value.map(inner))\n    : (value) =>\n        mergeUint8([compact.enc(value.length), mergeUint8(value.map(inner))])\n\nconst VectorDec = <T>(getter: Decoder<T>, size?: number): Decoder<Array<T>> =>\n  toInternalBytes((bytes) => {\n    const nElements = size! >= 0 ? size! : compact.dec(bytes)\n    const result = new Array(nElements as number)\n\n    for (let i = 0; i < nElements; i++) {\n      result[i] = getter(bytes)\n    }\n\n    return result\n  })\n\nexport const Vector = <T>(inner: Codec<T>, size?: number): Codec<Array<T>> =>\n  createCodec(VectorEnc(inner[0], size), VectorDec(inner[1], size))\n\nVector.enc = VectorEnc\nVector.dec = VectorDec\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// TODO: temporarily set to false, trying to understand bugs\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) {\n    astr('base64', s); return (Uint8Array as any).fromBase64(s, { lastChunkHandling: 'strict' });\n  },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { astr('base64', s); return (Uint8Array as any).fromBase64(s, { alphabet: 'base64url' }); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { rotr } from './utils.ts';\n\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const BSIGMA: Uint8Array = /* @__PURE__ */ Uint8Array.from([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  // Blake1, unused in others\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n\n// prettier-ignore\nexport type Num4 = { a: number; b: number; c: number; d: number; };\n\n// Mixing function G splitted in two halfs\nexport function G1s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 16);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 12);\n  return { a, b, c, d };\n}\n\nexport function G2s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 8);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 7);\n  return { a, b, c, d };\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\nimport { BSIGMA, G1s, G2s } from './_blake.ts';\nimport { SHA256_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32,\n  type CHashO, type Input\n} from './utils.ts';\n\n/** Blake hash options. dkLen is output length. key is used in MAC mode. salt is used in KDF mode. */\nexport type Blake2Opts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n\n// Mixing function G splitted in two halfs\nfunction G1b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 24)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction G2b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 63)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction checkBlake2Opts(\n  outputLen: number,\n  opts: Blake2Opts | undefined = {},\n  keyLen: number,\n  saltLen: number,\n  persLen: number\n) {\n  anumber(keyLen);\n  if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n  const { key, salt, personalization } = opts;\n  if (key !== undefined && (key.length < 1 || key.length > keyLen))\n    throw new Error('key length must be undefined or 1..' + keyLen);\n  if (salt !== undefined && salt.length !== saltLen)\n    throw new Error('salt must be undefined or ' + saltLen);\n  if (personalization !== undefined && personalization.length !== persLen)\n    throw new Error('personalization must be undefined or ' + persLen);\n}\n\n/** Class, from which others are subclassed. */\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected finished = false;\n  protected destroyed = false;\n  protected length: number = 0;\n  protected pos: number = 0;\n  readonly blockLen: number;\n  readonly outputLen: number;\n\n  constructor(blockLen: number, outputLen: number) {\n    super();\n    anumber(blockLen);\n    anumber(outputLen);\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        swap32IfBE(buffer32);\n        this.compress(buffer32, 0, false);\n        swap32IfBE(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        swap32IfBE(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        swap32IfBE(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(pos));\n    swap32IfBE(buffer32);\n    this.compress(buffer32, 0, true);\n    swap32IfBE(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.buffer.set(buffer);\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    // @ts-ignore\n    to.outputLen = outputLen;\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\nexport class BLAKE2b extends BLAKE2<BLAKE2b> {\n  // Same as SHA-512, but LE\n  private v0l = B2B_IV[0] | 0;\n  private v0h = B2B_IV[1] | 0;\n  private v1l = B2B_IV[2] | 0;\n  private v1h = B2B_IV[3] | 0;\n  private v2l = B2B_IV[4] | 0;\n  private v2h = B2B_IV[5] | 0;\n  private v3l = B2B_IV[6] | 0;\n  private v3h = B2B_IV[7] | 0;\n  private v4l = B2B_IV[8] | 0;\n  private v4h = B2B_IV[9] | 0;\n  private v5l = B2B_IV[10] | 0;\n  private v5h = B2B_IV[11] | 0;\n  private v6l = B2B_IV[12] | 0;\n  private v6h = B2B_IV[13] | 0;\n  private v7l = B2B_IV[14] | 0;\n  private v7h = B2B_IV[15] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n    super(128, olen);\n    checkBlake2Opts(olen, opts, 64, 16, 16);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt);\n      this.v4l ^= swap8IfBE(slt[0]);\n      this.v4h ^= swap8IfBE(slt[1]);\n      this.v5l ^= swap8IfBE(slt[2]);\n      this.v5h ^= swap8IfBE(slt[3]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization);\n      this.v6l ^= swap8IfBE(pers[0]);\n      this.v6h ^= swap8IfBE(pers[1]);\n      this.v7l ^= swap8IfBE(pers[2]);\n      this.v7h ^= swap8IfBE(pers[3]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n  }\n  // prettier-ignore\n  protected set(\n    v0l: number, v0h: number, v1l: number, v1h: number,\n    v2l: number, v2h: number, v3l: number, v3h: number,\n    v4l: number, v4h: number, v5l: number, v5h: number,\n    v6l: number, v6h: number, v7l: number, v7h: number\n  ): void {\n    this.v0l = v0l | 0;\n    this.v0h = v0h | 0;\n    this.v1l = v1l | 0;\n    this.v1h = v1h | 0;\n    this.v2l = v2l | 0;\n    this.v2h = v2h | 0;\n    this.v3l = v3l | 0;\n    this.v3h = v3h | 0;\n    this.v4l = v4l | 0;\n    this.v4h = v4h | 0;\n    this.v5l = v5l | 0;\n    this.v5h = v5h | 0;\n    this.v6l = v6l | 0;\n    this.v6h = v6h | 0;\n    this.v7l = v7l | 0;\n    this.v7h = v7h | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n    BBUF.set(B2B_IV, 16); // Second half from IV.\n    let { h, l } = u64.fromBig(BigInt(this.length));\n    BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n    BBUF[25] = B2B_IV[9] ^ h; // High word.\n    // Invert all bits for last block\n    if (isLast) {\n      BBUF[28] = ~BBUF[28];\n      BBUF[29] = ~BBUF[29];\n    }\n    let j = 0;\n    const s = BSIGMA;\n    for (let i = 0; i < 12; i++) {\n      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n\n      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n    }\n    this.v0l ^= BBUF[0] ^ BBUF[16];\n    this.v0h ^= BBUF[1] ^ BBUF[17];\n    this.v1l ^= BBUF[2] ^ BBUF[18];\n    this.v1h ^= BBUF[3] ^ BBUF[19];\n    this.v2l ^= BBUF[4] ^ BBUF[20];\n    this.v2h ^= BBUF[5] ^ BBUF[21];\n    this.v3l ^= BBUF[6] ^ BBUF[22];\n    this.v3h ^= BBUF[7] ^ BBUF[23];\n    this.v4l ^= BBUF[8] ^ BBUF[24];\n    this.v4h ^= BBUF[9] ^ BBUF[25];\n    this.v5l ^= BBUF[10] ^ BBUF[26];\n    this.v5h ^= BBUF[11] ^ BBUF[27];\n    this.v6l ^= BBUF[12] ^ BBUF[28];\n    this.v6h ^= BBUF[13] ^ BBUF[29];\n    this.v7l ^= BBUF[14] ^ BBUF[30];\n    this.v7h ^= BBUF[15] ^ BBUF[31];\n    clean(BBUF);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2b, Blake2Opts>(\n  (opts) => new BLAKE2b(opts)\n);\n\n// =================\n// Blake2S\n// =================\n\n// prettier-ignore\nexport type Num16 = {\n  v0: number; v1: number; v2: number; v3: number;\n  v4: number; v5: number; v6: number; v7: number;\n  v8: number; v9: number; v10: number; v11: number;\n  v12: number; v13: number; v14: number; v15: number;\n};\n\n// prettier-ignore\nexport function compress(s: Uint8Array, offset: number, msg: Uint32Array, rounds: number,\n  v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number,\n  v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n): Num16 {\n  let j = 0;\n  for (let i = 0; i < rounds; i++) {\n    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\n\n    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\n  }\n  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\n\nconst B2S_IV = SHA256_IV;\nexport class BLAKE2s extends BLAKE2<BLAKE2s> {\n  // Internal state, same as SHA-256\n  private v0 = B2S_IV[0] | 0;\n  private v1 = B2S_IV[1] | 0;\n  private v2 = B2S_IV[2] | 0;\n  private v3 = B2S_IV[3] | 0;\n  private v4 = B2S_IV[4] | 0;\n  private v5 = B2S_IV[5] | 0;\n  private v6 = B2S_IV[6] | 0;\n  private v7 = B2S_IV[7] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n    super(64, olen);\n    checkBlake2Opts(olen, opts, 32, 8, 8);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt as Uint8Array);\n      this.v4 ^= swap8IfBE(slt[0]);\n      this.v5 ^= swap8IfBE(slt[1]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization as Uint8Array);\n      this.v6 ^= swap8IfBE(pers[0]);\n      this.v7 ^= swap8IfBE(pers[1]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      abytes(key);\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n    return [v0, v1, v2, v3, v4, v5, v6, v7];\n  }\n  // prettier-ignore\n  protected set(\n    v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number\n  ): void {\n    this.v0 = v0 | 0;\n    this.v1 = v1 | 0;\n    this.v2 = v2 | 0;\n    this.v3 = v3 | 0;\n    this.v4 = v4 | 0;\n    this.v5 = v5 | 0;\n    this.v6 = v6 | 0;\n    this.v7 = v7 | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    const { h, l } = u64.fromBig(BigInt(this.length));\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        BSIGMA, offset, msg, 10,\n        this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7,\n        B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]\n      );\n    this.v0 ^= v0 ^ v8;\n    this.v1 ^= v1 ^ v9;\n    this.v2 ^= v2 ^ v10;\n    this.v3 ^= v3 ^ v11;\n    this.v4 ^= v4 ^ v12;\n    this.v5 ^= v5 ^ v13;\n    this.v6 ^= v6 ^ v14;\n    this.v7 ^= v7 ^ v15;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2s: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2s, Blake2Opts>(\n  (opts) => new BLAKE2s(opts)\n);\n", "/**\n * Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.\n * @module\n * @deprecated\n */\nimport { BLAKE2b as B2B, blake2b as b2b } from './blake2.ts';\n/** @deprecated Use import from `noble/hashes/blake2` module */\nexport const BLAKE2b: typeof B2B = B2B;\n/** @deprecated Use import from `noble/hashes/blake2` module */\nexport const blake2b: typeof b2b = b2b;\n", "import { base58 } from \"@scure/base\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\n\nconst SS58_PREFIX = new TextEncoder().encode(\"SS58PRE\")\nconst CHECKSUM_LENGTH = 2\n\nexport type SS58String = string & { __SS58String?: unknown }\nexport type SS58AddressInfo =\n  | { isValid: false }\n  | { isValid: true; ss58Format: number; publicKey: Uint8Array }\n\nexport const getSs58AddressInfo = (address: SS58String): SS58AddressInfo => {\n  try {\n    const decoded = base58.decode(address)\n    const prefixBytes = decoded.subarray(0, decoded[0] & 0b0100_0000 ? 2 : 1)\n    const publicKey = decoded.subarray(\n      prefixBytes.length,\n      decoded.length - CHECKSUM_LENGTH,\n    )\n\n    const checksum = decoded.subarray(prefixBytes.length + publicKey.length)\n    const expectedChecksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n\n    const isChecksumValid =\n      checksum[0] === expectedChecksum[0] && checksum[1] === expectedChecksum[1]\n\n    if (!isChecksumValid) return { isValid: false }\n\n    return {\n      isValid: true,\n      ss58Format: prefixBytesToNumber(prefixBytes),\n      publicKey: publicKey.slice(),\n    }\n  } catch (_) {\n    return { isValid: false }\n  }\n}\n\nconst prefixBytesToNumber = (bytes: Uint8Array) => {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0)\n}\n\nexport const fromBufferToBase58 = (ss58Format: number) => {\n  const prefixBytes =\n    ss58Format < 64\n      ? Uint8Array.of(ss58Format)\n      : Uint8Array.of(\n          ((ss58Format & 0b0000_0000_1111_1100) >> 2) | 0b0100_0000,\n          (ss58Format >> 8) | ((ss58Format & 0b0000_0000_0000_0011) << 6),\n        )\n\n  return (publicKey: Uint8Array): SS58String => {\n    const checksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n    return base58.encode(\n      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum),\n    )\n  }\n}\n", "import { Bytes, enhanceCodec } from \"scale-ts\"\nimport {\n  getSs58AddressInfo,\n  SS58String,\n  fromBufferToBase58,\n} from \"@/utils/ss58-util\"\n\nfunction fromBase58ToBuffer(nBytes: number, _ss58Format: number) {\n  return (address: SS58String) => {\n    const info = getSs58AddressInfo(address)\n    if (!info.isValid) throw new Error(\"Invalid checksum\")\n    const { publicKey } = info\n    if (publicKey.length !== nBytes)\n      throw new Error(\"Invalid public key length\")\n\n    return publicKey\n  }\n}\n\nexport const AccountId = (ss58Format: number = 42, nBytes: 32 | 33 = 32) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    fromBase58ToBuffer(nBytes, ss58Format),\n    fromBufferToBase58(ss58Format),\n  )\n", "// https://jsben.ch/uWZw3\nconst HEX_STR = \"0123456789abcdef\"\nexport function toHex(bytes: Uint8Array): string {\n  const result = new Array<string>(bytes.length + 1)\n\n  result[0] = \"0x\"\n\n  for (let i = 0; i < bytes.length; ) {\n    const b = bytes[i++]\n    result[i] = HEX_STR[b >> 4] + HEX_STR[b & 15]\n  }\n\n  return result.join(\"\")\n}\n\n// https://jsben.ch/URe1X\nconst HEX_MAP: Record<string, number> = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n}\nexport function fromHex(hexString: string): Uint8Array {\n  const isOdd = hexString.length % 2\n  const base = (hexString[1] === \"x\" ? 2 : 0) + isOdd\n  const nBytes = (hexString.length - base) / 2 + isOdd\n  const bytes = new Uint8Array(nBytes)\n\n  if (isOdd) bytes[0] = 0 | HEX_MAP[hexString[2]]\n\n  for (let i = 0; i < nBytes; ) {\n    const idx = base + i * 2\n    const a = HEX_MAP[hexString[idx]]\n    const b = HEX_MAP[hexString[idx + 1]]\n    bytes[isOdd + i++] = (a << 4) | b\n  }\n\n  return bytes\n}\n", "export function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k: K) => O,\n): Record<K, O>\n\nexport function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k?: K) => O,\n): Record<K, O> {\n  return Object.fromEntries(\n    Object.entries(input).map(\n      ([key, value]: any) => [key, mapper(value, key)] as const,\n    ),\n  ) as any\n}\n\nexport type StringRecord<T> = {\n  [Sym: symbol]: never\n  [Num: number]: never\n  [Str: string]: T\n}\n\nexport const mapStringRecord = <I, O>(\n  input: StringRecord<I>,\n  mapper: (value: I, key: string) => O,\n): StringRecord<O> =>\n  Object.fromEntries(\n    Object.entries(input).map(([key, value]) => [key, mapper(value, key)]),\n  ) as StringRecord<O>\n", "export const mergeUint8 = (...inputs: Array<Uint8Array>): Uint8Array => {\n  const totalLen = inputs.reduce((acc, a) => acc + a.byteLength, 0)\n  const result = new Uint8Array(totalLen)\n\n  for (let idx = 0, at = 0; idx < inputs.length; idx++) {\n    const current = inputs[idx]\n    result.set(current, at)\n    at += current.byteLength\n  }\n\n  return result\n}\n", "export const noop: () => void = Function.prototype as any\n", "export class AbortError extends Error {\n  constructor() {\n    super(\"Abort Error\")\n    this.name = \"AbortError\"\n  }\n}\n", "import {\n  Bytes,\n  Codec,\n  Decoder,\n  Encoder,\n  Tuple,\n  compact,\n  createCodec,\n} from \"scale-ts\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport type { HexString } from \"./Hex\"\nimport { SS58String } from \"@/utils\"\nimport { AccountId } from \"./AccountId\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\nconst opaqueBytesDec = Tuple(compact, Bytes(Infinity))[1]\n\nexport class Binary {\n  #bytes: Uint8Array\n  #opaqueBytes: Uint8Array | null = null\n  #hex: HexString | null = null\n  #opaqueHex: HexString | null = null\n  #str: string | null = null\n\n  constructor(data: Uint8Array, opaque = false) {\n    if (opaque) {\n      try {\n        const [len, bytes] = opaqueBytesDec(data)\n        if (len === bytes.length) {\n          this.#bytes = bytes\n          this.#opaqueBytes = data\n          return\n        }\n      } catch (_) {}\n      throw new Error(\"Invalid opaque bytes\")\n    } else this.#bytes = data\n  }\n\n  asText = () => (this.#str ??= textDecoder.decode(this.#bytes))\n\n  asHex = () => (this.#hex ||= toHex(this.#bytes))\n  asOpaqueHex = () => (this.#opaqueHex ||= toHex(this.asBytes()))\n\n  asBytes = () => this.#bytes\n  asOpaqueBytes = () =>\n    (this.#opaqueBytes ||= mergeUint8(\n      compact[0](this.#bytes.length),\n      this.#bytes,\n    ))\n\n  static fromText(input: string): Binary {\n    return new this(textEncoder.encode(input))\n  }\n\n  static fromHex(input: HexString): Binary {\n    return new this(fromHex(input))\n  }\n  static fromOpaqueHex(input: HexString): Binary {\n    return new this(fromHex(input), true)\n  }\n\n  static fromBytes(input: Uint8Array): Binary {\n    return new this(input)\n  }\n  static fromOpaqueBytes(input: Uint8Array): Binary {\n    return new this(input, true)\n  }\n}\n\nconst [accountIdEncoder] = AccountId()\nexport class FixedSizeBinary<_L extends number> extends Binary {\n  constructor(data: Uint8Array) {\n    super(data)\n  }\n\n  static fromArray<L extends number, I extends Array<number> & { length: L }>(\n    input: I,\n  ) {\n    return new this<L>(new Uint8Array(input))\n  }\n\n  static fromAccountId32<L extends number>(\n    input: L extends 32 ? SS58String : never,\n  ) {\n    return new this<L>(accountIdEncoder(input))\n  }\n}\n\nconst enc = (nBytes?: number): Encoder<Binary> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value) => _enc(value.asBytes())\n}\n\nconst dec = (nBytes?: number): Decoder<Binary> => {\n  const _dec = Bytes.dec(nBytes)\n  const Bin = nBytes == null ? Binary : FixedSizeBinary\n  return (value) => Bin.fromBytes(_dec(value))\n}\n\nexport const Bin = (nBytes?: number): Codec<Binary> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nBin.enc = enc\nBin.dec = dec\n", "import { compact, enhanceCodec } from \"scale-ts\"\n\nexport const compactNumber = enhanceCodec(compact, (v) => v, Number)\nexport const compactBn = enhanceCodec(compact, (v) => v, BigInt)\n", "import { Bytes, Decoder, Encoder, createCodec, createDecoder } from \"scale-ts\"\nimport { compactNumber } from \"./compact\"\n\nexport interface BitSequence {\n  bitsLen: number\n  bytes: Uint8Array\n}\n\nconst bitSequenceDecoder: Decoder<BitSequence> = createDecoder((data) => {\n  const bitsLen = compactNumber.dec(data)\n\n  const bytesLen = Math.ceil(bitsLen / 8)\n  const bytes = Bytes(bytesLen).dec(data)\n  return { bytes, bitsLen }\n})\n\nconst bitSequenceEncoder: Encoder<BitSequence> = (input) => {\n  if (input.bitsLen > input.bytes.length * 8)\n    throw new Error(\n      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`,\n    )\n\n  const lenEncoded = compactNumber.enc(input.bitsLen)\n  const result = new Uint8Array(input.bytes.length + lenEncoded.length)\n  result.set(lenEncoded, 0)\n  result.set(input.bytes, lenEncoded.length)\n  return result\n}\n\nexport const bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder)\n", "import { enhanceCodec, u8 } from \"scale-ts\"\n\nexport const char = enhanceCodec(\n  u8,\n  (str: string) => str.charCodeAt(0),\n  String.fromCharCode,\n)\n", "import { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { Bytes, Codec, Decoder, Encoder, createCodec } from \"scale-ts\"\n\nexport type HexString = string & { __hexString?: unknown }\n\nconst enc = (nBytes?: number): Encoder<HexString> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value: string) => _enc(fromHex(value))\n}\n\nconst dec = (nBytes?: number): Decoder<HexString> => {\n  const _dec = Bytes.dec(nBytes)\n  return (value) => toHex(_dec(value)) as HexString\n}\n\nexport const Hex = (nBytes?: number): Codec<HexString> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nHex.enc = enc\nHex.dec = dec\n", "import { Bytes, enhanceCodec } from \"scale-ts\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const fixedStr = (nBytes: number) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    (str: string) => textEncoder.encode(str),\n    (bytes) => textDecoder.decode(bytes),\n  )\n", "import { Codec, Decoder, Encoder, createCodec, _void } from \"scale-ts\"\n\nexport const selfEncoder = <T>(value: () => Encoder<T>): Encoder<T> => {\n  let cache: Encoder<T> = (x) => {\n    const encoder = value()\n    cache = encoder\n    return encoder(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const selfDecoder = <T>(value: () => Decoder<T>): Decoder<T> => {\n  let cache: Decoder<T> = (x) => {\n    const decoder = value()\n    const result = decoder\n    cache = decoder\n    return result(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const Self = <T>(value: () => Codec<T>): Codec<T> =>\n  createCodec(\n    selfEncoder(() => value().enc),\n    selfDecoder(() => value().dec),\n  )\n", "export const withInner = <T, I>(codec: T, inner: I): T & { inner: I } => {\n  const result: T & { inner: I } = codec as any\n  result.inner = inner\n  return result\n}\n", "import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  Enum as OEnum,\n  StringRecord,\n  createCodec,\n} from \"scale-ts\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport { Enum } from \"@/types/enum\"\nimport { withInner } from \"./with-inner\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> =\n  UnionToIntersection<T extends any ? () => T : never> extends () => infer R\n    ? R\n    : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\nconst VariantEnc: <O extends StringRecord<Encoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O> | undefined,\n) => Encoder<\n  Enum<{\n    [K in keyof O]: EncoderType<O[K]>\n  }>\n> & { inner: O } = (...args) => {\n  const enc = OEnum.enc(...(args as [any, any]))\n  return withInner((v: any) => enc({ tag: v.type, value: v.value }), args[0])\n}\n\nconst VariantDec: <O extends StringRecord<Decoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O> | undefined,\n) => Decoder<\n  Enum<{\n    [K in keyof O]: DecoderType<O[K]>\n  }>\n> & { inner: O } = (...args) => {\n  const dec = OEnum.dec(...(args as [any]))\n  return withInner((v: any) => {\n    const { tag, value } = dec(v)\n    return Enum(tag as any, value as any) as any\n  }, args[0])\n}\n\nexport const Variant: {\n  <O extends StringRecord<Codec<any>>>(\n    inner: O,\n    indexes?: RestrictedLenTuple<number, O> | undefined,\n  ): Codec<\n    Enum<{\n      [K in keyof O]: CodecType<O[K]>\n    }>\n  > & { inner: O }\n  enc: <O_1 extends StringRecord<Encoder<any>>>(\n    inner: O_1,\n    x?: RestrictedLenTuple<number, O_1> | undefined,\n  ) => Encoder<\n    Enum<{\n      [K in keyof O_1]: EncoderType<O_1[K]>\n    }>\n  > & { inner: O_1 }\n  dec: <O_2 extends StringRecord<Decoder<any>>>(\n    inner: O_2,\n    x?: RestrictedLenTuple<number, O_2> | undefined,\n  ) => Decoder<\n    Enum<{\n      [K in keyof O_2]: DecoderType<O_2[K]>\n    }>\n  > & { inner: O_2 }\n} = (inner, ...args) =>\n  withInner(\n    createCodec(\n      VariantEnc(\n        mapObject(inner, ([encoder]) => encoder) as any,\n        ...(args as any[]),\n      ),\n      VariantDec(\n        mapObject(inner, ([, decoder]) => decoder) as any,\n        ...(args as any[]),\n      ) as any,\n    ),\n    inner,\n  ) as any\nVariant.enc = VariantEnc\nVariant.dec = VariantDec\n\nexport const ScaleEnum: {\n  <O extends StringRecord<Codec<any>>>(\n    inner: O,\n    indexes?: RestrictedLenTuple<number, O> | undefined,\n  ): Codec<\n    {\n      [K in keyof O]: {\n        tag: K\n        value: CodecType<O[K]>\n      }\n    }[keyof O]\n  > & { inner: O }\n  enc: <O_1 extends StringRecord<Encoder<any>>>(\n    inner: O_1,\n    x?: RestrictedLenTuple<number, O_1> | undefined,\n  ) => Encoder<\n    {\n      [K_1 in keyof O_1]: {\n        tag: K_1\n        value: EncoderType<O_1[K_1]>\n      }\n    }[keyof O_1]\n  > & { inner: O_1 }\n  dec: <O_2 extends StringRecord<Decoder<any>>>(\n    inner: O_2,\n    x?: RestrictedLenTuple<number, O_2> | undefined,\n  ) => Decoder<\n    {\n      [K_2 in keyof O_2]: {\n        tag: K_2\n        value: DecoderType<O_2[K_2]>\n      }\n    }[keyof O_2]\n  > & { inner: O_2 }\n} = (inner, ...args) => withInner(OEnum(inner, ...(args as any[])), inner)\nScaleEnum.enc = (inner, ...rest) =>\n  withInner(OEnum.enc(inner, ...(rest as any[])), inner)\nScaleEnum.dec = (inner, ...rest) =>\n  withInner(OEnum.dec(inner, ...(rest as any[])), inner)\n", "/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createHasher, createXOFer, Hash,\n  swap32IfBE,\n  toBytes, u32,\n  type CHash, type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\n\n/** Keccak sponge function. */\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n\n  public blockLen: number;\n  public suffix: number;\n  public outputLen: number;\n  protected enableXOF = false;\n  protected rounds: number;\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    blockLen: number,\n    suffix: number,\n    outputLen: number,\n    enableXOF = false,\n    rounds: number = 24\n  ) {\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (!(0 < blockLen && blockLen < 200))\n      throw new Error('only keccak-f1600 function is supported');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  clone(): Keccak {\n    return this._cloneInto();\n  }\n  protected keccak(): void {\n    swap32IfBE(this.state32);\n    keccakP(this.state32, this.rounds);\n    swap32IfBE(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { blockLen, state } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  createHasher(() => new Keccak(blockLen, suffix, outputLen));\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  createXOFer<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n", "import { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { Bytes, createCodec, createDecoder } from \"scale-ts\"\nimport { keccak_256 as keccak } from \"@noble/hashes/sha3\"\n\nconst getFormattedAddress = (hexAddress: string) => {\n  const nonChecksum = hexAddress.slice(2)\n  const hashedAddress = toHex(keccak(nonChecksum)).slice(2)\n\n  const result = new Array(40)\n\n  for (let i = 0; i < 40; i++) {\n    const checksumVal = parseInt(hashedAddress[i], 16)\n    const char = nonChecksum[i]\n    result[i] = checksumVal > 7 ? char.toUpperCase() : char\n  }\n\n  return `0x${result.join(\"\")}`\n}\n\nconst bytes20Dec = Bytes(20)[1]\n\nexport const ethAccount = createCodec<string>(\n  (input: string) => {\n    const bytes = fromHex(input)\n    if (bytes.length !== 20)\n      throw new Error(`Invalid length found on EthAddress(${input})`)\n\n    const hexAddress = toHex(bytes)\n    if (input === hexAddress || input === hexAddress.toUpperCase()) return bytes\n\n    if (getFormattedAddress(hexAddress) !== input)\n      throw new Error(`Invalid checksum found on EthAddress(${input})`)\n\n    return bytes\n  },\n  createDecoder((bytes) => getFormattedAddress(toHex(bytes20Dec(bytes)))),\n)\n", "import {\n  Struct as OStruct,\n  Tuple as OTuple,\n  Vector as OVector,\n  Result as OResult,\n  Option as OOption,\n  Codec,\n  Encoder,\n  Decoder,\n  StringRecord,\n  CodecType,\n  EncoderType,\n  DecoderType,\n  ResultPayload,\n} from \"scale-ts\"\nimport { withInner } from \"./with-inner\"\n\nexport const Struct: {\n  <A extends StringRecord<Codec<any>>>(\n    codecs: A,\n  ): Codec<{ [K in keyof A]: CodecType<A[K]> }> & { inner: A }\n  enc: <A_1 extends StringRecord<Encoder<any>>>(\n    encoders: A_1,\n  ) => Encoder<{ [K_1 in keyof A_1]: EncoderType<A_1[K_1]> }> & { inner: A_1 }\n  dec: <A_2 extends StringRecord<Decoder<any>>>(\n    decoders: A_2,\n  ) => Decoder<{ [K_2 in keyof A_2]: DecoderType<A_2[K_2]> }> & { inner: A_2 }\n} = (codecs) => withInner(OStruct(codecs), codecs)\nStruct.enc = (x) => withInner(OStruct.enc(x), x)\nStruct.dec = (x) => withInner(OStruct.dec(x), x)\n\nexport const Tuple: {\n  <A extends Codec<any>[]>(\n    ...inner: A\n  ): Codec<{ [K in keyof A]: A[K] extends Codec<infer D> ? D : unknown }> & {\n    inner: A\n  }\n  enc: <A_1 extends Encoder<any>[]>(\n    ...encoders: A_1\n  ) => Encoder<{\n    [K_1 in keyof A_1]: A_1[K_1] extends Encoder<infer D_1> ? D_1 : unknown\n  }> & { inner: A_1 }\n  dec: <A_2 extends Decoder<any>[]>(\n    ...decoders: A_2\n  ) => Decoder<{\n    [K_2 in keyof A_2]: A_2[K_2] extends Decoder<infer D_2> ? D_2 : unknown\n  }> & { inner: A_2 }\n} = (...inner) => withInner(OTuple(...inner), inner)\nTuple.enc = (...inner) => withInner(OTuple.enc(...inner), inner)\nTuple.dec = (...inner) => withInner(OTuple.dec(...inner), inner)\n\nexport const Vector: {\n  <T>(\n    inner: Codec<T>,\n    size?: number | undefined,\n  ): Codec<T[]> & { inner: Codec<T> }\n  enc: <T_1>(\n    inner: Encoder<T_1>,\n    size?: number | undefined,\n  ) => Encoder<T_1[]> & { inner: Encoder<T_1> }\n  dec: <T_2>(\n    getter: Decoder<T_2>,\n    size?: number | undefined,\n  ) => Decoder<T_2[]> & { inner: Decoder<T_2> }\n} = (inner, ...rest) => withInner(OVector(inner, ...rest), inner)\nVector.enc = (inner, ...rest) => withInner(OVector.enc(inner, ...rest), inner)\nVector.dec = (inner, ...rest) => withInner(OVector.dec(inner, ...rest), inner)\n\nexport const Result: {\n  <OK, KO>(\n    okCodec: Codec<OK>,\n    koCodec: Codec<KO>,\n  ): Codec<ResultPayload<OK, KO>> & { inner: { ok: Codec<OK>; ko: Codec<KO> } }\n  dec: <OK_1, KO_1>(\n    okDecoder: Decoder<OK_1>,\n    koDecoder: Decoder<KO_1>,\n  ) => Decoder<ResultPayload<OK_1, KO_1>> & {\n    inner: { ok: Decoder<OK_1>; ko: Decoder<KO_1> }\n  }\n  enc: <OK_2, KO_2>(\n    okEncoder: Encoder<OK_2>,\n    koEncoder: Encoder<KO_2>,\n  ) => Encoder<ResultPayload<OK_2, KO_2>> & {\n    inner: { ok: Encoder<OK_2>; ko: Encoder<KO_2> }\n  }\n} = (ok, ko) => withInner(OResult(ok, ko), { ok, ko })\nResult.enc = (ok, ko) => withInner(OResult.enc(ok, ko), { ok, ko })\nResult.dec = (ok, ko) => withInner(OResult.dec(ok, ko), { ok, ko })\n\nexport const Option: {\n  <T>(inner: Codec<T>): Codec<T | undefined> & { inner: Codec<T> }\n  enc: <T_1>(\n    inner: Encoder<T_1>,\n  ) => Encoder<T_1 | undefined> & { inner: Encoder<T_1> }\n  dec: <T_2>(\n    inner: Decoder<T_2>,\n  ) => Decoder<T_2 | undefined> & { inner: Decoder<T_2> }\n} = (inner) => withInner(OOption(inner), inner)\nOption.enc = (inner) => withInner(OOption.enc(inner), inner)\nOption.dec = (inner) => withInner(OOption.dec(inner), inner)\n", "import {\n  Bytes,\n  CodecType,\n  Struct,\n  Vector,\n  _void,\n  enhanceCodec,\n  Hex,\n  Variant,\n  compactNumber,\n} from \"./scale\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst fourChars = enhanceCodec(\n  Bytes(4),\n  textEncoder.encode.bind(textEncoder),\n  textDecoder.decode.bind(textDecoder),\n)\n\nconst diggestVal = Struct({\n  engine: fourChars,\n  payload: Hex(),\n})\n\nconst diggest = Variant(\n  {\n    consensus: diggestVal,\n    seal: diggestVal,\n    preRuntime: diggestVal,\n    runtimeUpdated: _void,\n  },\n  [4, 5, 6, 8],\n)\n\nconst hex32 = Hex(32)\nexport const blockHeader = Struct({\n  parentHash: hex32,\n  number: compactNumber,\n  stateRoot: hex32,\n  extrinsicRoot: hex32,\n  digests: Vector(diggest),\n})\n\nexport type BlockHeader = CodecType<typeof blockHeader>\n", "import { Vector, str } from \"scale-ts\"\n\nexport const docs = Vector(str)\n", "import { compactNumber } from \"../scale/compact\"\nimport {\n  CodecType,\n  Enum,\n  Option,\n  Struct,\n  Vector,\n  _void,\n  str,\n  u32,\n  u8,\n} from \"scale-ts\"\nimport { docs } from \"./docs\"\n\nconst oStr = Option(str)\n\nconst primitive = Enum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\n\nconst fields = Vector(\n  Struct({\n    name: oStr,\n    type: compactNumber,\n    typeName: oStr,\n    docs,\n  }),\n)\n\nconst arr = Struct({\n  len: u32,\n  type: compactNumber,\n})\n\nconst bitSequence = Struct({\n  bitStoreType: compactNumber,\n  bitOrderType: compactNumber,\n})\n\nconst variant = Vector(\n  Struct({\n    name: str,\n    fields,\n    index: u8,\n    docs,\n  }),\n)\n\nconst def = Enum({\n  composite: fields,\n  variant,\n  sequence: compactNumber,\n  array: arr,\n  tuple: Vector(compactNumber),\n  primitive,\n  compact: compactNumber,\n  bitSequence,\n})\n\nconst param = Struct({\n  name: str,\n  type: Option(compactNumber),\n})\nconst params = Vector(param)\n\nconst entry = Struct({\n  id: compactNumber,\n  path: docs,\n  params,\n  def,\n  docs,\n})\n\nexport const lookup = Vector(entry)\nexport type V14Lookup = CodecType<typeof lookup>\n", "import { _void, Enum, Option, str, Struct, u8, Vector } from \"scale-ts\"\n\nexport const itemDeprecation = Enum({\n  NotDeprecated: _void,\n  DeprecatedWithoutNote: _void,\n  Deprecated: Struct({\n    note: str,\n    since: Option(str),\n  }),\n})\n\nexport const variantDeprecation = Vector(\n  Struct({\n    index: u8,\n    deprecation: Enum(\n      {\n        DeprecatedWithoutNote: _void,\n        Deprecated: Struct({\n          note: str,\n          since: Option(str),\n        }),\n      },\n      [1, 2],\n    ),\n  }),\n)\n", "import { Struct, Vector, str } from \"scale-ts\"\nimport { docs } from \"./docs\"\nimport { compactNumber, Hex, compactNumber as ty } from \"../scale\"\nimport { itemDeprecation } from \"./deprecation\"\n\nexport const runtimeApiMethod = {\n  name: str,\n  inputs: Vector(\n    Struct({\n      name: str,\n      type: ty,\n    }),\n  ),\n  output: ty,\n  docs,\n}\n\nexport const runtimeApiV15 = Struct({\n  name: str,\n  methods: Vector(Struct(runtimeApiMethod)),\n  docs,\n})\n\nexport const runtimeApi = Struct({\n  name: str,\n  methods: Vector(\n    Struct({ ...runtimeApiMethod, deprecationInfo: itemDeprecation }),\n  ),\n  docs,\n  version: compactNumber,\n  deprecationInfo: itemDeprecation,\n})\n\nexport const viewFunction = Struct({\n  id: Hex(32),\n  ...runtimeApiMethod,\n  deprecationInfo: itemDeprecation,\n})\n", "import { Hex, compactNumber } from \"@/codecs/scale\"\nimport { Struct, Option, Vector, u8, str, Enum, _void } from \"scale-ts\"\nimport { docs } from \"./docs\"\nimport { itemDeprecation, variantDeprecation } from \"./deprecation\"\nimport { viewFunction } from \"./runtime-api\"\n\nconst hashType = Enum({\n  Blake2128: _void,\n  Blake2256: _void,\n  Blake2128Concat: _void,\n  Twox128: _void,\n  Twox256: _void,\n  Twox64Concat: _void,\n  Identity: _void,\n})\n\nconst hashers = Vector(hashType)\n\nexport const storageMap = Struct({\n  hashers,\n  key: compactNumber,\n  value: compactNumber,\n})\n\nconst storageItem = {\n  name: str,\n  modifier: u8,\n  type: Enum({\n    plain: compactNumber,\n    map: storageMap,\n  }),\n  fallback: Hex(),\n  docs,\n}\n\nconst enumRefV14 = Option(compactNumber)\n\nexport const v14Pallet = {\n  name: str,\n  storage: Option(\n    Struct({\n      prefix: str,\n      items: Vector(Struct(storageItem)),\n    }),\n  ),\n  calls: enumRefV14,\n  events: enumRefV14,\n  constants: Vector(\n    Struct({\n      name: str,\n      type: compactNumber,\n      value: Hex(),\n      docs,\n    }),\n  ),\n  errors: enumRefV14,\n  index: u8,\n}\n\nexport const v15Pallet = {\n  ...v14Pallet,\n  docs,\n}\n\nconst enumRef = Option(\n  Struct({ type: compactNumber, deprecationInfo: variantDeprecation }),\n)\n\nexport const v16Pallet = {\n  name: str,\n  storage: Option(\n    Struct({\n      prefix: str,\n      items: Vector(\n        Struct({\n          ...storageItem,\n          deprecationInfo: itemDeprecation,\n        }),\n      ),\n    }),\n  ),\n  calls: enumRef,\n  events: enumRef,\n  constants: Vector(\n    Struct({\n      name: str,\n      type: compactNumber,\n      value: Hex(),\n      docs,\n      deprecationInfo: itemDeprecation,\n    }),\n  ),\n  errors: enumRef,\n  associatedTypes: Vector(\n    Struct({\n      name: str,\n      type: compactNumber,\n      docs,\n    }),\n  ),\n  viewFns: Vector(viewFunction),\n  index: u8,\n  docs,\n  deprecationInfo: itemDeprecation,\n}\n", "import { CodecType, Struct, Vector, createCodec, str, u8 } from \"scale-ts\"\nimport { lookup } from \"./lookup\"\nimport { compactNumber } from \"../scale\"\nimport { v14Pallet } from \"./pallets\"\nimport { runtimeApi } from \"./runtime-api\"\n\nconst empty = new Uint8Array()\nconst Always = <T>(value: T) =>\n  createCodec<T>(\n    () => empty,\n    () => value,\n  )\n\nconst extrinsic = Struct({\n  type: compactNumber,\n  version: u8,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      type: compactNumber,\n      additionalSigned: compactNumber,\n    }),\n  ),\n})\n\nexport const v14 = Struct({\n  lookup,\n  pallets: Vector(Struct({ ...v14Pallet, docs: Always([] as string[]) })),\n  extrinsic,\n  type: compactNumber,\n  apis: Always([] as Array<CodecType<typeof runtimeApi>>),\n})\nexport type V14 = CodecType<typeof v14>\n", "import { CodecType, Struct, Tuple, Vector, str, u8 } from \"scale-ts\"\nimport { lookup } from \"./lookup\"\nimport { v15Pallet } from \"./pallets\"\nimport { Hex, compactNumber as ty } from \"../scale\"\nimport { runtimeApiV15 } from \"./runtime-api\"\n\nconst extrinsic = Struct({\n  version: u8,\n  address: ty,\n  call: ty,\n  signature: ty,\n  extra: ty,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      type: ty,\n      additionalSigned: ty,\n    }),\n  ),\n})\n\nexport const v15 = Struct({\n  lookup,\n  pallets: Vector(Struct(v15Pallet)),\n  extrinsic,\n  type: ty,\n  apis: Vector(runtimeApiV15),\n  outerEnums: Struct({\n    call: ty,\n    event: ty,\n    error: ty,\n  }),\n  custom: Vector(Tuple(str, Struct({ type: ty, value: Hex() }))),\n})\nexport type V15 = CodecType<typeof v15>\n", "import { CodecType, Struct, Tuple, Vector, str, u8 } from \"scale-ts\"\nimport { lookup } from \"./lookup\"\nimport { v16Pallet } from \"./pallets\"\nimport { compactNumber, Hex, compactNumber as ty } from \"../scale\"\nimport { runtimeApi } from \"./runtime-api\"\n\nconst extrinsic = Struct({\n  version: Vector(u8),\n  address: ty,\n  call: ty,\n  signature: ty,\n  signedExtensionsByVersion: Vector(Tuple(u8, Vector(compactNumber))),\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      type: ty,\n      additionalSigned: ty,\n    }),\n  ),\n})\n\nexport const v16 = Struct({\n  lookup,\n  pallets: Vector(Struct(v16Pallet)),\n  extrinsic,\n  apis: Vector(runtimeApi),\n  outerEnums: Struct({\n    call: ty,\n    event: ty,\n    error: ty,\n  }),\n  custom: Vector(Tuple(str, Struct({ type: ty, value: Hex() }))),\n})\nexport type V16 = CodecType<typeof v16>\n", "import {\n  Bytes,\n  type Codec,\n  type CodecType,\n  Enum,\n  Option,\n  Struct,\n  Tuple,\n  compact,\n  createCodec,\n  u32,\n} from \"scale-ts\"\nimport type { HexString } from \"../scale\"\nimport { v14 } from \"./v14\"\nimport { v15 } from \"./v15\"\nimport { v16 } from \"./v16\"\n\nconst unsupportedFn = () => {\n  throw new Error(\"Unsupported metadata version!\")\n}\n\nconst unsupported = createCodec(\n  unsupportedFn,\n  unsupportedFn,\n) as unknown as Codec<unknown>\n\nexport const metadata = Struct({\n  magicNumber: u32,\n  metadata: Enum({\n    v0: unsupported,\n    v1: unsupported,\n    v2: unsupported,\n    v3: unsupported,\n    v4: unsupported,\n    v5: unsupported,\n    v6: unsupported,\n    v7: unsupported,\n    v8: unsupported,\n    v9: unsupported,\n    v10: unsupported,\n    v11: unsupported,\n    v12: unsupported,\n    v13: unsupported,\n    v14,\n    v15,\n    v16,\n  }),\n})\nexport type Metadata = CodecType<typeof metadata>\n\nconst opaqueBytes = Bytes()\nconst optionOpaque = Option(opaqueBytes)\nconst opaqueOpaqueBytes = Tuple(compact, opaqueBytes)\n\nexport const decAnyMetadata = (\n  input: Uint8Array | HexString,\n): CodecType<typeof metadata> => {\n  try {\n    return metadata.dec(input)\n  } catch (_) {}\n\n  // comes from metadata.metadata_at_version\n  try {\n    return metadata.dec(optionOpaque.dec(input)!)\n  } catch (_) {}\n\n  // comes from state.getMetadata\n  try {\n    return metadata.dec(opaqueBytes.dec(input))\n  } catch (_) {}\n\n  // comes from metadata.metadata\n  try {\n    return metadata.dec(opaqueOpaqueBytes.dec(input)[1])\n  } catch (_) {}\n\n  throw null\n}\n", "import { CodecType } from \"scale-ts\"\nimport { V14Lookup } from \"./lookup\"\nimport { storageMap } from \"./pallets\"\nimport { HexString } from \"../scale\"\nimport { itemDeprecation, variantDeprecation } from \"./deprecation\"\nimport { viewFunction } from \"./runtime-api\"\nimport { V14 } from \"./v14\"\nimport { V16 } from \"./v16\"\nimport { V15 } from \"./v15\"\nimport { Metadata } from \"./metadata\"\n\ntype EnumRef<T> =\n  | ({\n      type: number\n    } & (T extends 16\n      ? { deprecationInfo: CodecType<typeof variantDeprecation> }\n      : {}))\n  | undefined\n\ntype DeprecationInfo<T> = T extends 16\n  ? { deprecationInfo: CodecType<typeof itemDeprecation> }\n  : {}\n\nexport type UnifiedMetadata<T extends 14 | 15 | 16 = 14 | 15 | 16> = {\n  version: T\n  lookup: V14Lookup\n  pallets: Array<\n    {\n      name: string\n      storage:\n        | {\n            prefix: string\n            items: Array<\n              {\n                name: string\n                modifier: number\n                type:\n                  | { tag: \"plain\"; value: number }\n                  | { tag: \"map\"; value: CodecType<typeof storageMap> }\n                fallback: HexString\n                docs: string[]\n              } & DeprecationInfo<T>\n            >\n          }\n        | undefined\n      calls: EnumRef<T>\n      events: EnumRef<T>\n      constants: Array<\n        {\n          name: string\n          type: number\n          value: HexString\n          docs: string[]\n        } & DeprecationInfo<T>\n      >\n      errors: EnumRef<T>\n      associatedTypes: Array<{\n        name: string\n        type: number\n        docs: string[]\n      }>\n      viewFns: Array<CodecType<typeof viewFunction>>\n      index: number\n      docs: string[]\n    } & DeprecationInfo<T>\n  >\n  extrinsic: {\n    version: number[]\n    signedExtensions: Array<{\n      identifier: string\n      type: number\n      additionalSigned: number\n    }>\n  } & (T extends 14\n    ? {\n        type: number\n      }\n    : { address: number; call: number; signature: number }) &\n    (T extends 16\n      ? { signedExtensionsByVersion: Array<[number, number[]]> }\n      : {})\n  apis: Array<\n    {\n      name: string\n      methods: Array<\n        {\n          name: string\n          inputs: Array<{ name: string; type: number }>\n          output: number\n          docs: string[]\n        } & DeprecationInfo<T>\n      >\n      docs: string[]\n    } & (T extends 16 ? { version: number } : {}) &\n      DeprecationInfo<T>\n  >\n} & (T extends 14\n  ? {}\n  : {\n      outerEnums: { call: number; event: number; error: number }\n      custom: Array<[string, { type: number; value: HexString }]>\n    })\n\nexport const unifyMetadata = (\n  metadata: Metadata | Metadata[\"metadata\"] | V14 | V15 | V16,\n): UnifiedMetadata => {\n  // complete metadata\n  if (\"magicNumber\" in metadata) metadata = metadata.metadata\n  if (\"tag\" in metadata) {\n    if (\n      metadata.tag !== \"v14\" &&\n      metadata.tag !== \"v15\" &&\n      metadata.tag !== \"v16\"\n    )\n      throw new Error(\"Only metadata 14, 15, and 16 are supported\")\n    metadata = metadata.value\n  }\n\n  // v16\n  if (\"signedExtensionsByVersion\" in metadata.extrinsic) {\n    return { version: 16, ...(metadata as V16) }\n  }\n  // v15\n  if (\"custom\" in metadata) {\n    const { lookup, extrinsic, custom, apis, pallets, outerEnums } =\n      metadata as V15\n\n    return {\n      version: 15,\n      lookup,\n      pallets: pallets.map((p): UnifiedMetadata<15>[\"pallets\"][number] => ({\n        ...p,\n        calls: p.calls != null ? { type: p.calls } : undefined,\n        events: p.events != null ? { type: p.events } : undefined,\n        errors: p.errors != null ? { type: p.errors } : undefined,\n        viewFns: [],\n        associatedTypes: [],\n      })),\n      extrinsic: { ...extrinsic, version: [extrinsic.version] },\n      apis,\n      outerEnums,\n      custom,\n    }\n  }\n  // fallback, v14\n  const { lookup, extrinsic, pallets } = metadata as V14\n  return {\n    version: 14,\n    lookup,\n    pallets: pallets.map((p): UnifiedMetadata<14>[\"pallets\"][number] => ({\n      ...p,\n      calls: p.calls != null ? { type: p.calls } : undefined,\n      events: p.events != null ? { type: p.events } : undefined,\n      errors: p.errors != null ? { type: p.errors } : undefined,\n      viewFns: [],\n      associatedTypes: [],\n    })),\n    extrinsic: { ...extrinsic, version: [extrinsic.version] },\n    apis: [],\n  }\n}\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\n\nconst len32 = { dkLen: 32 }\nexport const Blake2256 = (encoded: Uint8Array) => blake2b(encoded, len32)\n\nconst len16 = { dkLen: 16 }\nexport const Blake2128 = (encoded: Uint8Array) => blake2b(encoded, len16)\n\nexport const Blake2128Concat = (encoded: Uint8Array) =>\n  mergeUint8(Blake2128(encoded), encoded)\n", "/**\n * Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC & KDF.\n *\n * It is advertised as \"the fastest cryptographic hash\". However, it isn't true in JS.\n * Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:\n *\n * * There is only 30% reduction in number of rounds from blake2s\n * * Speed-up comes from tree structure, which is parallelized using SIMD & threading.\n *   These features are not present in JS, so we only get overhead from trees.\n * * Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.\n * * It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm\n * @module\n */\nimport { SHA256_IV } from './_md.ts';\nimport { fromBig } from './_u64.ts';\nimport { BLAKE2, compress } from './blake2.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createXOFer, swap32IfBE, toBytes, u32, u8,\n  type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// Flag bitset\nconst B3_Flags = {\n  CHUNK_START: 0b1,\n  CHUNK_END: 0b10,\n  PARENT: 0b100,\n  ROOT: 0b1000,\n  KEYED_HASH: 0b10000,\n  DERIVE_KEY_CONTEXT: 0b100000,\n  DERIVE_KEY_MATERIAL: 0b1000000,\n} as const;\n\nconst B3_IV = SHA256_IV.slice();\n\nconst B3_SIGMA: Uint8Array = /* @__PURE__ */ (() => {\n  const Id = Array.from({ length: 16 }, (_, i) => i);\n  const permute = (arr: number[]) =>\n    [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);\n  const res: number[] = [];\n  for (let i = 0, v = Id; i < 7; i++, v = permute(v)) res.push(...v);\n  return Uint8Array.from(res);\n})();\n\n/**\n * Ensure to use EITHER `key` OR `context`, not both.\n *\n * * `key`: 32-byte MAC key.\n * * `context`: string for KDF. Should be hardcoded, globally unique, and application - specific.\n *   A good default format for the context string is \"[application] [commit timestamp] [purpose]\".\n */\nexport type Blake3Opts = { dkLen?: number; key?: Input; context?: Input };\n\n/** Blake3 hash. Can be used as MAC and KDF. */\nexport class BLAKE3 extends BLAKE2<BLAKE3> implements HashXOF<BLAKE3> {\n  private chunkPos = 0; // Position of current block in chunk\n  private chunksDone = 0; // How many chunks we already have\n  private flags = 0 | 0;\n  private IV: Uint32Array;\n  private state: Uint32Array;\n  private stack: Uint32Array[] = [];\n  // Output\n  private posOut = 0;\n  private bufferOut32 = new Uint32Array(16);\n  private bufferOut: Uint8Array;\n  private chunkOut = 0; // index of output chunk\n  private enableXOF = true;\n\n  constructor(opts: Blake3Opts = {}, flags = 0) {\n    super(64, opts.dkLen === undefined ? 32 : opts.dkLen);\n    const { key, context } = opts;\n    const hasContext = context !== undefined;\n    if (key !== undefined) {\n      if (hasContext) throw new Error('Only \"key\" or \"context\" can be specified at same time');\n      const k = toBytes(key).slice();\n      abytes(k, 32);\n      this.IV = u32(k);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.KEYED_HASH;\n    } else if (hasContext) {\n      const ctx = toBytes(context);\n      const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT)\n        .update(ctx)\n        .digest();\n      this.IV = u32(contextKey);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;\n    } else {\n      this.IV = B3_IV.slice();\n      this.flags = flags;\n    }\n    this.state = this.IV.slice();\n    this.bufferOut = u8(this.bufferOut32);\n  }\n  // Unused\n  protected get(): [] {\n    return [];\n  }\n  protected set(): void {}\n  private b2Compress(counter: number, flags: number, buf: Uint32Array, bufPos: number = 0) {\n    const { state: s, pos } = this;\n    const { h, l } = fromBig(BigInt(counter), true);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, bufPos, buf, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags\n      );\n    s[0] = v0 ^ v8;\n    s[1] = v1 ^ v9;\n    s[2] = v2 ^ v10;\n    s[3] = v3 ^ v11;\n    s[4] = v4 ^ v12;\n    s[5] = v5 ^ v13;\n    s[6] = v6 ^ v14;\n    s[7] = v7 ^ v15;\n  }\n  protected compress(buf: Uint32Array, bufPos: number = 0, isLast: boolean = false): void {\n    // Compress last block\n    let flags = this.flags;\n    if (!this.chunkPos) flags |= B3_Flags.CHUNK_START;\n    if (this.chunkPos === 15 || isLast) flags |= B3_Flags.CHUNK_END;\n    if (!isLast) this.pos = this.blockLen;\n    this.b2Compress(this.chunksDone, flags, buf, bufPos);\n    this.chunkPos += 1;\n    // If current block is last in chunk (16 blocks), then compress chunks\n    if (this.chunkPos === 16 || isLast) {\n      let chunk = this.state;\n      this.state = this.IV.slice();\n      // If not the last one, compress only when there are trailing zeros in chunk counter\n      // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n      // 1 (001) - leaf not finished (just push current chunk to stack)\n      // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n      // 3 (011) - last leaf not finished\n      // 4 (100) - leafs finished at depth=1 and depth=2\n      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n        if (!(last = this.stack.pop())) break;\n        this.buffer32.set(last, 0);\n        this.buffer32.set(chunk, 8);\n        this.pos = this.blockLen;\n        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);\n        chunk = this.state;\n        this.state = this.IV.slice();\n      }\n      this.chunksDone++;\n      this.chunkPos = 0;\n      this.stack.push(chunk);\n    }\n    this.pos = 0;\n  }\n  _cloneInto(to?: BLAKE3): BLAKE3 {\n    to = super._cloneInto(to) as BLAKE3;\n    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;\n    to.state.set(state.slice());\n    to.stack = stack.map((i) => Uint32Array.from(i));\n    to.IV.set(IV);\n    to.flags = flags;\n    to.chunkPos = chunkPos;\n    to.chunksDone = chunksDone;\n    to.posOut = posOut;\n    to.chunkOut = chunkOut;\n    to.enableXOF = this.enableXOF;\n    to.bufferOut32.set(this.bufferOut32);\n    return to;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state, this.buffer32, this.IV, this.bufferOut32);\n    clean(...this.stack);\n  }\n  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n  private b2CompressOut() {\n    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;\n    const { h, l } = fromBig(BigInt(this.chunkOut++));\n    swap32IfBE(buffer32);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, 0, buffer32, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags\n      );\n    out32[0] = v0 ^ v8;\n    out32[1] = v1 ^ v9;\n    out32[2] = v2 ^ v10;\n    out32[3] = v3 ^ v11;\n    out32[4] = v4 ^ v12;\n    out32[5] = v5 ^ v13;\n    out32[6] = v6 ^ v14;\n    out32[7] = v7 ^ v15;\n    out32[8] = s[0] ^ v8;\n    out32[9] = s[1] ^ v9;\n    out32[10] = s[2] ^ v10;\n    out32[11] = s[3] ^ v11;\n    out32[12] = s[4] ^ v12;\n    out32[13] = s[5] ^ v13;\n    out32[14] = s[6] ^ v14;\n    out32[15] = s[7] ^ v15;\n    swap32IfBE(buffer32);\n    swap32IfBE(out32);\n    this.posOut = 0;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(this.pos));\n    // Process last chunk\n    let flags = this.flags | B3_Flags.ROOT;\n    if (this.stack.length) {\n      flags |= B3_Flags.PARENT;\n      swap32IfBE(this.buffer32);\n      this.compress(this.buffer32, 0, true);\n      swap32IfBE(this.buffer32);\n      this.chunksDone = 0;\n      this.pos = this.blockLen;\n    } else {\n      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;\n    }\n    this.flags = flags;\n    this.b2CompressOut();\n  }\n  private writeInto(out: Uint8Array) {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const { blockLen, bufferOut } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.b2CompressOut();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    if (!this.enableXOF) throw new Error('XOF is not possible after digest call');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.enableXOF = false;\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n}\n\n/**\n * BLAKE3 hash function. Can be used as MAC and KDF.\n * @param msg - message that would be hashed\n * @param opts - `dkLen` for output length, `key` for MAC mode, `context` for KDF mode\n * @example\n * const data = new Uint8Array(32);\n * const hash = blake3(data);\n * const mac = blake3(data, { key: new Uint8Array(32) });\n * const kdf = blake3(data, { context: 'application name' });\n */\nexport const blake3: CHashXO = /* @__PURE__ */ createXOFer<BLAKE3, Blake3Opts>(\n  (opts) => new BLAKE3(opts)\n);\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { blake3 } from \"@noble/hashes/blake3\"\n\nconst len32 = { dkLen: 32 }\nexport const Blake3256 = (encoded: Uint8Array) => blake3(encoded, len32)\n\nexport const Blake3256Concat = (encoded: Uint8Array) =>\n  mergeUint8(Blake3256(encoded), encoded)\n", "export const Identity = (encoded: Uint8Array): Uint8Array => encoded\n", "// Adapted implementation based on: https://github.com/pierrec/js-xxhash/blob/7ff5ced282f97dba121109d7013e0fa80360398c/lib/xxhash64.js\n\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n\n// helper functions\nconst bigintFromU16 = (\n  v0: number,\n  v1: number,\n  v2: number,\n  v3: number,\n): bigint =>\n  new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true)\n\nconst MASK_64 = 2n ** 64n - 1n\n\nconst rotl = (input: bigint, nBits: bigint) =>\n  ((input << nBits) & MASK_64) | (input >> (64n - nBits))\n\nconst multiply = (a: bigint, b: bigint) => (a * b) & MASK_64\n\nconst add = (a: bigint, b: bigint) => (a + b) & MASK_64\n\n// constants\nconst PRIME64_1 = 11400714785074694791n\nconst PRIME64_2 = 14029467366897019727n\nconst PRIME64_3 = 1609587929392839161n\nconst PRIME64_4 = 9650029242287828579n\nconst PRIME64_5 = 2870177450012600261n\n\nexport function h64(input: Uint8Array, seed: bigint = 0n) {\n  let v1 = add(add(seed, PRIME64_1), PRIME64_2)\n  let v2 = add(seed, PRIME64_2)\n  let v3 = seed\n  let v4 = seed - PRIME64_1\n  let totalLen = input.length\n  let memsize = 0\n  let memory: Uint8Array | null = null\n\n  ;(function update() {\n    let p = 0\n    let bEnd = p + totalLen\n\n    if (!totalLen) return\n\n    memory = new Uint8Array(32)\n\n    if (totalLen < 32) {\n      memory.set(input.subarray(0, totalLen), memsize)\n\n      memsize += totalLen\n      return\n    }\n\n    if (p <= bEnd - 32) {\n      const limit = bEnd - 32\n\n      do {\n        let other\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n      } while (p <= limit)\n    }\n\n    if (p < bEnd) {\n      memory.set(input.subarray(p, bEnd), memsize)\n      memsize = bEnd - p\n    }\n  })()\n\n  input = memory || input\n\n  let result: bigint\n  let p = 0\n\n  if (totalLen >= 32) {\n    result = rotl(v1, 1n)\n    result = add(result, rotl(v2, 7n))\n    result = add(result, rotl(v3, 12n))\n    result = add(result, rotl(v4, 18n))\n\n    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v1\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v2\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v3\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v4\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n  } else {\n    result = add(seed, PRIME64_5)\n  }\n\n  result = add(result, BigInt(totalLen))\n\n  while (p <= memsize - 8) {\n    let temp = bigintFromU16(\n      (input[p + 1] << 8) | input[p],\n      (input[p + 3] << 8) | input[p + 2],\n      (input[p + 5] << 8) | input[p + 4],\n      (input[p + 7] << 8) | input[p + 6],\n    )\n    temp = multiply(rotl(multiply(temp, PRIME64_2), 31n), PRIME64_1)\n    result = add(multiply(rotl(result ^ temp, 27n), PRIME64_1), PRIME64_4)\n    p += 8\n  }\n\n  if (p + 4 <= memsize) {\n    let temp = multiply(\n      bigintFromU16(\n        (input[p + 1] << 8) | input[p],\n        (input[p + 3] << 8) | input[p + 2],\n        0,\n        0,\n      ),\n      PRIME64_1,\n    )\n\n    result = add(multiply(rotl(result ^ temp, 23n), PRIME64_2), PRIME64_3)\n    p += 4\n  }\n\n  while (p < memsize) {\n    const temp = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5)\n    result = multiply(rotl(result ^ temp, 11n), PRIME64_1)\n  }\n\n  let temp = result >> 33n\n  result = multiply(result ^ temp, PRIME64_2)\n\n  temp = result >> 29n\n  result = multiply(result ^ temp, PRIME64_3)\n\n  temp = result >> 32n\n  result ^= temp\n\n  return result\n}\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { u64 } from \"scale-ts\"\nimport { h64 } from \"./h64\"\n\nexport const Twox128 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n\n  return result\n}\n\nexport const Twox256 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n  dv.setBigUint64(16, h64(input, 2n), true)\n  dv.setBigUint64(24, h64(input, 3n), true)\n\n  return result\n}\n\nexport const Twox64Concat = (encoded: Uint8Array): Uint8Array =>\n  mergeUint8(u64.enc(h64(encoded)), encoded)\n", "import { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport type { Codec } from \"scale-ts\"\nimport {\n  Blake2128,\n  Blake2128Concat,\n  Blake2256,\n  Identity,\n  Twox128,\n  Twox256,\n  Twox64Concat,\n} from \"./hashes\"\n\nexport type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array]\n\nconst textEncoder = new TextEncoder()\n\n// the value indicates:\n// - when positive: the number of bytes to skip before reaching the transparent-encoded key\n// - when negative: the number of bytes that the opaque hasher will generate\nconst hashers: Map<(input: Uint8Array) => Uint8Array, number> = new Map([\n  [Identity, 0],\n  [Twox64Concat, 8],\n  [Blake2128Concat, 16],\n  [Blake2128, -16],\n  [Blake2256, -32],\n  [Twox128, -16],\n  [Twox256, -32],\n])\n\nexport type OpaqueKeyHash = string & { __opaqueKeyHash?: unknown }\n\nexport const Storage = (pallet: string) => {\n  const palledEncoded = Twox128(textEncoder.encode(pallet))\n  return <A extends Array<EncoderWithHash<any>>>(\n    name: string,\n    ...encoders: [...A]\n  ): {\n    enc: (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ) => string\n    dec: (value: string) => {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    }\n  } => {\n    const palletItemEncoded = mergeUint8(\n      palledEncoded,\n      Twox128(textEncoder.encode(name)),\n    )\n\n    const palletItemEncodedHex = toHex(palletItemEncoded)\n\n    const dec = (\n      key: string,\n    ): {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    } => {\n      if (!key.startsWith(palletItemEncodedHex))\n        throw new Error(`key does not match this storage (${pallet}.${name})`)\n\n      if (encoders.length === 0) return [] as any\n\n      const argsKey = fromHex(key.slice(palletItemEncodedHex.length))\n      const result = new Array<any>(encoders.length)\n      for (let i = 0, cur = 0; i < encoders.length; i++) {\n        const [codec, hasher] = encoders[i]\n        const hBytes = hashers.get(hasher)\n        if (hBytes == null) throw new Error(\"Unknown hasher\")\n        if (hBytes < 0) {\n          const opaqueBytes = hBytes * -1\n          result[i] = toHex(argsKey.slice(cur, cur + opaqueBytes))\n          cur += opaqueBytes\n        } else {\n          cur += hBytes\n          result[i] = codec.dec(argsKey.slice(cur))\n          cur += codec.enc(result[i]).length\n        }\n      }\n      return result as any\n    }\n\n    const fns = encoders.map(\n      ([{ enc }, hash]) =>\n        (val: any) =>\n          hash(enc(val)),\n    )\n\n    const enc = (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ): string =>\n      toHex(\n        mergeUint8(palletItemEncoded, ...args.map((val, idx) => fns[idx](val))),\n      )\n\n    return {\n      enc,\n      dec,\n    }\n  }\n}\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { Binary, compact, u16 } from \"../codecs\"\nimport { Blake2256 } from \"../hashes\"\n\nconst PREFIX = Binary.fromText(\"modlpy/utilisuba\").asBytes()\nexport const getMultisigAccountId = ({\n  threshold,\n  signatories,\n}: {\n  threshold: number\n  signatories: Uint8Array[]\n}) => {\n  const sortedSignatories = sortMultisigSignatories(signatories)\n  const payload = mergeUint8(\n    PREFIX,\n    compact.enc(sortedSignatories.length),\n    ...sortedSignatories,\n    u16.enc(threshold),\n  )\n  return Blake2256(payload)\n}\n\nexport const sortMultisigSignatories = (signatories: Uint8Array[]) =>\n  signatories.slice().sort((a, b) => {\n    for (let i = 0; ; i++) {\n      const overA = i >= a.length\n      const overB = i >= b.length\n\n      if (overA && overB) return 0\n      else if (overA) return -1\n      else if (overB) return 1\n      else if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1\n    }\n  })\n", "import type {\n  StringRecord,\n  UnifiedMetadata,\n  V14Lookup,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport type SignedPrimitive = \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"i128\" | \"i256\"\nexport type UnsignedPrimitive = \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"u256\"\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | SignedPrimitive\n  | UnsignedPrimitive\n\nexport type PrimitiveVar = {\n  type: \"primitive\"\n  value: MetadataPrimitives\n}\n\nexport type VoidVar = { type: \"void\" }\nexport type CompactVar = {\n  type: \"compact\"\n  isBig: boolean\n  size: UnsignedPrimitive\n}\nexport type BitSequenceVar = { type: \"bitSequence\" }\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type AccountId20 = { type: \"AccountId20\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | VoidVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n  | AccountId20\n\n/* Array-like vars:\n * - TupleVar: Mixed types, fixed length\n * - Sequence: One type, arbitrary length\n * - Array: One type, fixed length\n */\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<\n    (\n      | { type: \"lookupEntry\"; value: LookupEntry }\n      | VoidVar\n      | TupleVar\n      | StructVar\n      | ArrayVar\n    ) & { idx: number }\n  >\n  innerDocs: StringRecord<string[]>\n  byteLength?: number\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nconst isBytes = (value: LookupEntry, nBytes: number) =>\n  value.type === \"array\" &&\n  value.len === nBytes &&\n  value.value.type === \"primitive\" &&\n  value.value.value === \"u8\"\n\nconst _void: VoidVar = { type: \"void\" }\n\nexport interface MetadataLookup {\n  (id: number): LookupEntry\n  metadata: UnifiedMetadata\n  call: number | null\n}\n\nconst _denormalizeLookup = (\n  lookupData: V14Lookup,\n  customMap: (value: V14Lookup[number]) => Var | null = () => null,\n): ((id: number) => LookupEntry) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  let isAccountId20SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const custom = customMap(lookupData[id])\n    if (custom) return custom\n\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return _void\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        const inner = getLookupEntryDef(def.value[0].type as number)\n\n        if (\n          isAccountId32SearchOn &&\n          path.at(-1) === \"AccountId32\" &&\n          isBytes(inner, 32)\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n\n        if (\n          isAccountId20SearchOn &&\n          path.at(-1) === \"AccountId20\" &&\n          isBytes(inner, 20)\n        ) {\n          isAccountId20SearchOn = false\n          return { type: \"AccountId20\" }\n        }\n\n        return inner\n      }\n\n      return getComplexVar(def.value)\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"void\"\n          ? // Option<void> would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return _void\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ..._void, idx: x.index }\n          return\n        }\n\n        if (x.fields.length === 1 && !x.fields[0].name) {\n          enumValue[key] = {\n            type: \"lookupEntry\",\n            value: getLookupEntryDef(x.fields[0].type),\n            idx: x.index,\n          }\n          return\n        }\n\n        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\")\n      return {\n        type: \"sequence\",\n        value: getLookupEntryDef(def.value as number),\n      }\n\n    if (def.tag === \"array\") {\n      const { len } = def.value\n      const value = getLookupEntryDef(def.value.type)\n\n      return !len || value.type === \"void\"\n        ? _void\n        : len > 1\n          ? {\n              type: \"array\",\n              value,\n              len: def.value.len,\n            }\n          : value\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return _void\n\n      return def.value.length > 1\n        ? getArrayOrTuple(\n            def.value.map((x) => getLookupEntryDef(x as number)),\n            def.value.map((x) => lookupData[x].docs),\n          )\n        : getLookupEntryDef(def.value[0] as number) // use to be a \"pointer\"\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value) as PrimitiveVar | VoidVar\n      if (translated.type === \"void\") return _void\n\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n        size: translated.value as UnsignedPrimitive,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n    }\n  })\n\n  const getComplexVar = (\n    input: Array<{ type: number; name?: string; docs: string[] }>,\n  ): TupleVar | StructVar | ArrayVar | VoidVar => {\n    let allKey = true\n\n    const values: Record<string | number, LookupEntry> = {}\n    const innerDocs: Record<string | number, string[]> = {}\n\n    input.forEach((x, idx) => {\n      allKey = allKey && !!x.name\n      const key = x.name || idx\n      const value = getLookupEntryDef(x.type as number)\n      if (value.type !== \"void\") {\n        values[key] = value\n        innerDocs[key] = x.docs\n      }\n    })\n    return allKey\n      ? {\n          type: \"struct\",\n          value: values as StringRecord<LookupEntry>,\n          innerDocs: innerDocs as StringRecord<string[]>,\n        }\n      : getArrayOrTuple(Object.values(values), Object.values(innerDocs))\n  }\n\n  const getArrayOrTuple = (\n    values: Array<LookupEntry>,\n    innerDocs: Array<string[]>,\n  ): TupleVar | ArrayVar | VoidVar => {\n    if (\n      values.every((v) => v.id === values[0].id) &&\n      innerDocs.every((doc) => !doc.length)\n    ) {\n      const [value] = values\n      return value.type === \"void\"\n        ? _void\n        : {\n            type: \"array\",\n            value: values[0],\n            len: values.length,\n          }\n    }\n    return {\n      type: \"tuple\",\n      value: values,\n      innerDocs: innerDocs,\n    }\n  }\n\n  return getLookupEntryDef\n}\n\nexport const denormalizeLookup = (lookupData: V14Lookup) =>\n  _denormalizeLookup(lookupData)\n\nexport const getLookupFn = (metadata: UnifiedMetadata): MetadataLookup => {\n  const getLookupEntryDef = _denormalizeLookup(metadata.lookup, ({ def }) => {\n    if (def.tag === \"composite\") {\n      const moduleErrorLength = getModuleErrorLength(def)\n      if (moduleErrorLength) {\n        return {\n          type: \"enum\",\n          innerDocs: {},\n          value: Object.fromEntries(\n            metadata.pallets.map((p) => [\n              p.name,\n              p.errors == null\n                ? { ..._void, idx: p.index }\n                : {\n                    type: \"lookupEntry\" as const,\n                    value: getLookupEntryDef(p.errors.type),\n                    idx: p.index,\n                  },\n            ]),\n          ) as StringRecord<\n            (\n              | VoidVar\n              | {\n                  type: \"lookupEntry\"\n                  value: LookupEntry\n                }\n            ) & { idx: number }\n          >,\n          byteLength: moduleErrorLength,\n        }\n      }\n    }\n    return null\n  })\n\n  function getModuleErrorLength(def: {\n    tag: \"composite\"\n    value: {\n      name: string | undefined\n      type: number\n      typeName: string | undefined\n      docs: string[]\n    }[]\n  }) {\n    const preChecks =\n      def.value.length === 2 &&\n      def.value[0].name === \"index\" &&\n      def.value[1].name === \"error\"\n    if (!preChecks) return null\n\n    const index = getLookupEntryDef(def.value[0].type)\n    const error = getLookupEntryDef(def.value[1].type)\n\n    return index.type === \"primitive\" &&\n      index.value === \"u8\" &&\n      error.type === \"array\" &&\n      error.value.type === \"primitive\" &&\n      error.value.value === \"u8\"\n      ? 1 + error.len\n      : null\n  }\n\n  const getCall = () => {\n    if (\"call\" in metadata.extrinsic) {\n      return metadata.extrinsic.call\n    }\n\n    const extrinsic = metadata.lookup[metadata.extrinsic.type]\n    const call = extrinsic?.params.find((p) => p.name === \"Call\")\n\n    return call?.type ?? null\n  }\n\n  return Object.assign(getLookupEntryDef, { metadata, call: getCall() })\n}\n", "import { LookupEntry } from \"./lookups\"\n\ntype FnWithStack<Other extends Array<any>, T> = (\n  input: LookupEntry,\n  cache: Map<number, T>,\n  stack: Set<number>,\n  ...rest: Other\n) => T\n\nexport const withCache =\n  <Other extends Array<any>, T>(\n    fn: FnWithStack<Other, T>,\n    onEnterCircular: (\n      cacheGetter: () => T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n    onExitCircular: (\n      outter: T,\n      inner: T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n  ): FnWithStack<Other, T> =>\n  (input, cache, stack, ...rest) => {\n    const { id } = input\n    if (cache.has(id)) return cache.get(id)!\n\n    if (stack.has(id)) {\n      const res = onEnterCircular(() => cache.get(id)!, input, ...rest)\n      cache.set(id, res)\n      return res\n    }\n\n    stack.add(id)\n    let result = fn(input, cache, stack, ...rest)\n    stack.delete(id)\n\n    if (cache.has(id))\n      result = onExitCircular(result, cache.get(id)!, input, ...rest)\n\n    cache.set(id, result)\n    return result\n  }\n", "import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport type { LookupEntry } from \"./lookups\"\nimport { withCache } from \"./with-cache\"\n\nconst _bytes = scale.Bin()\n\nconst _buildCodec = (\n  input: LookupEntry,\n  cache: Map<number, Codec<any>>,\n  stack: Set<number>,\n  _accountId: Codec<scale.SS58String>,\n): Codec<any> => {\n  if (input.type === \"primitive\") return scale[input.value]\n  if (input.type === \"void\") return scale._void\n  if (input.type === \"AccountId32\") return _accountId\n  if (input.type === \"AccountId20\") return scale.ethAccount\n  if (input.type === \"compact\")\n    return input.isBig ? scale.compactBn : scale.compactNumber\n  if (input.type === \"bitSequence\") return scale.bitSequence\n\n  const buildNextCodec = (nextInput: LookupEntry): Codec<any> =>\n    buildCodec(nextInput, cache, stack, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerCodec = buildNextCodec(inner)\n    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec)\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    scale.Tuple(...value.map(buildNextCodec))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    const inner = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, buildNextCodec(value)]),\n    ) as StringRecord<Codec<any>>\n    return scale.Struct(inner)\n  }\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return _bytes\n  }\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\")\n      return scale.Bin(input.len)\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\") return scale.Option(buildNextCodec(input.value))\n\n  if (input.type === \"result\")\n    return scale.Result(\n      buildNextCodec(input.value.ok),\n      buildNextCodec(input.value.ko),\n    )\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    switch (v.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildNextCodec(v.value)\n      case \"tuple\":\n        return buildTuple(v.value)\n      case \"struct\":\n        return buildStruct(v.value)\n      case \"array\":\n        return buildVector(v.value, v.len)\n    }\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => {\n      return [key, dependencies[idx]]\n    }),\n  ) as StringRecord<Codec<any>>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  const variantCodec = areIndexesSorted\n    ? scale.Variant(inner)\n    : scale.Variant(inner, indexes as any)\n  return input.byteLength\n    ? fixedSizeCodec(variantCodec, input.byteLength)\n    : variantCodec\n}\nconst buildCodec = withCache(_buildCodec, scale.Self, (res) => res)\n\nexport const getLookupCodecBuilder = (\n  lookup: (id: number) => LookupEntry,\n  accountId = scale.AccountId(),\n) => {\n  const cache = new Map()\n  const buildDefinition = (id: number) =>\n    buildCodec(lookup(id), cache, new Set(), accountId)\n\n  return (id: number) => buildDefinition(id)\n}\n\nconst fixedSizeCodec = <T>(codec: Codec<T>, size: number): Codec<T> => {\n  const allBytes = scale.Bytes(size)\n  return scale.createCodec<T>(\n    (value: T) => allBytes.enc(codec.enc(value)),\n    (data) => codec.dec(allBytes.dec(data)),\n  )\n}\n", "import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport type { EnumVar, MetadataLookup } from \"./lookups\"\nimport { getLookupCodecBuilder } from \"./lookup-codec-builder\"\n\nconst nullCodec = scale.enhanceCodec(\n  scale._void,\n  () => undefined,\n  () => null,\n)\n\nexport const getDynamicBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        buildDefinition = getLookupCodecBuilder(\n          getLookupEntryDef,\n          scale.AccountId(prefixVal),\n        )\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    // if val is `void` it decodes to `undefined`, making it impossible\n    // to differentiate from a non-existant key\n    // therefore, if the key exists => null, if it doesn't => undefined\n    const withNullVoid = (codec: Codec<any>) =>\n      codec === scale._void ? nullCodec : codec\n\n    const storageWithFallback = (\n      len: number,\n      value: Codec<any>,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const keys = storagePallet!(...args)\n      const [, ...encodersWithHash] = args\n      return {\n        args: scale.Tuple(...encodersWithHash.map(([codec]) => codec)),\n        keys,\n        value,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? value.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        withNullVoid(buildDefinition(storageEntry.type.value)),\n        entry,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = withNullVoid(buildDefinition(value))\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: scale.EncoderWithHash<unknown>[] = (() => {\n      if (hashes.length === 1) {\n        return [[buildDefinition(key), hashes[0]]]\n      }\n\n      const keyDef = getLookupEntryDef(key)\n\n      switch (keyDef.type) {\n        case \"array\":\n          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash])\n        case \"tuple\":\n          return keyDef.value.map((x, idx) => [\n            buildDefinition(x.id),\n            hashes[idx],\n          ])\n        default:\n          throw new Error(\"Invalid key type\")\n      }\n    })()\n\n    return storageWithFallback(hashes.length, val, entry, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    switch (entry.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildDefinition(entry.value.id)\n      case \"tuple\":\n        return scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      case \"struct\":\n        return scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n      case \"array\":\n        return scale.Vector(buildDefinition(entry.value.id), entry.len)\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!.type)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildViewFn = (pallet: string, entry: string) => {\n    const fn = metadata.pallets\n      .find((x) => x.name === pallet)\n      ?.viewFns.find((x) => x.name === entry)\n    if (!fn) throw null\n\n    return {\n      args: scale.Tuple(...fn.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(fn.output),\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildViewFn,\n    buildRuntimeCall,\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    ss58Prefix,\n  }\n}\n", "import type { StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport { h64 } from \"@polkadot-api/substrate-bindings\"\nimport {\n  LookupGraph,\n  buildLookupGraph,\n  getStronglyConnectedComponents,\n  getSubgraph,\n  mergeSCCsWithCommonNodes,\n} from \"./lookup-graph\"\nimport {\n  ArrayVar,\n  LookupEntry,\n  MetadataLookup,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n  VoidVar,\n} from \"./lookups\"\n\nconst textEncoder = new TextEncoder()\nconst encodeText = textEncoder.encode.bind(textEncoder)\n\nconst getChecksum = (values: Array<bigint>) => {\n  const res = new Uint8Array(values.length * 8)\n  const dv = new DataView(res.buffer)\n\n  for (let i = 0; i < values.length; i++) dv.setBigUint64(i * 8, values[i])\n\n  return h64(res)\n}\nconst getStringChecksum = (values: Array<string>) =>\n  getChecksum(values.map((v) => h64(encodeText(v))))\n\ntype Shape =\n  | \"primitive\"\n  | \"void\"\n  | \"vector\"\n  | \"tuple\"\n  | \"struct\"\n  | \"option\"\n  | \"result\"\n  | \"enum\"\nconst shapeIds: Record<Shape, bigint> = {\n  primitive: 0n,\n  vector: 1n,\n  tuple: 2n,\n  struct: 3n,\n  option: 4n,\n  result: 5n,\n  enum: 6n,\n  void: 7n,\n}\n\ntype RuntimePrimitives =\n  | \"undefined\"\n  | \"number\"\n  | \"string\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"bitSequence\"\n  | \"byteSequence\"\n  | \"accountId32\"\n  | \"accountId20\"\n\nconst runtimePrimitiveIds: Record<RuntimePrimitives, bigint> = {\n  undefined: 0n,\n  number: 1n,\n  string: 2n,\n  bigint: 3n,\n  boolean: 4n,\n  bitSequence: 5n, // {bitsLen: number, bytes: Uint8Array}\n  byteSequence: 6n, // Binary\n  accountId32: 7n, // SS58String\n  accountId20: 8n, // EthAccount\n}\n\nconst metadataPrimitiveIds: Record<MetadataPrimitives, bigint> = {\n  bool: runtimePrimitiveIds.boolean,\n  char: runtimePrimitiveIds.string,\n  str: runtimePrimitiveIds.string,\n  u8: runtimePrimitiveIds.number,\n  u16: runtimePrimitiveIds.number,\n  u32: runtimePrimitiveIds.number,\n  u64: runtimePrimitiveIds.bigint,\n  u128: runtimePrimitiveIds.bigint,\n  u256: runtimePrimitiveIds.bigint,\n  i8: runtimePrimitiveIds.number,\n  i16: runtimePrimitiveIds.number,\n  i32: runtimePrimitiveIds.number,\n  i64: runtimePrimitiveIds.bigint,\n  i128: runtimePrimitiveIds.bigint,\n  i256: runtimePrimitiveIds.bigint,\n}\n\nconst structLikeBuilder = <T>(\n  shapeId: bigint,\n  input: StringRecord<T>,\n  innerChecksum: (value: T) => bigint,\n) => {\n  const sortedEntries = Object.entries(input).sort(([a], [b]) =>\n    a.localeCompare(b),\n  )\n  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key))\n  const valuesChecksum = getChecksum(\n    sortedEntries.map(([, entry]) => innerChecksum(entry)),\n  )\n\n  return getChecksum([shapeId, keysChecksum, valuesChecksum])\n}\n\nconst _buildChecksum = (\n  input: LookupEntry,\n  buildNextChecksum: (entry: LookupEntry) => bigint,\n): bigint => {\n  if (input.type === \"primitive\")\n    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]])\n\n  if (input.type === \"void\") return getChecksum([shapeIds.void])\n\n  if (input.type === \"compact\")\n    return getChecksum([\n      shapeIds.primitive,\n      runtimePrimitiveIds[input.isBig ? \"bigint\" : \"number\"],\n    ])\n\n  if (input.type === \"bitSequence\")\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence])\n\n  if (input.type === \"AccountId32\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId32])\n  }\n\n  if (input.type === \"AccountId20\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId20])\n  }\n\n  const buildVector = (entry: LookupEntry, length?: number) => {\n    const innerChecksum = buildNextChecksum(entry)\n    return getChecksum(\n      length !== undefined\n        ? [shapeIds.vector, innerChecksum, BigInt(length)]\n        : [shapeIds.vector, innerChecksum],\n    )\n  }\n\n  if (input.type === \"array\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([\n        shapeIds.primitive,\n        runtimePrimitiveIds.byteSequence,\n        BigInt(input.len),\n      ])\n    }\n    return buildVector(innerValue, input.len)\n  }\n\n  if (input.type === \"sequence\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence])\n    }\n    return buildVector(innerValue)\n  }\n\n  const buildTuple = (entries: LookupEntry[]) =>\n    getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)])\n\n  const buildStruct = (entries: StringRecord<LookupEntry>) =>\n    structLikeBuilder(shapeIds.struct, entries, buildNextChecksum)\n\n  if (input.type === \"tuple\") return buildTuple(input.value)\n\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\")\n    return getChecksum([shapeIds.option, buildNextChecksum(input.value)])\n\n  if (input.type === \"result\")\n    return getChecksum([\n      shapeIds.result,\n      buildNextChecksum(input.value.ok),\n      buildNextChecksum(input.value.ko),\n    ])\n\n  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {\n    if (entry.type === \"lookupEntry\") return buildNextChecksum(entry.value)\n    switch (entry.type) {\n      case \"void\":\n        return getChecksum([shapeIds.void])\n      case \"tuple\":\n        return buildTuple(entry.value)\n      case \"struct\":\n        return buildStruct(entry.value)\n      case \"array\":\n        return buildVector(entry.value, entry.len)\n    }\n  })\n}\n\nconst sortCyclicGroups = (groups: Array<Set<number>>, graph: LookupGraph) => {\n  const getReachableNodes = (group: Set<number>) => {\n    const result = new Set<number>()\n    const toVisit = Array.from(group)\n    while (toVisit.length) {\n      const id = toVisit.pop()!\n      if (result.has(id)) continue\n      result.add(id)\n\n      graph.get(id)?.refs.forEach((id) => toVisit.push(id))\n    }\n\n    return Array.from(result)\n  }\n\n  const result: Array<Set<number>> = new Array()\n\n  function dependentsFirst(group: Set<number>) {\n    if (result.includes(group)) return\n    const dependents = groups.filter(\n      (candidate) =>\n        candidate !== group &&\n        getReachableNodes(group).some((node) => candidate.has(node)),\n    )\n    dependents.forEach((group) => dependentsFirst(group))\n    if (result.includes(group)) return\n    result.push(group)\n  }\n\n  groups.forEach((group) => dependentsFirst(group))\n  return result\n}\n\nfunction iterateChecksums(\n  group: Set<number>,\n  iterations: number,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) {\n  // Keep the values that are getting changed on each iteration in a separate\n  // cache, because two nodes referencing the same one should read the same\n  // previous iteration checksum for that node.\n  const groupReadCache = new Map([...group].map((id) => [id, 0n]))\n  const groupWriteCache = new Map<number, bigint>()\n\n  const recursiveBuildChecksum = (\n    entry: LookupEntry,\n    // The first call has to skip the cache, otherwise it would return the\n    // previous iteration result.\n    skipCache = true,\n  ): bigint => {\n    if (!skipCache && (groupReadCache.has(entry.id) || cache.has(entry.id))) {\n      return groupReadCache.get(entry.id) ?? cache.get(entry.id)!\n    }\n    const result = _buildChecksum(entry, (nextEntry) =>\n      recursiveBuildChecksum(nextEntry, false),\n    )\n    if (group.has(entry.id)) {\n      groupWriteCache.set(entry.id, result)\n    } else {\n      cache.set(entry.id, result)\n    }\n    return result\n  }\n\n  for (let i = 0; i < iterations; i++) {\n    group.forEach((id) => recursiveBuildChecksum(graph.get(id)!.entry))\n\n    group.forEach((id) => groupReadCache.set(id, groupWriteCache.get(id)!))\n  }\n\n  return groupReadCache\n}\n\nfunction getMirroredNodes(\n  cyclicGroups: Array<Set<number>>,\n  graph: LookupGraph,\n) {\n  const maxSize = cyclicGroups.reduce(\n    (acc, group) => Math.max(acc, group.size),\n    0,\n  )\n  const allEntries = new Set([...graph.values()].map((v) => v.entry.id))\n\n  const resultingChecksums = iterateChecksums(\n    allEntries,\n    maxSize,\n    // Cache won't be used, since it's using the internal one for every node.\n    new Map(),\n    graph,\n  )\n\n  const checksumToNodes = new Map<bigint, number[]>()\n  for (const id of allEntries) {\n    const checksum = resultingChecksums.get(id)\n    if (checksum == undefined) throw new Error(\"Unreachable\")\n    if (!checksumToNodes.has(checksum)) {\n      checksumToNodes.set(checksum, [])\n    }\n    checksumToNodes.get(checksum)!.push(id)\n  }\n\n  const checksumsWithDuplicates = [...checksumToNodes.entries()].filter(\n    ([, nodes]) => nodes.length > 1,\n  )\n\n  const duplicatesMap: Record<number, number[]> = {}\n  checksumsWithDuplicates.forEach(([, nodes]) => {\n    nodes.forEach((n) => (duplicatesMap[n] = nodes))\n  })\n\n  return duplicatesMap\n}\n\nconst buildChecksum = (\n  entry: LookupEntry,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) => {\n  if (cache.has(entry.id)) return cache.get(entry.id)!\n\n  const subGraph = getSubgraph(entry.id, graph)\n\n  const cycles = getStronglyConnectedComponents(subGraph).filter(\n    // SCCs can be of length=1, but for those we're only interested with those that are circular with themselves\n    (group) => group.size > 1 || isSelfCircular(group, subGraph),\n  )\n  const cyclicGroups = mergeSCCsWithCommonNodes(cycles).filter((group) => {\n    // Exclude groups that were previously calculated\n    return !cache.has(group.values().next().value!)\n  })\n  const mirrored = getMirroredNodes(cyclicGroups, subGraph)\n  const sortedCyclicGroups = sortCyclicGroups(cyclicGroups, subGraph)\n\n  sortedCyclicGroups.forEach((group) => {\n    if (cache.has(group.values().next().value!)) {\n      // exclude mirrored groups\n      return\n    }\n\n    const result = iterateChecksums(group, group.size, cache, graph)\n    group.forEach((id) => {\n      const checksum = result.get(id)!\n      if (id in mirrored) {\n        mirrored[id].forEach((id) => cache.set(id, checksum))\n      } else {\n        cache.set(id, checksum)\n      }\n    })\n  })\n\n  const getChecksum = (entry: LookupEntry) => {\n    if (cache.has(entry.id)) return cache.get(entry.id)!\n    return _buildChecksum(entry, getChecksum)\n  }\n\n  return getChecksum(entry)\n}\n\nconst isSelfCircular = (group: Set<number>, graph: LookupGraph) => {\n  if (group.size !== 1) return false\n  const [id] = group\n\n  return graph.get(id)!.refs.has(id)\n}\n\nexport const getChecksumBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  const graph = buildLookupGraph(getLookupEntryDef, metadata.lookup.length)\n\n  const cache = new Map<number, bigint>()\n\n  const buildDefinition = (id: number): bigint =>\n    buildChecksum(getLookupEntryDef(id), cache, graph)\n\n  const buildStorage = (pallet: string, entry: string): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .storage!.items.find((s) => s.name === entry)!\n\n      if (storageEntry.type.tag === \"plain\")\n        return buildDefinition(storageEntry.type.value)\n\n      const { key, value } = storageEntry.type.value\n      const val = buildDefinition(value)\n      const returnKey = buildDefinition(key)\n      return getChecksum([val, returnKey])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildViewFns = (pallet: string, entry: string): bigint | null => {\n    try {\n      const viewFn = metadata.pallets\n        .find((x) => x.name === pallet)\n        ?.viewFns.find((x) => x.name === entry)\n      if (!viewFn) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        viewFn.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        viewFn.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(viewFn.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string): bigint | null => {\n    try {\n      const entry = metadata.apis\n        .find((x) => x.name === api)\n        ?.methods.find((x) => x.name === method)\n      if (!entry) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        entry.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        entry.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(entry.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildComposite = (\n    input: TupleVar | StructVar | VoidVar | ArrayVar,\n  ): bigint => {\n    if (input.type === \"void\") return getChecksum([0n])\n\n    if (input.type === \"tuple\") {\n      const values = Object.values(input.value).map((entry) =>\n        buildDefinition(entry.id),\n      )\n\n      return getChecksum([shapeIds.tuple, ...values])\n    }\n\n    if (input.type === \"array\") {\n      return getChecksum([\n        shapeIds.vector,\n        buildDefinition(input.value.id),\n        BigInt(input.len),\n      ])\n    }\n\n    // Otherwise struct\n    return structLikeBuilder(shapeIds.struct, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildNamedTuple = (input: StructVar): bigint => {\n    return structLikeBuilder(shapeIds.tuple, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const variantShapeId = {\n    errors: 1n,\n    events: 2n,\n    calls: 3n,\n  }\n  const buildVariant =\n    (variantType: \"errors\" | \"events\" | \"calls\") =>\n    (pallet: string, name: string): bigint | null => {\n      try {\n        const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n        const enumLookup = getLookupEntryDef(palletEntry[variantType]!.type)\n        buildDefinition(enumLookup.id)\n\n        if (enumLookup.type !== \"enum\") throw null\n        const entry = enumLookup.value[name]\n        const valueChecksum =\n          entry.type === \"lookupEntry\"\n            ? buildDefinition(entry.value.id)\n            : buildComposite(entry)\n        return getChecksum([variantShapeId[variantType], valueChecksum])\n      } catch (_) {\n        return null\n      }\n    }\n\n  const buildConstant = (\n    pallet: string,\n    constantName: string,\n  ): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .constants!.find((s) => s.name === constantName)!\n\n      return buildDefinition(storageEntry.type)\n    } catch (_) {\n      return null\n    }\n  }\n\n  const toStringEnhancer =\n    <Args extends Array<any>>(\n      fn: (...args: Args) => bigint | null,\n    ): ((...args: Args) => string | null) =>\n    (...args) =>\n      fn(...args)?.toString(32) ?? null\n\n  return {\n    buildDefinition: toStringEnhancer(buildDefinition),\n    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),\n    buildStorage: toStringEnhancer(buildStorage),\n    buildViewFns: toStringEnhancer(buildViewFns),\n    buildCall: toStringEnhancer(buildVariant(\"calls\")),\n    buildEvent: toStringEnhancer(buildVariant(\"events\")),\n    buildError: toStringEnhancer(buildVariant(\"errors\")),\n    buildConstant: toStringEnhancer(buildConstant),\n    buildComposite: toStringEnhancer(buildComposite),\n    buildNamedTuple: toStringEnhancer(buildNamedTuple),\n    getAllGeneratedChecksums: () =>\n      Array.from(cache.values()).map((v) => v.toString(32)),\n  }\n}\n", "import {\n  compact,\n  enhanceEncoder,\n  u8,\n  UnifiedMetadata,\n} from \"@polkadot-api/substrate-bindings\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\nimport { getLookupFn, LookupEntry } from \"@polkadot-api/metadata-builders\"\n\nconst versionCodec = enhanceEncoder(\n  u8.enc,\n  (value: { signed: boolean; version: number }) =>\n    (+!!value.signed << 7) | value.version,\n)\n\nconst enum SignerType {\n  Polkadot,\n  Ethereum,\n}\nconst unkownSignerType = () => new Error(\"Unkown signer\")\nconst getSignerType = (\n  metadata: UnifiedMetadata,\n): [SignerType, [] | [number]] => {\n  const { extrinsic } = metadata\n  const getLookup = getLookupFn(metadata)\n  let address: LookupEntry\n  let signature: LookupEntry\n  if (\"address\" in extrinsic) {\n    address = getLookup(extrinsic.address)\n    signature = getLookup(extrinsic.signature)\n  } else {\n    const extProps = Object.fromEntries(\n      metadata.lookup[extrinsic.type].params\n        .filter((x) => x.type != null)\n        .map((x) => [x.name, getLookup(x.type!)]),\n    )\n    address = extProps[\"Address\"]\n    signature = extProps[\"Signature\"]\n    if (!address || !signature) throw unkownSignerType()\n  }\n\n  if (\n    address.type === \"AccountId20\" &&\n    signature.type === \"array\" &&\n    signature.len === 65 &&\n    signature.value.type === \"primitive\" &&\n    signature.value.value === \"u8\"\n  )\n    return [SignerType.Ethereum, []]\n\n  if (\n    signature.type !== \"enum\" ||\n    [\"Ecdsa\", \"Ed25519\", \"Sr25519\"].some((x) => !(x in signature.value))\n  )\n    throw unkownSignerType()\n\n  if (address.type === \"enum\") {\n    const id = address.value[\"Id\"]\n    if (id.type === \"lookupEntry\" && id.value.type === \"AccountId32\")\n      return [SignerType.Polkadot, [id.idx]]\n  } else if (address.type === \"AccountId32\") return [SignerType.Polkadot, []]\n  throw unkownSignerType()\n}\n\nconst signingTypeId: Record<\"Ecdsa\" | \"Ed25519\" | \"Sr25519\", number> = {\n  Ed25519: 0,\n  Sr25519: 1,\n  Ecdsa: 2,\n}\n\nexport const createV4Tx = (\n  metadata: UnifiedMetadata,\n  publicKey: Uint8Array,\n  signed: Uint8Array,\n  extra: Uint8Array[],\n  callData: Uint8Array,\n  signingType?: \"Ecdsa\" | \"Ed25519\" | \"Sr25519\",\n) => {\n  const [signerType, addressPrefix] = getSignerType(metadata)\n  const preResult = mergeUint8(\n    versionCodec({ signed: true, version: 4 }),\n    // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`\n    signerType === SignerType.Ethereum\n      ? publicKey\n      : new Uint8Array([...addressPrefix, ...publicKey]),\n    signerType === SignerType.Ethereum || !signingType\n      ? signed\n      : new Uint8Array([signingTypeId[signingType], ...signed]),\n    ...extra,\n    callData,\n  )\n  return mergeUint8(compact.enc(preResult.length), preResult)\n}\n", "import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\n\nconst [preBytes, postBytes] = [\"<Bytes>\", \"</Bytes>\"].map((str) =>\n  Binary.fromText(str).asBytes(),\n)\n\nexport const getSignBytes =\n  (sign: (x: Uint8Array) => Uint8Array | Promise<Uint8Array>) =>\n  async (data: Uint8Array): Promise<Uint8Array> => {\n    let isPadded = true\n    let i: number\n\n    for (i = 0; isPadded && i < preBytes.length; i++)\n      isPadded = preBytes[i] === data[i]\n    isPadded = isPadded && i === preBytes.length\n\n    const postDataStart = data.length - postBytes.length\n    for (i = 0; isPadded && i < postBytes.length; i++)\n      isPadded = postBytes[i] === data[postDataStart + i]\n    isPadded = isPadded && i === postBytes.length\n\n    return sign(isPadded ? data : mergeUint8(preBytes, data, postBytes))\n  }\n"],
  "mappings": "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",
  "names": ["Option", "Result", "Struct", "Tuple", "Vector", "Enum", "enc", "arr", "padding", "str", "isBytes", "anumber", "abytes", "abytes", "u8", "arr", "u32", "arr", "hasHexBuiltin", "str", "abytes", "anumber", "u32", "abytes", "v14", "v15", "blake2b", "blake2b", "HEX_MAP", "fromHex", "mapObject", "mergeUint8", "noop", "textEncoder", "textDecoder", "__publicField", "mergeUint8", "fromHex", "Bin", "str", "enc", "fromHex", "dec", "textEncoder", "textDecoder", "str", "enc", "OEnum", "dec", "Enum", "mapObject", "anumber", "u32", "abytes", "keccak", "char", "fromHex", "Struct", "OStruct", "Tuple", "OTuple", "Vector", "OVector", "Result", "OResult", "Option", "OOption", "textEncoder", "textDecoder", "Struct", "Vector", "Enum", "bitSequence", "Enum", "ty", "Enum", "extrinsic", "ty", "extrinsic", "ty", "Enum", "metadata", "lookup", "extrinsic", "pallets", "blake2b", "mergeUint8", "arr", "abytes", "u32", "u8", "v14", "v15", "anumber", "len32", "mergeUint8", "add", "p", "temp", "mergeUint8", "textEncoder", "hashers", "mergeUint8", "dec", "fromHex", "opaqueBytes", "enc", "mergeUint8", "isBytes", "_void", "withCache", "entry", "def", "params", "metadata", "def", "_void", "extrinsic", "_bytes", "inner", "Vector", "Tuple", "value", "Struct", "Option", "Result", "lookup", "metadata", "entry", "value", "Tuple", "hashers", "Struct", "mapObject", "Vector", "lookup", "_a", "textEncoder", "metadata", "extrinsic", "mergeUint8", "str", "mergeUint8"]
}
