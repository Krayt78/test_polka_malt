import {
  aggregateWallets,
  connectWallet,
  disconnectWallet,
  getAccounts,
  getConnectedWallets
} from "./chunk-Y7OA44XQ.js";
import {
  AccountId,
  blake2b
} from "./chunk-EVM4Y7G3.js";
import {
  DeepLinkWallet,
  initializeWallets
} from "./chunk-OVJJME56.js";
import {
  BehaviorSubject,
  of,
  switchMap,
  tap
} from "./chunk-2T3XQHSK.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __superGet,
  __toESM
} from "./chunk-B4Q33VKO.js";

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version) {
      if (!version) throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f2) {
      if (typeof f2 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f2;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (let i2 = 0; i2 < length; i2++) {
          this.putBit((num >>> length - i2 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved) this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1) return [];
      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i2 = 1; i2 < posCount - 1; i2++) {
        positions[i2] = positions[i2 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version) {
      const coords = [];
      const pos = exports.getRowColCoords(version);
      const posLength = pos.length;
      for (let i2 = 0; i2 < posLength; i2++) {
        for (let j = 0; j < posLength; j++) {
          if (i2 === 0 && j === 0 || // top-left
          i2 === 0 && j === posLength - 1 || // bottom-left
          i2 === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i2], pos[j]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version) {
      const size = getSymbolSize(version);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i2 = 0; i2 < modulesCount; i2++) darkCount += data.data[i2];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i2, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i2 + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i2 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i2 + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i2 * j % 2 + i2 * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i2 * j % 2 + i2 * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i2 * j % 3 + (i2 + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p2 = 0; p2 < numPatterns; p2++) {
        setupFormatFunc(p2);
        exports.applyMask(p2, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p2, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p2;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x = 1;
      for (let i2 = 0; i2 < 255; i2++) {
        EXP_TABLE[i2] = x;
        LOG_TABLE[x] = i2;
        x <<= 1;
        if (x & 256) {
          x ^= 285;
        }
      }
      for (let i2 = 255; i2 < 512; i2++) {
        EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
      }
    })();
    exports.log = function log(n) {
      if (n < 1) throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports.mul = function mul(x, y2) {
      if (x === 0 || y2 === 0) return 0;
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y2]];
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i2 = 0; i2 < p1.length; i2++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i2 + j] ^= GF.mul(p1[i2], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i2 = 0; i2 < divisor.length; i2++) {
          result[i2] ^= GF.mul(divisor[i2], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i2 = 0; i2 < degree; i2++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
      }
      return poly;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10) return mode.ccBits[0];
      else if (version < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined") mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d3 = version << 12;
      while (Utils.getBCHDigit(d3) - G18_BCH >= 0) {
        d3 ^= G18 << Utils.getBCHDigit(d3) - G18_BCH;
      }
      return version << 12 | d3;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d3 = data << 10;
      while (Utils.getBCHDigit(d3) - G15_BCH >= 0) {
        d3 ^= G15 << Utils.getBCHDigit(d3) - G15_BCH;
      }
      return (data << 10 | d3) ^ G15_MASK;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i2, group, value;
      for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
        group = this.data.substr(i2, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i2;
      if (remainingNum > 0) {
        group = this.data.substr(i2);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i2;
      for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        this.data = new TextEncoder().encode(data);
      } else {
        this.data = new Uint8Array(data);
      }
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
        bitBuffer.put(this.data[i2], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i2;
      for (i2 = 0; i2 < this.data.length; i2++) {
        let value = Utils.toSJIS(this.data[i2]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s2, d3) {
        var predecessors = {};
        var costs = {};
        costs[s2] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s2, 0);
        var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u2 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u2] || {};
          for (v2 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v2)) {
              cost_of_e = adjacent_nodes[v2];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v2];
              first_visit = typeof costs[v2] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v2] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v2, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v2] = u2;
              }
            }
          }
        }
        if (typeof d3 !== "undefined" && typeof costs[d3] === "undefined") {
          var msg = ["Could not find a path from ", s2, " to ", d3, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d3) {
        var nodes = [];
        var u2 = d3;
        var predecessor;
        while (u2) {
          nodes.push(u2);
          predecessor = predecessors[u2];
          u2 = predecessors[u2];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s2, d3) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s2, d3);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d3
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T = dijkstra.PriorityQueue, t2 = {}, key;
          opts = opts || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t2[key] = T[key];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T.default_sorter;
          return t2;
        },
        default_sorter: function(a2, b2) {
          return a2.cost - b2.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i2 = 0; i2 < segs.length; i2++) {
        const seg = segs[i2];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const nodeGroup = nodes[i2];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = "" + i2 + j;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i2 = 1; i2 < path.length - 1; i2++) {
        optimizedSegs.push(graph.table[path[i2]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r) continue;
          for (let c2 = -1; c2 <= 7; c2++) {
            if (col + c2 <= -1 || size <= col + c2) continue;
            if (r >= 0 && r <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c2 >= 2 && c2 <= 4) {
              matrix.set(row + r, col + c2, true, true);
            } else {
              matrix.set(row + r, col + c2, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      const pos = AlignmentPattern.getPositions(version);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r = -2; r <= 2; r++) {
          for (let c2 = -2; c2 <= 2; c2++) {
            if (r === -2 || r === 2 || c2 === -2 || c2 === 2 || r === 0 && c2 === 0) {
              matrix.set(row + r, col + c2, true, true);
            } else {
              matrix.set(row + r, col + c2, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version);
      let row, col, mod;
      for (let i2 = 0; i2 < 18; i2++) {
        row = Math.floor(i2 / 3);
        col = i2 % 3 + size - 8 - 3;
        mod = (bits >> i2 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i2, mod;
      for (i2 = 0; i2 < 15; i2++) {
        mod = (bits >> i2 & 1) === 1;
        if (i2 < 6) {
          matrix.set(i2, 8, mod, true);
        } else if (i2 < 8) {
          matrix.set(i2 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i2, 8, mod, true);
        }
        if (i2 < 8) {
          matrix.set(8, size - i2 - 1, mod, true);
        } else if (i2 < 9) {
          matrix.set(8, 15 - i2 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i2 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c2 = 0; c2 < 2; c2++) {
            if (!matrix.isReserved(row, col - c2)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c2, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i2 = 0; i2 < remainingByte; i2++) {
        buffer.put(i2 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
        const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b2] = buffer.slice(offset, offset + dataSize);
        ecData[b2] = rs.encode(dcData[b2]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i2, r;
      for (i2 = 0; i2 < maxDataSize; i2++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i2 < dcData[r].length) {
            data[index++] = dcData[r][i2];
          }
        }
      }
      for (i2 = 0; i2 < ecCount; i2++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i2];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
          return [c2, c2];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i2 = 0; i2 < symbolSize; i2++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i2 * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i2 >= scaledMargin && j >= scaledMargin && i2 < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i2 - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e2) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render2(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x, y2) {
      let str = cmd + x;
      if (typeof y2 !== "undefined") str += " " + y2;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i2 = 0; i2 < data.length; i2++) {
        const col = Math.floor(i2 % size);
        const row = Math.floor(i2 / size);
        if (!col && !newRow) newRow = true;
        if (data[i2]) {
          lineLength++;
          if (!(i2 > 0 && col > 0 && data[i2 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i2 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render2(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e2) {
        cb(e2);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _2, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/const.js
var genericChainSpec = {
  name: "Polkadot",
  genesisHash: "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3",
  properties: { tokenSymbol: "DOT", tokenDecimals: 10 }
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/utils.js
function logAndThrow(error) {
  console.error(error);
  throw error;
}
function identifyBrowser() {
  const userAgent = globalThis.navigator.userAgent;
  const isFirefox = /Firefox/i.test(userAgent);
  const isChrome = /Chrome|Chromium/i.test(userAgent) && !/Edg/i.test(userAgent);
  const isAndroid = /Android/i.test(userAgent);
  const isIOS = /iPad|iPhone|iPod/i.test(userAgent) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  if (isAndroid) {
    return "android";
  } else if (isIOS) {
    return "ios";
  } else if (isFirefox) {
    return "firefox";
  } else if (isChrome) {
    return "chrome";
  } else {
    return void 0;
  }
}
function getDownloadUrl(walletInfo) {
  const platform = identifyBrowser();
  if (platform === void 0) {
    return void 0;
  }
  if (!walletInfo.platforms.includes(platform)) {
    return void 0;
  }
  if (typeof walletInfo.downloadUrl === "string") {
    return { platform: void 0, url: walletInfo.downloadUrl };
  }
  const urls = walletInfo.downloadUrl;
  if (urls === void 0) {
    return;
  }
  const exactUrl = platform in urls ? (
    // @ts-expect-error TODO
    urls[platform]
  ) : void 0;
  const url = exactUrl ?? ("default" in urls ? urls.default : void 0);
  if (url === void 0) {
    return;
  }
  return { platform, url };
}
function urlFromSvg(svg3) {
  return new URL(URL.createObjectURL(new Blob([svg3.strings.join()], { type: "image/svg+xml" })));
}

// node_modules/.pnpm/@lit+reactive-element@2.1.0/node_modules/@lit/reactive-element/development/css-tag.js
var NODE_MODE = false;
var global = globalThis;
var supportsAdoptingStyleSheets = global.ShadowRoot && (global.ShadyCSS === void 0 || global.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var cssTagCache = /* @__PURE__ */ new WeakMap();
var CSSResult = class {
  constructor(cssText, strings, safeToken) {
    this["_$cssResult$"] = true;
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
    this._strings = strings;
  }
  // This is a getter so that it's lazy. In practice, this means stylesheets
  // are not created until the first element instance is made.
  get styleSheet() {
    let styleSheet = this._styleSheet;
    const strings = this._strings;
    if (supportsAdoptingStyleSheets && styleSheet === void 0) {
      const cacheable = strings !== void 0 && strings.length === 1;
      if (cacheable) {
        styleSheet = cssTagCache.get(strings);
      }
      if (styleSheet === void 0) {
        (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);
        if (cacheable) {
          cssTagCache.set(strings, styleSheet);
        }
      }
    }
    return styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var textFromCSSResult = (value) => {
  if (value["_$cssResult$"] === true) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
  }
};
var unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), void 0, constructionToken);
var css = (strings, ...values) => {
  const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v2, idx) => acc + textFromCSSResult(v2) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, strings, constructionToken);
};
var adoptStyles = (renderRoot, styles) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles.map((s2) => s2 instanceof CSSStyleSheet ? s2 : s2.styleSheet);
  } else {
    for (const s2 of styles) {
      const style = document.createElement("style");
      const nonce = global["litNonce"];
      if (nonce !== void 0) {
        style.setAttribute("nonce", nonce);
      }
      style.textContent = s2.cssText;
      renderRoot.appendChild(style);
    }
  }
};
var cssResultFromStyleSheet = (sheet) => {
  let cssText = "";
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};
var getCompatibleStyle = supportsAdoptingStyleSheets || NODE_MODE && global.CSSStyleSheet === void 0 ? (s2) => s2 : (s2) => s2 instanceof CSSStyleSheet ? cssResultFromStyleSheet(s2) : s2;

// node_modules/.pnpm/@lit+reactive-element@2.1.0/node_modules/@lit/reactive-element/development/reactive-element.js
var { is, defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, getPrototypeOf } = Object;
var NODE_MODE2 = false;
var global2 = globalThis;
if (NODE_MODE2) {
  global2.customElements ?? (global2.customElements = customElements);
}
var DEV_MODE = true;
var issueWarning;
var trustedTypes = global2.trustedTypes;
var emptyStringForBooleanAttribute = trustedTypes ? trustedTypes.emptyScript : "";
var polyfillSupport = DEV_MODE ? global2.reactiveElementPolyfillSupportDevMode : global2.reactiveElementPolyfillSupport;
if (DEV_MODE) {
  global2.litIssuedWarnings ?? (global2.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!global2.litIssuedWarnings.has(warning) && !global2.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global2.litIssuedWarnings.add(warning);
    }
  };
  queueMicrotask(() => {
    var _a16;
    issueWarning("dev-mode", `Lit is in dev mode. Not recommended for production!`);
    if (((_a16 = global2.ShadyDOM) == null ? void 0 : _a16.inUse) && polyfillSupport === void 0) {
      issueWarning("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
    }
  });
}
var debugLogEvent = DEV_MODE ? (event) => {
  const shouldEmit = global2.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global2.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
} : void 0;
var JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? emptyStringForBooleanAttribute : null;
        break;
      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;
      case Number:
        fromValue = value === null ? null : Number(value);
        break;
      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e2) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  }
};
var notEqual = (value, old) => !is(value, old);
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  useDefault: false,
  hasChanged: notEqual
};
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata"));
global2.litPropertyMetadata ?? (global2.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var ReactiveElement = class extends HTMLElement {
  /**
   * Adds an initializer function to the class that is called during instance
   * construction.
   *
   * This is useful for code that runs against a `ReactiveElement`
   * subclass, such as a decorator, that needs to do work for each
   * instance, such as setting up a `ReactiveController`.
   *
   * ```ts
   * const myDecorator = (target: typeof ReactiveElement, key: string) => {
   *   target.addInitializer((instance: ReactiveElement) => {
   *     // This is run during construction of the element
   *     new MyController(instance);
   *   });
   * }
   * ```
   *
   * Decorating a field will then cause each instance to run an initializer
   * that adds a controller:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   @myDecorator foo;
   * }
   * ```
   *
   * Initializers are stored per-constructor. Adding an initializer to a
   * subclass does not add it to a superclass. Since initializers are run in
   * constructors, initializers will run in order of the class hierarchy,
   * starting with superclasses and progressing to the instance's class.
   *
   * @nocollapse
   */
  static addInitializer(initializer) {
    this.__prepare();
    (this._initializers ?? (this._initializers = [])).push(initializer);
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   * @category attributes
   */
  static get observedAttributes() {
    this.finalize();
    return this.__attributeToPropertyMap && [...this.__attributeToPropertyMap.keys()];
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a {@linkcode PropertyDeclaration} for the property with the
   * given options. The property setter calls the property's `hasChanged`
   * property option or uses a strict identity check to determine whether or not
   * to request an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * ```ts
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static createProperty(name, options = defaultPropertyDeclaration) {
    if (options.state) {
      options.attribute = false;
    }
    this.__prepare();
    if (this.prototype.hasOwnProperty(name)) {
      options = Object.create(options);
      options.wrapped = true;
    }
    this.elementProperties.set(name, options);
    if (!options.noAccessor) {
      const key = DEV_MODE ? (
        // Use Symbol.for in dev mode to make it easier to maintain state
        // when doing HMR.
        Symbol.for(`${String(name)} (@property() cache)`)
      ) : Symbol();
      const descriptor = this.getPropertyDescriptor(name, key, options);
      if (descriptor !== void 0) {
        defineProperty(this.prototype, name, descriptor);
      }
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   * ```ts
   * class MyElement extends LitElement {
   *   static getPropertyDescriptor(name, key, options) {
   *     const defaultDescriptor =
   *         super.getPropertyDescriptor(name, key, options);
   *     const setter = defaultDescriptor.set;
   *     return {
   *       get: defaultDescriptor.get,
   *       set(value) {
   *         setter.call(this, value);
   *         // custom action.
   *       },
   *       configurable: true,
   *       enumerable: true
   *     }
   *   }
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static getPropertyDescriptor(name, key, options) {
    const { get, set } = getOwnPropertyDescriptor(this.prototype, name) ?? {
      get() {
        return this[key];
      },
      set(v2) {
        this[key] = v2;
      }
    };
    if (DEV_MODE && get == null) {
      if ("value" in (getOwnPropertyDescriptor(this.prototype, name) ?? {})) {
        throw new Error(`Field ${JSON.stringify(String(name))} on ${this.name} was declared as a reactive property but it's actually declared as a value on the prototype. Usually this is due to using @property or @state on a method.`);
      }
      issueWarning("reactive-property-without-getter", `Field ${JSON.stringify(String(name))} on ${this.name} was declared as a reactive property but it does not have a getter. This will be an error in a future version of Lit.`);
    }
    return {
      get,
      set(value) {
        const oldValue = get == null ? void 0 : get.call(this);
        set == null ? void 0 : set.call(this, value);
        this.requestUpdate(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a `PropertyDeclaration` via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override
   * {@linkcode createProperty}.
   *
   * @nocollapse
   * @final
   * @category properties
   */
  static getPropertyOptions(name) {
    return this.elementProperties.get(name) ?? defaultPropertyDeclaration;
  }
  /**
   * Initializes static own properties of the class used in bookkeeping
   * for element properties, initializers, etc.
   *
   * Can be called multiple times by code that needs to ensure these
   * properties exist before using them.
   *
   * This method ensures the superclass is finalized so that inherited
   * property metadata can be copied down.
   * @nocollapse
   */
  static __prepare() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("elementProperties", this))) {
      return;
    }
    const superCtor = getPrototypeOf(this);
    superCtor.finalize();
    if (superCtor._initializers !== void 0) {
      this._initializers = [...superCtor._initializers];
    }
    this.elementProperties = new Map(superCtor.elementProperties);
  }
  /**
   * Finishes setting up the class so that it's ready to be registered
   * as a custom element and instantiated.
   *
   * This method is called by the ReactiveElement.observedAttributes getter.
   * If you override the observedAttributes getter, you must either call
   * super.observedAttributes to trigger finalization, or call finalize()
   * yourself.
   *
   * @nocollapse
   */
  static finalize() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("finalized", this))) {
      return;
    }
    this.finalized = true;
    this.__prepare();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...getOwnPropertyNames(props),
        ...getOwnPropertySymbols(props)
      ];
      for (const p2 of propKeys) {
        this.createProperty(p2, props[p2]);
      }
    }
    const metadata = this[Symbol.metadata];
    if (metadata !== null) {
      const properties = litPropertyMetadata.get(metadata);
      if (properties !== void 0) {
        for (const [p2, options] of properties) {
          this.elementProperties.set(p2, options);
        }
      }
    }
    this.__attributeToPropertyMap = /* @__PURE__ */ new Map();
    for (const [p2, options] of this.elementProperties) {
      const attr = this.__attributeNameForProperty(p2, options);
      if (attr !== void 0) {
        this.__attributeToPropertyMap.set(attr, p2);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    if (DEV_MODE) {
      if (this.hasOwnProperty("createProperty")) {
        issueWarning("no-override-create-property", "Overriding ReactiveElement.createProperty() is deprecated. The override will not be called with standard decorators");
      }
      if (this.hasOwnProperty("getPropertyDescriptor")) {
        issueWarning("no-override-get-property-descriptor", "Overriding ReactiveElement.getPropertyDescriptor() is deprecated. The override will not be called with standard decorators");
      }
    }
  }
  /**
   * Takes the styles the user supplied via the `static styles` property and
   * returns the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * Styles are deduplicated preserving the _last_ instance in the list. This
   * is a performance optimization to avoid duplicated styles that can occur
   * especially when composing via subclassing. The last item is kept to try
   * to preserve the cascade order with the assumption that it's most important
   * that last added styles override previous styles.
   *
   * @nocollapse
   * @category styles
   */
  static finalizeStyles(styles) {
    const elementStyles = [];
    if (Array.isArray(styles)) {
      const set = new Set(styles.flat(Infinity).reverse());
      for (const s2 of set) {
        elementStyles.unshift(getCompatibleStyle(s2));
      }
    } else if (styles !== void 0) {
      elementStyles.push(getCompatibleStyle(styles));
    }
    return elementStyles;
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */
  static __attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  constructor() {
    super();
    this.__instanceProperties = void 0;
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this.__initialize();
  }
  /**
   * Internal only override point for customizing work done when elements
   * are constructed.
   */
  __initialize() {
    var _a16;
    this.__updatePromise = new Promise((res) => this.enableUpdating = res);
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    (_a16 = this.constructor._initializers) == null ? void 0 : _a16.forEach((i2) => i2(this));
  }
  /**
   * Registers a `ReactiveController` to participate in the element's reactive
   * update cycle. The element automatically calls into any registered
   * controllers during its lifecycle callbacks.
   *
   * If the element is connected when `addController()` is called, the
   * controller's `hostConnected()` callback will be immediately called.
   * @category controllers
   */
  addController(controller) {
    var _a16;
    (this.__controllers ?? (this.__controllers = /* @__PURE__ */ new Set())).add(controller);
    if (this.renderRoot !== void 0 && this.isConnected) {
      (_a16 = controller.hostConnected) == null ? void 0 : _a16.call(controller);
    }
  }
  /**
   * Removes a `ReactiveController` from the element.
   * @category controllers
   */
  removeController(controller) {
    var _a16;
    (_a16 = this.__controllers) == null ? void 0 : _a16.delete(controller);
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs.
   */
  __saveInstanceProperties() {
    const instanceProperties = /* @__PURE__ */ new Map();
    const elementProperties = this.constructor.elementProperties;
    for (const p2 of elementProperties.keys()) {
      if (this.hasOwnProperty(p2)) {
        instanceProperties.set(p2, this[p2]);
        delete this[p2];
      }
    }
    if (instanceProperties.size > 0) {
      this.__instanceProperties = instanceProperties;
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   *
   * @return Returns a node into which to render.
   * @category rendering
   */
  createRenderRoot() {
    const renderRoot = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  /**
   * On first connection, creates the element's renderRoot, sets up
   * element styling, and enables updating.
   * @category lifecycle
   */
  connectedCallback() {
    var _a16;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot());
    this.enableUpdating(true);
    (_a16 = this.__controllers) == null ? void 0 : _a16.forEach((c2) => {
      var _a17;
      return (_a17 = c2.hostConnected) == null ? void 0 : _a17.call(c2);
    });
  }
  /**
   * Note, this method should be considered final and not overridden. It is
   * overridden on the element instance with a function that triggers the first
   * update.
   * @category updates
   */
  enableUpdating(_requestedUpdate) {
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   * @category lifecycle
   */
  disconnectedCallback() {
    var _a16;
    (_a16 = this.__controllers) == null ? void 0 : _a16.forEach((c2) => {
      var _a17;
      return (_a17 = c2.hostDisconnected) == null ? void 0 : _a17.call(c2);
    });
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * Specifically, when an attribute is set, the corresponding property is set.
   * You should rarely need to implement this callback. If this method is
   * overridden, `super.attributeChangedCallback(name, _old, value)` must be
   * called.
   *
   * See [responding to attribute changes](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#responding_to_attribute_changes)
   * on MDN for more information about the `attributeChangedCallback`.
   * @category attributes
   */
  attributeChangedCallback(name, _old, value) {
    this._$attributeToProperty(name, value);
  }
  __propertyToAttribute(name, value) {
    var _a16;
    const elemProperties = this.constructor.elementProperties;
    const options = elemProperties.get(name);
    const attr = this.constructor.__attributeNameForProperty(name, options);
    if (attr !== void 0 && options.reflect === true) {
      const converter = ((_a16 = options.converter) == null ? void 0 : _a16.toAttribute) !== void 0 ? options.converter : defaultConverter;
      const attrValue = converter.toAttribute(value, options.type);
      if (DEV_MODE && this.constructor.enabledWarnings.includes("migration") && attrValue === void 0) {
        issueWarning("undefined-attribute-value", `The attribute value for the ${name} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
      }
      this.__reflectingProperty = name;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  /** @internal */
  _$attributeToProperty(name, value) {
    var _a16, _b3;
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name);
    if (propName !== void 0 && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter = typeof options.converter === "function" ? { fromAttribute: options.converter } : ((_a16 = options.converter) == null ? void 0 : _a16.fromAttribute) !== void 0 ? options.converter : defaultConverter;
      this.__reflectingProperty = propName;
      this[propName] = converter.fromAttribute(value, options.type) ?? ((_b3 = this.__defaultValues) == null ? void 0 : _b3.get(propName)) ?? // eslint-disable-next-line @typescript-eslint/no-explicit-any
      null;
      this.__reflectingProperty = null;
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should be called
   * when an element should update based on some state not triggered by setting
   * a reactive property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored.
   *
   * @param name name of requesting property
   * @param oldValue old value of requesting property
   * @param options property options to use instead of the previously
   *     configured options
   * @category updates
   */
  requestUpdate(name, oldValue, options) {
    var _a16;
    if (name !== void 0) {
      if (DEV_MODE && name instanceof Event) {
        issueWarning(``, `The requestUpdate() method was called with an Event as the property name. This is probably a mistake caused by binding this.requestUpdate as an event listener. Instead bind a function that will call it with no arguments: () => this.requestUpdate()`);
      }
      const ctor = this.constructor;
      const newValue = this[name];
      options ?? (options = ctor.getPropertyOptions(name));
      const changed = (options.hasChanged ?? notEqual)(newValue, oldValue) || // When there is no change, check a corner case that can occur when
      // 1. there's a initial value which was not reflected
      // 2. the property is subsequently set to this value.
      // For example, `prop: {useDefault: true, reflect: true}`
      // and el.prop = 'foo'. This should be considered a change if the
      // attribute is not set because we will now reflect the property to the attribute.
      options.useDefault && options.reflect && newValue === ((_a16 = this.__defaultValues) == null ? void 0 : _a16.get(name)) && !this.hasAttribute(ctor.__attributeNameForProperty(name, options));
      if (changed) {
        this._$changeProperty(name, oldValue, options);
      } else {
        return;
      }
    }
    if (this.isUpdatePending === false) {
      this.__updatePromise = this.__enqueueUpdate();
    }
  }
  /**
   * @internal
   */
  _$changeProperty(name, oldValue, { useDefault, reflect, wrapped }, initializeValue) {
    if (useDefault && !(this.__defaultValues ?? (this.__defaultValues = /* @__PURE__ */ new Map())).has(name)) {
      this.__defaultValues.set(name, initializeValue ?? oldValue ?? this[name]);
      if (wrapped !== true || initializeValue !== void 0) {
        return;
      }
    }
    if (!this._$changedProperties.has(name)) {
      if (!this.hasUpdated && !useDefault) {
        oldValue = void 0;
      }
      this._$changedProperties.set(name, oldValue);
    }
    if (reflect === true && this.__reflectingProperty !== name) {
      (this.__reflectingProperties ?? (this.__reflectingProperties = /* @__PURE__ */ new Set())).add(name);
    }
  }
  /**
   * Sets up the element to asynchronously update.
   */
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
    } catch (e2) {
      Promise.reject(e2);
    }
    const result = this.scheduleUpdate();
    if (result != null) {
      await result;
    }
    return !this.isUpdatePending;
  }
  /**
   * Schedules an element update. You can override this method to change the
   * timing of updates by returning a Promise. The update will await the
   * returned Promise, and you should resolve the Promise to allow the update
   * to proceed. If this method is overridden, `super.scheduleUpdate()`
   * must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```ts
   * override protected async scheduleUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.scheduleUpdate();
   * }
   * ```
   * @category updates
   */
  scheduleUpdate() {
    const result = this.performUpdate();
    if (DEV_MODE && this.constructor.enabledWarnings.includes("async-perform-update") && typeof (result == null ? void 0 : result.then) === "function") {
      issueWarning("async-perform-update", `Element ${this.localName} returned a Promise from performUpdate(). This behavior is deprecated and will be removed in a future version of ReactiveElement.`);
    }
    return result;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * Call `performUpdate()` to immediately process a pending update. This should
   * generally not be needed, but it can be done in rare cases when you need to
   * update synchronously.
   *
   * @category updates
   */
  performUpdate() {
    var _a16;
    if (!this.isUpdatePending) {
      return;
    }
    debugLogEvent == null ? void 0 : debugLogEvent({ kind: "update" });
    if (!this.hasUpdated) {
      this.renderRoot ?? (this.renderRoot = this.createRenderRoot());
      if (DEV_MODE) {
        const ctor = this.constructor;
        const shadowedProperties = [...ctor.elementProperties.keys()].filter((p2) => this.hasOwnProperty(p2) && p2 in getPrototypeOf(this));
        if (shadowedProperties.length) {
          throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
        }
      }
      if (this.__instanceProperties) {
        for (const [p2, value] of this.__instanceProperties) {
          this[p2] = value;
        }
        this.__instanceProperties = void 0;
      }
      const elementProperties = this.constructor.elementProperties;
      if (elementProperties.size > 0) {
        for (const [p2, options] of elementProperties) {
          const { wrapped } = options;
          const value = this[p2];
          if (wrapped === true && !this._$changedProperties.has(p2) && value !== void 0) {
            this._$changeProperty(p2, void 0, options, value);
          }
        }
      }
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        (_a16 = this.__controllers) == null ? void 0 : _a16.forEach((c2) => {
          var _a17;
          return (_a17 = c2.hostUpdate) == null ? void 0 : _a17.call(c2);
        });
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e2) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e2;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  /**
   * Invoked before `update()` to compute values needed during the update.
   *
   * Implement `willUpdate` to compute property values that depend on other
   * properties and are used in the rest of the update process.
   *
   * ```ts
   * willUpdate(changedProperties) {
   *   // only need to check changed properties for an expensive computation.
   *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
   *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
   *   }
   * }
   *
   * render() {
   *   return html`SHA: ${this.sha}`;
   * }
   * ```
   *
   * @category updates
   */
  willUpdate(_changedProperties) {
  }
  // Note, this is an override point for polyfill-support.
  // @internal
  _$didUpdate(changedProperties) {
    var _a16;
    (_a16 = this.__controllers) == null ? void 0 : _a16.forEach((c2) => {
      var _a17;
      return (_a17 = c2.hostUpdated) == null ? void 0 : _a17.call(c2);
    });
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
    if (DEV_MODE && this.isUpdatePending && this.constructor.enabledWarnings.includes("change-in-update")) {
      issueWarning("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
    }
  }
  __markUpdated() {
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super.getUpdateComplete()`, then any subsequent state.
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  get updateComplete() {
    return this.getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   override async getUpdateComplete() {
   *     const result = await super.getUpdateComplete();
   *     await this._myChild.updateComplete;
   *     return result;
   *   }
   * }
   * ```
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  getUpdateComplete() {
    return this.__updatePromise;
  }
  /**
   * Controls whether or not `update()` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  update(_changedProperties) {
    this.__reflectingProperties && (this.__reflectingProperties = this.__reflectingProperties.forEach((p2) => this.__propertyToAttribute(p2, this[p2])));
    this.__markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  updated(_changedProperties) {
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * ```ts
   * firstUpdated() {
   *   this.renderRoot.getElementById('my-text-area').focus();
   * }
   * ```
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  firstUpdated(_changedProperties) {
  }
};
ReactiveElement.elementStyles = [];
ReactiveElement.shadowRootOptions = { mode: "open" };
ReactiveElement[JSCompiler_renameProperty("elementProperties", ReactiveElement)] = /* @__PURE__ */ new Map();
ReactiveElement[JSCompiler_renameProperty("finalized", ReactiveElement)] = /* @__PURE__ */ new Map();
polyfillSupport == null ? void 0 : polyfillSupport({ ReactiveElement });
if (DEV_MODE) {
  ReactiveElement.enabledWarnings = [
    "change-in-update",
    "async-perform-update"
  ];
  const ensureOwnWarnings = function(ctor) {
    if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings", ctor))) {
      ctor.enabledWarnings = ctor.enabledWarnings.slice();
    }
  };
  ReactiveElement.enableWarning = function(warning) {
    ensureOwnWarnings(this);
    if (!this.enabledWarnings.includes(warning)) {
      this.enabledWarnings.push(warning);
    }
  };
  ReactiveElement.disableWarning = function(warning) {
    ensureOwnWarnings(this);
    const i2 = this.enabledWarnings.indexOf(warning);
    if (i2 >= 0) {
      this.enabledWarnings.splice(i2, 1);
    }
  };
}
(global2.reactiveElementVersions ?? (global2.reactiveElementVersions = [])).push("2.1.0");
if (DEV_MODE && global2.reactiveElementVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/lit-html.js
var DEV_MODE2 = true;
var ENABLE_EXTRA_SECURITY_HOOKS = true;
var ENABLE_SHADYDOM_NOPATCH = true;
var NODE_MODE3 = false;
var global3 = globalThis;
var debugLogEvent2 = DEV_MODE2 ? (event) => {
  const shouldEmit = global3.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global3.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
} : void 0;
var debugLogRenderId = 0;
var issueWarning2;
if (DEV_MODE2) {
  global3.litIssuedWarnings ?? (global3.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning2 = (code, warning) => {
    warning += code ? ` See https://lit.dev/msg/${code} for more information.` : "";
    if (!global3.litIssuedWarnings.has(warning) && !global3.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global3.litIssuedWarnings.add(warning);
    }
  };
  queueMicrotask(() => {
    issueWarning2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
  });
}
var _a, _b;
var wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = global3.ShadyDOM) == null ? void 0 : _a.inUse) && ((_b = global3.ShadyDOM) == null ? void 0 : _b.noPatch) === true ? global3.ShadyDOM.wrap : (node) => node;
var trustedTypes2 = global3.trustedTypes;
var policy = trustedTypes2 ? trustedTypes2.createPolicy("lit-html", {
  createHTML: (s2) => s2
}) : void 0;
var identityFunction = (value) => value;
var noopSanitizer = (_node, _name, _type) => identityFunction;
var setSanitizer = (newSanitizer) => {
  if (!ENABLE_EXTRA_SECURITY_HOOKS) {
    return;
  }
  if (sanitizerFactoryInternal !== noopSanitizer) {
    throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
  }
  sanitizerFactoryInternal = newSanitizer;
};
var _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
  sanitizerFactoryInternal = noopSanitizer;
};
var createSanitizer = (node, name, type) => {
  return sanitizerFactoryInternal(node, name, type);
};
var boundAttributeSuffix = "$lit$";
var marker = `lit$${Math.random().toFixed(9).slice(2)}$`;
var markerMatch = "?" + marker;
var nodeMarker = `<${markerMatch}>`;
var d = NODE_MODE3 && global3.document === void 0 ? {
  createTreeWalker() {
    return {};
  }
} : document;
var createMarker = () => d.createComment("");
var isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
var isArray = Array.isArray;
var isIterable = (value) => isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
typeof (value == null ? void 0 : value[Symbol.iterator]) === "function";
var SPACE_CHAR = `[ 	
\f\r]`;
var ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
var NAME_CHAR = `[^\\s"'>=/]`;
var textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var COMMENT_START = 1;
var TAG_NAME = 2;
var DYNAMIC_TAG_NAME = 3;
var commentEndRegex = /-->/g;
var comment2EndRegex = />/g;
var tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
var ENTIRE_MATCH = 0;
var ATTRIBUTE_NAME = 1;
var SPACES_AND_EQUALS = 2;
var QUOTE_CHAR = 3;
var singleQuoteAttrEndRegex = /'/g;
var doubleQuoteAttrEndRegex = /"/g;
var rawTextElement = /^(?:script|style|textarea|title)$/i;
var HTML_RESULT = 1;
var SVG_RESULT = 2;
var MATHML_RESULT = 3;
var ATTRIBUTE_PART = 1;
var CHILD_PART = 2;
var PROPERTY_PART = 3;
var BOOLEAN_ATTRIBUTE_PART = 4;
var EVENT_PART = 5;
var ELEMENT_PART = 6;
var COMMENT_PART = 7;
var tag = (type) => (strings, ...values) => {
  if (DEV_MODE2 && strings.some((s2) => s2 === void 0)) {
    console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
  }
  if (DEV_MODE2) {
    if (values.some((val) => val == null ? void 0 : val["_$litStatic$"])) {
      issueWarning2("", `Static values 'literal' or 'unsafeStatic' cannot be used as values to non-static templates.
Please use the static 'html' tag function. See https://lit.dev/docs/templates/expressions/#static-expressions`);
    }
  }
  return {
    // This property needs to remain unminified.
    ["_$litType$"]: type,
    strings,
    values
  };
};
var html = tag(HTML_RESULT);
var svg = tag(SVG_RESULT);
var mathml = tag(MATHML_RESULT);
var noChange = Symbol.for("lit-noChange");
var nothing = Symbol.for("lit-nothing");
var templateCache = /* @__PURE__ */ new WeakMap();
var walker = d.createTreeWalker(
  d,
  129
  /* NodeFilter.SHOW_{ELEMENT|COMMENT} */
);
var sanitizerFactoryInternal = noopSanitizer;
function trustFromTemplateString(tsa, stringFromTSA) {
  if (!isArray(tsa) || !tsa.hasOwnProperty("raw")) {
    let message = "invalid template strings array";
    if (DEV_MODE2) {
      message = `
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.
          If you're using the html or svg tagged template functions normally
          and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `.trim().replace(/\n */g, "\n");
    }
    throw new Error(message);
  }
  return policy !== void 0 ? policy.createHTML(stringFromTSA) : stringFromTSA;
}
var getTemplateHtml = (strings, type) => {
  const l2 = strings.length - 1;
  const attrNames = [];
  let html3 = type === SVG_RESULT ? "<svg>" : type === MATHML_RESULT ? "<math>" : "";
  let rawTextEndRegex;
  let regex = textEndRegex;
  for (let i2 = 0; i2 < l2; i2++) {
    const s2 = strings[i2];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match;
    while (lastIndex < s2.length) {
      regex.lastIndex = lastIndex;
      match = regex.exec(s2);
      if (match === null) {
        break;
      }
      lastIndex = regex.lastIndex;
      if (regex === textEndRegex) {
        if (match[COMMENT_START] === "!--") {
          regex = commentEndRegex;
        } else if (match[COMMENT_START] !== void 0) {
          regex = comment2EndRegex;
        } else if (match[TAG_NAME] !== void 0) {
          if (rawTextElement.test(match[TAG_NAME])) {
            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, "g");
          }
          regex = tagEndRegex;
        } else if (match[DYNAMIC_TAG_NAME] !== void 0) {
          if (DEV_MODE2) {
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
          }
          regex = tagEndRegex;
        }
      } else if (regex === tagEndRegex) {
        if (match[ENTIRE_MATCH] === ">") {
          regex = rawTextEndRegex ?? textEndRegex;
          attrNameEndIndex = -1;
        } else if (match[ATTRIBUTE_NAME] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;
          attrName = match[ATTRIBUTE_NAME];
          regex = match[QUOTE_CHAR] === void 0 ? tagEndRegex : match[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
        }
      } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
        regex = tagEndRegex;
      } else if (regex === commentEndRegex || regex === comment2EndRegex) {
        regex = textEndRegex;
      } else {
        regex = tagEndRegex;
        rawTextEndRegex = void 0;
      }
    }
    if (DEV_MODE2) {
      console.assert(attrNameEndIndex === -1 || regex === tagEndRegex || regex === singleQuoteAttrEndRegex || regex === doubleQuoteAttrEndRegex, "unexpected parse state B");
    }
    const end = regex === tagEndRegex && strings[i2 + 1].startsWith("/>") ? " " : "";
    html3 += regex === textEndRegex ? s2 + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s2.slice(0, attrNameEndIndex) + boundAttributeSuffix + s2.slice(attrNameEndIndex)) + marker + end : s2 + marker + (attrNameEndIndex === -2 ? i2 : end);
  }
  const htmlResult = html3 + (strings[l2] || "<?>") + (type === SVG_RESULT ? "</svg>" : type === MATHML_RESULT ? "</math>" : "");
  return [trustFromTemplateString(strings, htmlResult), attrNames];
};
var Template = class _Template {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html3, attrNames] = getTemplateHtml(strings, type);
    this.el = _Template.createElement(html3, options);
    walker.currentNode = this.el.content;
    if (type === SVG_RESULT || type === MATHML_RESULT) {
      const wrapper = this.el.content.firstChild;
      wrapper.replaceWith(...wrapper.childNodes);
    }
    while ((node = walker.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        if (DEV_MODE2) {
          const tag2 = node.localName;
          if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker)) {
            const m = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
            if (tag2 === "template") {
              throw new Error(m);
            } else
              issueWarning2("", m);
          }
        }
        if (node.hasAttributes()) {
          for (const name of node.getAttributeNames()) {
            if (name.endsWith(boundAttributeSuffix)) {
              const realName = attrNames[attrNameIndex++];
              const value = node.getAttribute(name);
              const statics = value.split(marker);
              const m = /([.?@])?(.*)/.exec(realName);
              parts.push({
                type: ATTRIBUTE_PART,
                index: nodeIndex,
                name: m[2],
                strings: statics,
                ctor: m[1] === "." ? PropertyPart : m[1] === "?" ? BooleanAttributePart : m[1] === "@" ? EventPart : AttributePart
              });
              node.removeAttribute(name);
            } else if (name.startsWith(marker)) {
              parts.push({
                type: ELEMENT_PART,
                index: nodeIndex
              });
              node.removeAttribute(name);
            }
          }
        }
        if (rawTextElement.test(node.tagName)) {
          const strings2 = node.textContent.split(marker);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes2 ? trustedTypes2.emptyScript : "";
            for (let i2 = 0; i2 < lastIndex; i2++) {
              node.append(strings2[i2], createMarker());
              walker.nextNode();
              parts.push({ type: CHILD_PART, index: ++nodeIndex });
            }
            node.append(strings2[lastIndex], createMarker());
          }
        }
      } else if (node.nodeType === 8) {
        const data = node.data;
        if (data === markerMatch) {
          parts.push({ type: CHILD_PART, index: nodeIndex });
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker, i2 + 1)) !== -1) {
            parts.push({ type: COMMENT_PART, index: nodeIndex });
            i2 += marker.length - 1;
          }
        }
      }
      nodeIndex++;
    }
    if (DEV_MODE2) {
      if (attrNames.length !== attrNameIndex) {
        throw new Error(`Detected duplicate attribute bindings. This occurs if your template has duplicate attributes on an element tag. For example "<input ?disabled=\${true} ?disabled=\${false}>" contains a duplicate "disabled" attribute. The error was detected in the following template: 
\`` + strings.join("${...}") + "`");
      }
    }
    debugLogEvent2 && debugLogEvent2({
      kind: "template prep",
      template: this,
      clonableTemplate: this.el,
      parts: this.parts,
      strings
    });
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @nocollapse */
  static createElement(html3, _options) {
    const el = d.createElement("template");
    el.innerHTML = html3;
    return el;
  }
};
function resolveDirective(part, value, parent = part, attributeIndex) {
  var _a16, _b3;
  if (value === noChange) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a16 = parent.__directives) == null ? void 0 : _a16[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive(value) ? void 0 : (
    // This property needs to remain unminified.
    value["_$litDirective$"]
  );
  if ((currentDirective == null ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b3 = currentDirective == null ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) == null ? void 0 : _b3.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      (parent.__directives ?? (parent.__directives = []))[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
var TemplateInstance = class {
  constructor(template, parent) {
    this._$parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template;
    this._$parent = parent;
  }
  // Called by ChildPart parentNode getter
  get parentNode() {
    return this._$parent.parentNode;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  // This method is separate from the constructor because we need to return a
  // DocumentFragment and we don't want to hold onto it with an instance field.
  _clone(options) {
    const { el: { content }, parts } = this._$template;
    const fragment = ((options == null ? void 0 : options.creationScope) ?? d).importNode(content, true);
    walker.currentNode = fragment;
    let node = walker.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART) {
          part = new ChildPart(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART) {
          part = new ElementPart(node, this, options);
        }
        this._$parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== (templatePart == null ? void 0 : templatePart.index)) {
        node = walker.nextNode();
        nodeIndex++;
      }
    }
    walker.currentNode = d;
    return fragment;
  }
  _update(values) {
    let i2 = 0;
    for (const part of this._$parts) {
      if (part !== void 0) {
        debugLogEvent2 && debugLogEvent2({
          kind: "set part",
          part,
          value: values[i2],
          valueIndex: i2,
          values,
          templateInstance: this
        });
        if (part.strings !== void 0) {
          part._$setValue(values, part, i2);
          i2 += part.strings.length - 2;
        } else {
          part._$setValue(values[i2]);
        }
      }
      i2++;
    }
  }
};
var ChildPart = class _ChildPart {
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    var _a16;
    return ((_a16 = this._$parent) == null ? void 0 : _a16._$isConnected) ?? this.__isConnected;
  }
  constructor(startNode, endNode, parent, options) {
    this.type = CHILD_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected = (options == null ? void 0 : options.isConnected) ?? true;
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      this._textSanitizer = void 0;
    }
  }
  /**
   * The parent node into which the part renders its content.
   *
   * A ChildPart's content consists of a range of adjacent child nodes of
   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
   * `.endNode`).
   *
   * - If both `.startNode` and `.endNode` are non-null, then the part's content
   * consists of all siblings between `.startNode` and `.endNode`, exclusively.
   *
   * - If `.startNode` is non-null but `.endNode` is null, then the part's
   * content consists of all siblings following `.startNode`, up to and
   * including the last child of `.parentNode`. If `.endNode` is non-null, then
   * `.startNode` will always be non-null.
   *
   * - If both `.endNode` and `.startNode` are null, then the part's content
   * consists of all child nodes of `.parentNode`.
   */
  get parentNode() {
    let parentNode = wrap(this._$startNode).parentNode;
    const parent = this._$parent;
    if (parent !== void 0 && (parentNode == null ? void 0 : parentNode.nodeType) === 11) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  /**
   * The part's leading marker node, if any. See `.parentNode` for more
   * information.
   */
  get startNode() {
    return this._$startNode;
  }
  /**
   * The part's trailing marker node, if any. See `.parentNode` for more
   * information.
   */
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    var _a16;
    if (DEV_MODE2 && this.parentNode === null) {
      throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
    }
    value = resolveDirective(this, value, directiveParent);
    if (isPrimitive(value)) {
      if (value === nothing || value == null || value === "") {
        if (this._$committedValue !== nothing) {
          debugLogEvent2 && debugLogEvent2({
            kind: "commit nothing to child",
            start: this._$startNode,
            end: this._$endNode,
            parent: this._$parent,
            options: this.options
          });
          this._$clear();
        }
        this._$committedValue = nothing;
      } else if (value !== this._$committedValue && value !== noChange) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      if (DEV_MODE2 && ((_a16 = this.options) == null ? void 0 : _a16.host) === value) {
        this._commitText(`[probable mistake: rendered a template's host in itself (commonly caused by writing \${this} in a template]`);
        console.warn(`Attempted to render the template host`, value, `inside itself. This is almost always a mistake, and in dev mode `, `we render some warning text. In production however, we'll `, `render it, which will usually result in an error, and sometimes `, `in the element disappearing from the DOM.`);
        return;
      }
      this._commitNode(value);
    } else if (isIterable(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node) {
    return wrap(wrap(this._$startNode).parentNode).insertBefore(node, this._$endNode);
  }
  _commitNode(value) {
    var _a16;
    if (this._$committedValue !== value) {
      this._$clear();
      if (ENABLE_EXTRA_SECURITY_HOOKS && sanitizerFactoryInternal !== noopSanitizer) {
        const parentNodeName = (_a16 = this._$startNode.parentNode) == null ? void 0 : _a16.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          let message = "Forbidden";
          if (DEV_MODE2) {
            if (parentNodeName === "STYLE") {
              message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
            } else {
              message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
            }
          }
          throw new Error(message);
        }
      }
      debugLogEvent2 && debugLogEvent2({
        kind: "commit node",
        start: this._$startNode,
        parent: this._$parent,
        value,
        options: this.options
      });
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
      const node = wrap(this._$startNode).nextSibling;
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(node, "data", "property");
        }
        value = this._textSanitizer(value);
      }
      debugLogEvent2 && debugLogEvent2({
        kind: "commit text",
        node,
        value,
        options: this.options
      });
      node.data = value;
    } else {
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        const textNode = d.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(textNode, "data", "property");
        }
        value = this._textSanitizer(value);
        debugLogEvent2 && debugLogEvent2({
          kind: "commit text",
          node: textNode,
          value,
          options: this.options
        });
        textNode.data = value;
      } else {
        this._commitNode(d.createTextNode(value));
        debugLogEvent2 && debugLogEvent2({
          kind: "commit text",
          node: wrap(this._$startNode).nextSibling,
          value,
          options: this.options
        });
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result) {
    var _a16;
    const { values, ["_$litType$"]: type } = result;
    const template = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template.createElement(trustFromTemplateString(type.h, type.h[0]), this.options)), type);
    if (((_a16 = this._$committedValue) == null ? void 0 : _a16._$template) === template) {
      debugLogEvent2 && debugLogEvent2({
        kind: "template updating",
        template,
        instance: this._$committedValue,
        parts: this._$committedValue._$parts,
        options: this.options,
        values
      });
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance(template, this);
      const fragment = instance._clone(this.options);
      debugLogEvent2 && debugLogEvent2({
        kind: "template instantiated",
        template,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      instance._update(values);
      debugLogEvent2 && debugLogEvent2({
        kind: "template instantiated and updated",
        template,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      this._commitNode(fragment);
      this._$committedValue = instance;
    }
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @internal */
  _$getTemplate(result) {
    let template = templateCache.get(result.strings);
    if (template === void 0) {
      templateCache.set(result.strings, template = new Template(result));
    }
    return template;
  }
  _commitIterable(value) {
    if (!isArray(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new _ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  /**
   * Removes the nodes contained within this Part from the DOM.
   *
   * @param start Start node to clear from, for clearing a subset of the part's
   *     DOM (used when truncating iterables)
   * @param from  When `start` is specified, the index within the iterable from
   *     which ChildParts are being removed, used for disconnecting directives in
   *     those Parts.
   *
   * @internal
   */
  _$clear(start = wrap(this._$startNode).nextSibling, from) {
    var _a16;
    (_a16 = this._$notifyConnectionChanged) == null ? void 0 : _a16.call(this, false, true, from);
    while (start && start !== this._$endNode) {
      const n = wrap(start).nextSibling;
      wrap(start).remove();
      start = n;
    }
  }
  /**
   * Implementation of RootPart's `isConnected`. Note that this method
   * should only be called on `RootPart`s (the `ChildPart` returned from a
   * top-level `render()` call). It has no effect on non-root ChildParts.
   * @param isConnected Whether to set
   * @internal
   */
  setConnected(isConnected) {
    var _a16;
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      (_a16 = this._$notifyConnectionChanged) == null ? void 0 : _a16.call(this, isConnected);
    } else if (DEV_MODE2) {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
};
var AttributePart = class {
  get tagName() {
    return this.element.tagName;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  constructor(element, name, strings, parent, options) {
    this.type = ATTRIBUTE_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this.element = element;
    this.name = name;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing;
    }
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      this._sanitizer = void 0;
    }
  }
  /**
   * Sets the value of this part by resolving the value from possibly multiple
   * values and static strings and committing it to the DOM.
   * If this part is single-valued, `this._strings` will be undefined, and the
   * method will be called with a single value argument. If this part is
   * multi-value, `this._strings` will be defined, and the method is called
   * with the value array of the part's owning TemplateInstance, and an offset
   * into the value array from which the values should be read.
   * This method is overloaded this way to eliminate short-lived array slices
   * of the template instance values, and allow a fast-path for single-valued
   * parts.
   *
   * @param value The part value, or an array of values for multi-valued parts
   * @param valueIndex the index to start reading values from. `undefined` for
   *   single-valued parts
   * @param noCommit causes the part to not commit its value to the DOM. Used
   *   in hydration to prime attribute parts with their first-rendered value,
   *   but not set the attribute, and in SSR to no-op the DOM operation and
   *   capture the value for serialization.
   *
   * @internal
   */
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective(this, value, directiveParent, 0);
      change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i2, v2;
      for (i2 = 0; i2 < strings.length - 1; i2++) {
        v2 = resolveDirective(this, values[valueIndex + i2], directiveParent, i2);
        if (v2 === noChange) {
          v2 = this._$committedValue[i2];
        }
        change || (change = !isPrimitive(v2) || v2 !== this._$committedValue[i2]);
        if (v2 === nothing) {
          value = nothing;
        } else if (value !== nothing) {
          value += (v2 ?? "") + strings[i2 + 1];
        }
        this._$committedValue[i2] = v2;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  /** @internal */
  _commitValue(value) {
    if (value === nothing) {
      wrap(this.element).removeAttribute(this.name);
    } else {
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "attribute");
        }
        value = this._sanitizer(value ?? "");
      }
      debugLogEvent2 && debugLogEvent2({
        kind: "commit attribute",
        element: this.element,
        name: this.name,
        value,
        options: this.options
      });
      wrap(this.element).setAttribute(this.name, value ?? "");
    }
  }
};
var PropertyPart = class extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART;
  }
  /** @internal */
  _commitValue(value) {
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "property");
      }
      value = this._sanitizer(value);
    }
    debugLogEvent2 && debugLogEvent2({
      kind: "commit property",
      element: this.element,
      name: this.name,
      value,
      options: this.options
    });
    this.element[this.name] = value === nothing ? void 0 : value;
  }
};
var BooleanAttributePart = class extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART;
  }
  /** @internal */
  _commitValue(value) {
    debugLogEvent2 && debugLogEvent2({
      kind: "commit boolean attribute",
      element: this.element,
      name: this.name,
      value: !!(value && value !== nothing),
      options: this.options
    });
    wrap(this.element).toggleAttribute(this.name, !!value && value !== nothing);
  }
};
var EventPart = class extends AttributePart {
  constructor(element, name, strings, parent, options) {
    super(element, name, strings, parent, options);
    this.type = EVENT_PART;
    if (DEV_MODE2 && this.strings !== void 0) {
      throw new Error(`A \`<${element.localName}>\` has a \`@${name}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
  }
  // EventPart does not use the base _$setValue/_resolveValue implementation
  // since the dirty checking is more complex
  /** @internal */
  _$setValue(newListener, directiveParent = this) {
    newListener = resolveDirective(this, newListener, directiveParent, 0) ?? nothing;
    if (newListener === noChange) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
    debugLogEvent2 && debugLogEvent2({
      kind: "commit event listener",
      element: this.element,
      name: this.name,
      value: newListener,
      options: this.options,
      removeListener: shouldRemoveListener,
      addListener: shouldAddListener,
      oldListener
    });
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a16;
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call(((_a16 = this.options) == null ? void 0 : _a16.host) ?? this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
};
var ElementPart = class {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    debugLogEvent2 && debugLogEvent2({
      kind: "commit to element binding",
      element: this.element,
      value,
      options: this.options
    });
    resolveDirective(this, value);
  }
};
var _$LH = {
  // Used in lit-ssr
  _boundAttributeSuffix: boundAttributeSuffix,
  _marker: marker,
  _markerMatch: markerMatch,
  _HTML_RESULT: HTML_RESULT,
  _getTemplateHtml: getTemplateHtml,
  // Used in tests and private-ssr-support
  _TemplateInstance: TemplateInstance,
  _isIterable: isIterable,
  _resolveDirective: resolveDirective,
  _ChildPart: ChildPart,
  _AttributePart: AttributePart,
  _BooleanAttributePart: BooleanAttributePart,
  _EventPart: EventPart,
  _PropertyPart: PropertyPart,
  _ElementPart: ElementPart
};
var polyfillSupport2 = DEV_MODE2 ? global3.litHtmlPolyfillSupportDevMode : global3.litHtmlPolyfillSupport;
polyfillSupport2 == null ? void 0 : polyfillSupport2(Template, ChildPart);
(global3.litHtmlVersions ?? (global3.litHtmlVersions = [])).push("3.3.0");
if (DEV_MODE2 && global3.litHtmlVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}
var render = (value, container, options) => {
  if (DEV_MODE2 && container == null) {
    throw new TypeError(`The container to render into may not be ${container}`);
  }
  const renderId = DEV_MODE2 ? debugLogRenderId++ : 0;
  const partOwnerNode = (options == null ? void 0 : options.renderBefore) ?? container;
  let part = partOwnerNode["_$litPart$"];
  debugLogEvent2 && debugLogEvent2({
    kind: "begin render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  if (part === void 0) {
    const endNode = (options == null ? void 0 : options.renderBefore) ?? null;
    partOwnerNode["_$litPart$"] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, void 0, options ?? {});
  }
  part._$setValue(value);
  debugLogEvent2 && debugLogEvent2({
    kind: "end render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  return part;
};
if (ENABLE_EXTRA_SECURITY_HOOKS) {
  render.setSanitizer = setSanitizer;
  render.createSanitizer = createSanitizer;
  if (DEV_MODE2) {
    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
  }
}

// node_modules/.pnpm/lit-element@4.2.0/node_modules/lit-element/development/lit-element.js
var JSCompiler_renameProperty2 = (prop, _obj) => prop;
var DEV_MODE3 = true;
var global4 = globalThis;
var issueWarning3;
if (DEV_MODE3) {
  global4.litIssuedWarnings ?? (global4.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning3 = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!global4.litIssuedWarnings.has(warning) && !global4.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global4.litIssuedWarnings.add(warning);
    }
  };
}
var LitElement = class extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = { host: this };
    this.__childPart = void 0;
  }
  /**
   * @category rendering
   */
  createRenderRoot() {
    var _a16;
    const renderRoot = super.createRenderRoot();
    (_a16 = this.renderOptions).renderBefore ?? (_a16.renderBefore = renderRoot.firstChild);
    return renderRoot;
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param changedProperties Map of changed properties with old values
   * @category updates
   */
  update(changedProperties) {
    const value = this.render();
    if (!this.hasUpdated) {
      this.renderOptions.isConnected = this.isConnected;
    }
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  /**
   * Invoked when the component is added to the document's DOM.
   *
   * In `connectedCallback()` you should setup tasks that should only occur when
   * the element is connected to the document. The most common of these is
   * adding event listeners to nodes external to the element, like a keydown
   * event handler added to the window.
   *
   * ```ts
   * connectedCallback() {
   *   super.connectedCallback();
   *   addEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * Typically, anything done in `connectedCallback()` should be undone when the
   * element is disconnected, in `disconnectedCallback()`.
   *
   * @category lifecycle
   */
  connectedCallback() {
    var _a16;
    super.connectedCallback();
    (_a16 = this.__childPart) == null ? void 0 : _a16.setConnected(true);
  }
  /**
   * Invoked when the component is removed from the document's DOM.
   *
   * This callback is the main signal to the element that it may no longer be
   * used. `disconnectedCallback()` should ensure that nothing is holding a
   * reference to the element (such as event listeners added to nodes external
   * to the element), so that it is free to be garbage collected.
   *
   * ```ts
   * disconnectedCallback() {
   *   super.disconnectedCallback();
   *   window.removeEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * An element may be re-connected after being disconnected.
   *
   * @category lifecycle
   */
  disconnectedCallback() {
    var _a16;
    super.disconnectedCallback();
    (_a16 = this.__childPart) == null ? void 0 : _a16.setConnected(false);
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's `ChildPart` - typically a
   * `TemplateResult`. Setting properties inside this method will *not* trigger
   * the element to update.
   * @category rendering
   */
  render() {
    return noChange;
  }
};
LitElement["_$litElement$"] = true;
LitElement[JSCompiler_renameProperty2("finalized", LitElement)] = true;
var _a2;
(_a2 = global4.litElementHydrateSupport) == null ? void 0 : _a2.call(global4, { LitElement });
var polyfillSupport3 = DEV_MODE3 ? global4.litElementPolyfillSupportDevMode : global4.litElementPolyfillSupport;
polyfillSupport3 == null ? void 0 : polyfillSupport3({ LitElement });
(global4.litElementVersions ?? (global4.litElementVersions = [])).push("4.2.0");
if (DEV_MODE3 && global4.litElementVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning3("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/wallets/ledger.js
var ledger = {
  selector: (wallet2) => wallet2.id === "ledger",
  name: "Ledger",
  logo: urlFromSvg(html`<svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 28 28"
      fill="none"
    >
      <script xmlns="" />
      <path fill="#000" d="M0 0h28v28H0z" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M11.65 4.4H4.4V9h1.1V5.5l6.15-.04V4.4Zm.05 5.95v7.25h4.6v-1.1h-3.5l-.04-6.15H11.7ZM4.4 23.6h7.25v-1.06L5.5 22.5V19H4.4v4.6ZM16.35 4.4h7.25V9h-1.1V5.5l-6.15-.04V4.4Zm7.25 19.2h-7.25v-1.06l6.15-.04V19h1.1v4.6Z"
        clip-rule="evenodd"
      />
    </svg>`)
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/wallets/mimir.js
var mimir = {
  selector: (wallet2) => wallet2.id === "mimir" || wallet2.id === "injected/mimir",
  name: "Mimir",
  platforms: ["chrome", "firefox"],
  logo: urlFromSvg(html`<svg viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg">
      <g>
        <rect width="15" height="15" rx="7.5" fill="#2700FF" />
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M12.0001 5.59628L12 12.2656H10.0125L10.0126 9.02998C9.29958 9.59709 8.45981 9.89257 7.5 9.89257C6.54019 9.89257 5.70042 9.59709 4.98743 9.02998L4.9875 12.2656H3L3.00001 5.59632C3.29033 5.77239 3.63032 5.87364 3.99375 5.87364C4.35718 5.87364 4.69716 5.77239 4.98748 5.59633L4.98744 5.66363C5.61085 7.23839 6.42948 7.9258 7.5 7.9258C8.57052 7.9258 9.38915 7.23839 10.0126 5.66363L10.0125 5.59633C10.3028 5.77239 10.6428 5.87364 11.0063 5.87364C11.3697 5.87364 11.7097 5.77237 12.0001 5.59628ZM3.99375 5.11719C4.64614 5.11719 5.175 4.58378 5.175 3.92578C5.175 3.26779 4.64614 2.73438 3.99375 2.73438C3.34136 2.73438 2.8125 3.26779 2.8125 3.92578C2.8125 4.58378 3.34136 5.11719 3.99375 5.11719ZM11.0063 5.11719C11.6586 5.11719 12.1875 4.58378 12.1875 3.92578C12.1875 3.26779 11.6586 2.73438 11.0063 2.73438C10.3539 2.73438 9.825 3.26779 9.825 3.92578C9.825 4.58378 10.3539 5.11719 11.0063 5.11719Z"
          fill="white"
        />
      </g>
    </svg>`)
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/wallets/nova.js
var nova = {
  selector: (wallet2) => wallet2.id === "injected/polkadot-js" && // TODO: remove once Nova is fixed
  ["ios", "android"].includes(identifyBrowser()),
  name: "Nova Wallet",
  platforms: ["ios", "android"],
  logo: urlFromSvg(html`<svg
      x="0px"
      y="0px"
      viewBox="0 0 324 324"
      style="enable-background:new 0 0 324 324;"
      xmlns="http://www.w3.org/2000/svg"
    >
      <style type="text/css">
        .st0 {
          fill: url(#SVGID_1_);
        }
        .st1 {
          fill: #ffffff;
        }
      </style>
      <radialGradient
        id="SVGID_1_"
        cx="8.15"
        cy="19.93"
        r="372.6356"
        gradientTransform="matrix(1 0 0 -1 0 326)"
        gradientUnits="userSpaceOnUse"
      >
        <stop offset="5.331913e-02" style="stop-color:#D7D3E9" />
        <stop offset="0.1933" style="stop-color:#A19CDE" />
        <stop offset="0.3834" style="stop-color:#696BD9" />
        <stop offset="0.54" style="stop-color:#3A5AE7" />
        <stop offset="0.7735" style="stop-color:#225FE7" />
        <stop offset="1" style="stop-color:#0883D1" />
      </radialGradient>
      <path
        class="st0"
        d="M84.1,0h155.8C286.3,0,324,37.7,324,84.1v155.8c0,46.5-37.7,84.1-84.1,84.1H84.1C37.7,324,0,286.3,0,239.9V84.1  C0,37.7,37.7,0,84.1,0z"
      />
      <path
        class="st1"
        d="M275,166.7v3c-18.4,2.9-58,9.8-77.5,17.2c-7,2.7-12.5,8.1-15.2,15.1c-7.4,19.4-14.4,59.2-17.3,77.7h-6  c-2.9-18.5-9.9-58.4-17.3-77.7c-2.7-6.9-8.2-12.4-15.2-15.1c-19.5-7.5-59-14.3-77.5-17.2v-6c18.4-2.9,58-9.8,77.5-17.2  c7-2.7,12.5-8.1,15.2-15.1c7.5-19.4,14.4-59.2,17.3-77.7h6c2.9,18.5,9.9,58.3,17.3,77.7c2.7,6.9,8.2,12.4,15.2,15.1  c19.5,7.4,59.1,14.3,77.5,17.2L275,166.7z"
      />
    </svg>`),
  downloadUrl: {
    ios: "https://apps.apple.com/us/app/nova-polkadot-wallet/id1597119355",
    android: "https://play.google.com/store/apps/details?id=io.novafoundation.nova.market"
  }
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/wallets/polkadot-js.js
var polkadotJs = {
  selector: (wallet2) => wallet2.id === "injected/polkadot-js" && // TODO: remove once Nova is fixed
  !["ios", "android"].includes(identifyBrowser()),
  name: "Polkadot{.js}",
  platforms: ["chrome", "firefox"],
  logo: urlFromSvg(html`<svg
      viewBox="15 15 140 140"
      style="enable-background:new 0 0 170 170;zoom: 1;"
      xmlns="http://www.w3.org/2000/svg"
    >
      <style type="text/css">
        .bg0 {
          fill: #ff8c00;
        }
        .st0 {
          fill: #ffffff;
        }
      </style>
      <g>
        <circle class="bg0" cx="85" cy="85" r="70"></circle>
        <g>
          <path
            class="st0"
            d="M85,34.7c-20.8,0-37.8,16.9-37.8,37.8c0,4.2,0.7,8.3,2,12.3c0.9,2.7,3.9,4.2,6.7,3.3c2.7-0.9,4.2-3.9,3.3-6.7 c-1.1-3.1-1.6-6.4-1.5-9.7C58.1,57.6,69.5,46,83.6,45.3c15.7-0.8,28.7,11.7,28.7,27.2c0,14.5-11.4,26.4-25.7,27.2 c0,0-5.3,0.3-7.9,0.7c-1.3,0.2-2.3,0.4-3,0.5c-0.3,0.1-0.6-0.2-0.5-0.5l0.9-4.4L81,73.4c0.6-2.8-1.2-5.6-4-6.2 c-2.8-0.6-5.6,1.2-6.2,4c0,0-11.8,55-11.9,55.6c-0.6,2.8,1.2,5.6,4,6.2c2.8,0.6,5.6-1.2,6.2-4c0.1-0.6,1.7-7.9,1.7-7.9 c1.2-5.6,5.8-9.7,11.2-10.4c1.2-0.2,5.9-0.5,5.9-0.5c19.5-1.5,34.9-17.8,34.9-37.7C122.8,51.6,105.8,34.7,85,34.7z M87.7,121.7 c-3.4-0.7-6.8,1.4-7.5,4.9c-0.7,3.4,1.4,6.8,4.9,7.5c3.4,0.7,6.8-1.4,7.5-4.9C93.3,125.7,91.2,122.4,87.7,121.7z"
          ></path>
        </g>
      </g>
    </svg>`),
  downloadUrl: {
    chrome: "https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd",
    firefox: "https://addons.mozilla.org/firefox/addon/polkadot-js-extension",
    default: "https://polkadot.js.org/extension"
  }
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/wallets/subwallet.js
var subWallet = {
  selector: (wallet2) => wallet2.id === "injected/subwallet-js",
  name: "SubWallet",
  platforms: ["chrome", "firefox", "ios", "android"],
  logo: urlFromSvg(html`<svg
      viewBox="0 0 704 704"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <g clip-path="url(#clip0_362_8013)">
        <rect
          width="704"
          height="704"
          rx="48"
          fill="url(#paint0_linear_362_8013)"
        />
        <g clip-path="url(#clip1_362_8013)">
          <path
            d="M512 285.599V218.99L245.286 112L192 139.06L192.281 346.38L391.824 426.727L285.251 472.104V437.013L236.324 417.152L192.281 437.967L192.281 564.94L245.333 592L512 471.688V386.345L272 290.283V232L462.417 308.08L512 285.599Z"
            fill="white"
          />
        </g>
      </g>
      <defs>
        <linearGradient
          id="paint0_linear_362_8013"
          x1="352"
          y1="0"
          x2="352"
          y2="704"
          gradientUnits="userSpaceOnUse"
        >
          <stop stop-color="#004BFF" />
          <stop offset="1" stop-color="#4CEAAC" />
        </linearGradient>
        <clipPath id="clip0_362_8013">
          <rect width="704" height="704" rx="16" fill="white" />
        </clipPath>
        <clipPath id="clip1_362_8013">
          <rect
            width="320"
            height="480"
            fill="white"
            transform="translate(192 112)"
          />
        </clipPath>
      </defs>
    </svg>`),
  downloadUrl: {
    chrome: "https://chrome.google.com/webstore/detail/subwallet-polkadot-extens/onhogfjeacnfoofkfgppdlbmlmnplgbn",
    firefox: "https://addons.mozilla.org/firefox/addon/subwallet",
    default: "https://www.subwallet.app/download.html"
  }
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/wallets/talisman.js
var talisman = {
  selector: (wallet2) => wallet2.id === "injected/talisman",
  name: "Talisman",
  platforms: ["chrome", "firefox"],
  logo: urlFromSvg(html`<svg
      fill="none"
      viewBox="0 0 64 64"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        clip-rule="evenodd"
        d="m50.1161 35.6631c.6081 1.3243 2.3987 1.792 3.4291.7616l1.8897-1.8897c1.9526-1.9526 5.1184-1.9526 7.0711 0 1.9526 1.9526 1.9526 5.1185 0 7.0711l-15.2721 15.272c-3.6687 4.355-9.1626 7.1219-15.3027 7.1219-6.4029 0-12.1031-3.0089-15.7637-7.6899l-14.7031-14.7031c-1.952627-1.9526-1.952627-5.1184 0-7.071 1.95262-1.9526 5.11844-1.9526 7.07106 0l1.86104 1.861c1.0079 1.0079 2.7576.5545 3.353-.7406.1176-.2559.1815-.5305.1815-.8121v-22.8444c0-2.76139 2.2386-4.99996 5-4.99996s5 2.23857 5 4.99996v11.5565c0 .9944 1.0187 1.6694 1.9668 1.3697.6001-.1896 1.0337-.736 1.0337-1.3653v-18.56079c0-2.76142 2.2385-4.99998943 5-4.99999015 2.7614-.00000073 5 2.23857015 5 4.99999015v18.56119c0 .6292.4334 1.1754 1.0333 1.365.9479.2996 1.9663-.3752 1.9663-1.3693v-11.557c0-2.76139 2.2385-4.99996 5-4.99996 2.7614 0 4.9999 2.23857 4.9999 4.99996l.0001 22.8351c0 .2872.0652.5671.185.8281z"
        fill="#fd4848"
        fill-rule="evenodd"
      />
      <path
        d="m47.9319 45.9999s-7.1635 10-16 10c-8.8366 0-16-10-16-10s7.1634-10 16-10c8.8365 0 16 10 16 10z"
        fill="#d5ff5c"
      />
      <g stroke="#fd4848">
        <path
          d="m39.4315 46.0001c0 4.1419-3.3577 7.4996-7.4996 7.4996s-7.4996-3.3577-7.4996-7.4996 3.3577-7.4996 7.4996-7.4996 7.4996 3.3577 7.4996 7.4996z"
          stroke-width="1.00078"
        />
        <path
          d="m36.4312 46.0004c0 2.485-2.0145 4.4996-4.4996 4.4996-2.485 0-4.4996-2.0146-4.4996-4.4996 0-2.4851 2.0146-4.4997 4.4996-4.4997 2.4851 0 4.4996 2.0146 4.4996 4.4997z"
          stroke-width="1.00078"
        />
        <path
          d="m42.4312 46.0001c0 5.7987-4.7008 10.4996-10.4996 10.4996-5.7987 0-10.4996-4.7008-10.4996-10.4996s4.7009-10.4996 10.4996-10.4996c5.7988 0 10.4996 4.7008 10.4996 10.4996z"
          stroke-width="1.00078"
        />
        <path
          d="m45.4312 46c0 7.4557-6.0439 13.4996-13.4996 13.4996-7.4556 0-13.4996-6.0439-13.4996-13.4996 0-7.4556 6.044-13.4996 13.4996-13.4996 7.4557 0 13.4996 6.044 13.4996 13.4996z"
          stroke-width="1.00078"
        />
        <path
          d="m33.4315 45.9999c0 .8282-.6714 1.4996-1.4996 1.4996s-1.4996-.6714-1.4996-1.4996.6714-1.4996 1.4996-1.4996 1.4996.6714 1.4996 1.4996z"
          fill="#162beb"
          stroke-width="1.00078"
        />
      </g>
      <ellipse cx="31.9319" cy="45.9999" fill="#fd4848" rx="2" ry="2" />
      <path
        d="m16.6516 46.122c-.0342-.0439-.0657-.0846-.0944-.1221.0287-.0374.0602-.0781.0944-.122.2086-.2676.5176-.6517.9164-1.1134.798-.9241 1.9524-2.1556 3.3772-3.3858 2.8651-2.4738 6.7496-4.8784 10.9867-4.8784 4.237 0 8.1216 2.4046 10.9867 4.8784 1.4247 1.2302 2.5791 2.4617 3.3772 3.3858.3987.4617.7078.8458.9163 1.1134.0343.0438.0658.0846.0945.122-.0287.0375-.0602.0782-.0945.1221-.2085.2676-.5176.6517-.9163 1.1134-.7981.9241-1.9525 2.1556-3.3772 3.3858-2.8651 2.4738-6.7497 4.8783-10.9867 4.8783-4.2371 0-8.1216-2.4045-10.9867-4.8783-1.4248-1.2302-2.5792-2.4617-3.3772-3.3858-.3988-.4617-.7078-.8458-.9164-1.1134z"
        stroke="#d5ff5c"
        stroke-width="1.00078"
      />
    </svg>`),
  downloadUrl: "https://talisman.xyz/download"
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/wallets/walletconnect.js
var walletConnect = {
  selector: (wallet2) => wallet2.id === "wallet-connect",
  name: "WalletConnect",
  logo: urlFromSvg(html`<svg
      fill="none"
      viewBox="0 0 400 400"
      xmlns="http://www.w3.org/2000/svg"
    >
      <clipPath id="a">
        <path d="m0 0h400v400h-400z" />
      </clipPath>
      <g clip-path="url(#a)">
        <circle cx="200" cy="200" fill="#3396ff" r="199.5" stroke="#66b1ff" />
        <path
          d="m122.519 148.965c42.791-41.729 112.171-41.729 154.962 0l5.15 5.022c2.14 2.086 2.14 5.469 0 7.555l-17.617 17.18c-1.07 1.043-2.804 1.043-3.874 0l-7.087-6.911c-29.853-29.111-78.253-29.111-108.106 0l-7.59 7.401c-1.07 1.043-2.804 1.043-3.874 0l-17.617-17.18c-2.14-2.086-2.14-5.469 0-7.555zm191.397 35.529 15.679 15.29c2.14 2.086 2.14 5.469 0 7.555l-70.7 68.944c-2.139 2.087-5.608 2.087-7.748 0l-50.178-48.931c-.535-.522-1.402-.522-1.937 0l-50.178 48.931c-2.139 2.087-5.608 2.087-7.748 0l-70.7015-68.945c-2.1396-2.086-2.1396-5.469 0-7.555l15.6795-15.29c2.1396-2.086 5.6085-2.086 7.7481 0l50.1789 48.932c.535.522 1.402.522 1.937 0l50.177-48.932c2.139-2.087 5.608-2.087 7.748 0l50.179 48.932c.535.522 1.402.522 1.937 0l50.179-48.931c2.139-2.087 5.608-2.087 7.748 0z"
          fill="#fff"
        />
      </g>
    </svg>`)
};

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/wallets/index.js
var wallets = [
  talisman,
  polkadotJs,
  nova,
  subWallet,
  ledger,
  walletConnect,
  mimir
];

// node_modules/.pnpm/@preact+signals-core@1.8.0/node_modules/@preact/signals-core/dist/signals-core.module.js
var i = Symbol.for("preact-signals");
function t() {
  if (!(s > 1)) {
    var i2, t2 = false;
    while (void 0 !== h) {
      var r = h;
      h = void 0;
      f++;
      while (void 0 !== r) {
        var o2 = r.o;
        r.o = void 0;
        r.f &= -3;
        if (!(8 & r.f) && c(r)) try {
          r.c();
        } catch (r2) {
          if (!t2) {
            i2 = r2;
            t2 = true;
          }
        }
        r = o2;
      }
    }
    f = 0;
    s--;
    if (t2) throw i2;
  } else s--;
}
var o = void 0;
var h = void 0;
var s = 0;
var f = 0;
var v = 0;
function e(i2) {
  if (void 0 !== o) {
    var t2 = i2.n;
    if (void 0 === t2 || t2.t !== o) {
      t2 = { i: 0, S: i2, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t2 };
      if (void 0 !== o.s) o.s.n = t2;
      o.s = t2;
      i2.n = t2;
      if (32 & o.f) i2.S(t2);
      return t2;
    } else if (-1 === t2.i) {
      t2.i = 0;
      if (void 0 !== t2.n) {
        t2.n.p = t2.p;
        if (void 0 !== t2.p) t2.p.n = t2.n;
        t2.p = o.s;
        t2.n = void 0;
        o.s.n = t2;
        o.s = t2;
      }
      return t2;
    }
  }
}
function u(i2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
}
u.prototype.brand = i;
u.prototype.h = function() {
  return true;
};
u.prototype.S = function(i2) {
  if (this.t !== i2 && void 0 === i2.e) {
    i2.x = this.t;
    if (void 0 !== this.t) this.t.e = i2;
    this.t = i2;
  }
};
u.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    var t2 = i2.e, r = i2.x;
    if (void 0 !== t2) {
      t2.x = r;
      i2.e = void 0;
    }
    if (void 0 !== r) {
      r.e = t2;
      i2.x = void 0;
    }
    if (i2 === this.t) this.t = r;
  }
};
u.prototype.subscribe = function(i2) {
  var t2 = this;
  return E(function() {
    var r = t2.value, n = o;
    o = void 0;
    try {
      i2(r);
    } finally {
      o = n;
    }
  });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  var i2 = o;
  o = void 0;
  try {
    return this.value;
  } finally {
    o = i2;
  }
};
Object.defineProperty(u.prototype, "value", { get: function() {
  var i2 = e(this);
  if (void 0 !== i2) i2.i = this.i;
  return this.v;
}, set: function(i2) {
  if (i2 !== this.v) {
    if (f > 100) throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    v++;
    s++;
    try {
      for (var r = this.t; void 0 !== r; r = r.x) r.t.N();
    } finally {
      t();
    }
  }
} });
function d2(i2) {
  return new u(i2);
}
function c(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i) return true;
  return false;
}
function a(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) {
    var r = t2.S.n;
    if (void 0 !== r) t2.r = r;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i2.s = t2;
      break;
    }
  }
}
function l(i2) {
  var t2 = i2.s, r = void 0;
  while (void 0 !== t2) {
    var o2 = t2.p;
    if (-1 === t2.i) {
      t2.S.U(t2);
      if (void 0 !== o2) o2.n = t2.n;
      if (void 0 !== t2.n) t2.n.p = o2;
    } else r = t2;
    t2.S.n = t2.r;
    if (void 0 !== t2.r) t2.r = void 0;
    t2 = o2;
  }
  i2.s = r;
}
function y(i2) {
  u.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = v - 1;
  this.f = 4;
}
(y.prototype = new u()).h = function() {
  this.f &= -3;
  if (1 & this.f) return false;
  if (32 == (36 & this.f)) return true;
  this.f &= -5;
  if (this.g === v) return true;
  this.g = v;
  this.f |= 1;
  if (this.i > 0 && !c(this)) {
    this.f &= -2;
    return true;
  }
  var i2 = o;
  try {
    a(this);
    o = this;
    var t2 = this.x();
    if (16 & this.f || this.v !== t2 || 0 === this.i) {
      this.v = t2;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  o = i2;
  l(this);
  this.f &= -2;
  return true;
};
y.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (var t2 = this.s; void 0 !== t2; t2 = t2.n) t2.S.S(t2);
  }
  u.prototype.S.call(this, i2);
};
y.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    u.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (var t2 = this.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
    }
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var i2 = this.t; void 0 !== i2; i2 = i2.x) i2.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var i2 = e(this);
  this.h();
  if (void 0 !== i2) i2.i = this.i;
  if (16 & this.f) throw this.v;
  return this.v;
} });
function w(i2) {
  return new y(i2);
}
function _(i2) {
  var r = i2.u;
  i2.u = void 0;
  if ("function" == typeof r) {
    s++;
    var n = o;
    o = void 0;
    try {
      r();
    } catch (t2) {
      i2.f &= -2;
      i2.f |= 8;
      g(i2);
      throw t2;
    } finally {
      o = n;
      t();
    }
  }
}
function g(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function p(i2) {
  if (o !== this) throw new Error("Out-of-order effect");
  l(this);
  o = i2;
  this.f &= -2;
  if (8 & this.f) g(this);
  t();
}
function b(i2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
}
b.prototype.c = function() {
  var i2 = this.S();
  try {
    if (8 & this.f) return;
    if (void 0 === this.x) return;
    var t2 = this.x();
    if ("function" == typeof t2) this.u = t2;
  } finally {
    i2();
  }
};
b.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  a(this);
  s++;
  var i2 = o;
  o = this;
  return p.bind(this, i2);
};
b.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = h;
    h = this;
  }
};
b.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f)) g(this);
};
function E(i2) {
  var t2 = new b(i2);
  try {
    t2.c();
  } catch (i3) {
    t2.d();
    throw i3;
  }
  return t2.d.bind(t2);
}

// node_modules/.pnpm/@lit-labs+preact-signals@1.0.3/node_modules/@lit-labs/preact-signals/development/lib/signal-watcher.js
function SignalWatcher(Base) {
  class SignalWatcher2 extends Base {
    performUpdate() {
      var _a16;
      if (this.isUpdatePending === false) {
        return;
      }
      (_a16 = this.__dispose) === null || _a16 === void 0 ? void 0 : _a16.call(this);
      let updateFromLit = true;
      this.__dispose = E(() => {
        if (updateFromLit) {
          updateFromLit = false;
          super.performUpdate();
        } else {
          this.requestUpdate();
        }
      });
    }
    connectedCallback() {
      super.connectedCallback();
      this.requestUpdate();
    }
    disconnectedCallback() {
      var _a16;
      super.disconnectedCallback();
      (_a16 = this.__dispose) === null || _a16 === void 0 ? void 0 : _a16.call(this);
    }
  }
  return SignalWatcher2;
}

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directive.js
var PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
var directive = (c2) => (...values) => ({
  // This property needs to remain unminified.
  ["_$litDirective$"]: c2,
  values
});
var Directive = class {
  constructor(_partInfo) {
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  /** @internal */
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  /** @internal */
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
};

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directive-helpers.js
var { _ChildPart: ChildPart2 } = _$LH;
var ENABLE_SHADYDOM_NOPATCH2 = true;
var _a3, _b2;
var wrap2 = ENABLE_SHADYDOM_NOPATCH2 && ((_a3 = window.ShadyDOM) == null ? void 0 : _a3.inUse) && ((_b2 = window.ShadyDOM) == null ? void 0 : _b2.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
var isSingleExpression = (part) => part.strings === void 0;
var createMarker2 = () => document.createComment("");
var insertPart = (containerPart, refPart, part) => {
  var _a16;
  const container = wrap2(containerPart._$startNode).parentNode;
  const refNode = refPart === void 0 ? containerPart._$endNode : refPart._$startNode;
  if (part === void 0) {
    const startNode = wrap2(container).insertBefore(createMarker2(), refNode);
    const endNode = wrap2(container).insertBefore(createMarker2(), refNode);
    part = new ChildPart2(startNode, endNode, containerPart, containerPart.options);
  } else {
    const endNode = wrap2(part._$endNode).nextSibling;
    const oldParent = part._$parent;
    const parentChanged = oldParent !== containerPart;
    if (parentChanged) {
      (_a16 = part._$reparentDisconnectables) == null ? void 0 : _a16.call(part, containerPart);
      part._$parent = containerPart;
      let newConnectionState;
      if (part._$notifyConnectionChanged !== void 0 && (newConnectionState = containerPart._$isConnected) !== oldParent._$isConnected) {
        part._$notifyConnectionChanged(newConnectionState);
      }
    }
    if (endNode !== refNode || parentChanged) {
      let start = part._$startNode;
      while (start !== endNode) {
        const n = wrap2(start).nextSibling;
        wrap2(container).insertBefore(start, refNode);
        start = n;
      }
    }
  }
  return part;
};
var setChildPartValue = (part, value, directiveParent = part) => {
  part._$setValue(value, directiveParent);
  return part;
};
var RESET_VALUE = {};
var setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;
var getCommittedValue = (part) => part._$committedValue;
var removePart = (part) => {
  var _a16;
  (_a16 = part._$notifyConnectionChanged) == null ? void 0 : _a16.call(part, false, true);
  let start = part._$startNode;
  const end = wrap2(part._$endNode).nextSibling;
  while (start !== end) {
    const n = wrap2(start).nextSibling;
    wrap2(start).remove();
    start = n;
  }
};

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/async-directive.js
var DEV_MODE4 = true;
var notifyChildrenConnectedChanged = (parent, isConnected) => {
  var _a16;
  const children = parent._$disconnectableChildren;
  if (children === void 0) {
    return false;
  }
  for (const obj of children) {
    (_a16 = obj["_$notifyDirectiveConnectionChanged"]) == null ? void 0 : _a16.call(obj, isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};
var removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === void 0) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while ((children == null ? void 0 : children.size) === 0);
};
var addDisconnectableToParent = (obj) => {
  for (let parent; parent = obj._$parent; obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === void 0) {
      parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};
function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== void 0) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}
function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === void 0 || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i2 = fromPartIndex; i2 < value.length; i2++) {
        notifyChildrenConnectedChanged(value[i2], false);
        removeDisconnectableFromParent(value[i2]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}
var installDisconnectAPI = (obj) => {
  if (obj.type == PartType.CHILD) {
    obj._$notifyConnectionChanged ?? (obj._$notifyConnectionChanged = notifyChildPartConnectedChanged);
    obj._$reparentDisconnectables ?? (obj._$reparentDisconnectables = reparentDisconnectables);
  }
};
var AsyncDirective = class extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = void 0;
  }
  /**
   * Initialize the part with internal fields
   * @param part
   * @param parent
   * @param attributeIndex
   */
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  // This property needs to remain unminified.
  /**
   * Called from the core code when a directive is going away from a part (in
   * which case `shouldRemoveFromParent` should be true), and from the
   * `setChildrenConnected` helper function when recursively changing the
   * connection state of a tree (in which case `shouldRemoveFromParent` should
   * be false).
   *
   * @param isConnected
   * @param isClearingDirective - True when the directive itself is being
   *     removed; false when the tree is being disconnected
   * @internal
   */
  ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
    var _a16, _b3;
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        (_a16 = this.reconnected) == null ? void 0 : _a16.call(this);
      } else {
        (_b3 = this.disconnected) == null ? void 0 : _b3.call(this);
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  /**
   * Sets the value of the directive's Part outside the normal `update`/`render`
   * lifecycle of a directive.
   *
   * This method should not be called synchronously from a directive's `update`
   * or `render`.
   *
   * @param directive The directive to update
   * @param value The value to set
   */
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      if (DEV_MODE4 && this.__attributeIndex === void 0) {
        throw new Error(`Expected this.__attributeIndex to be a number`);
      }
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  /**
   * User callbacks for implementing logic to release any resources/subscriptions
   * that may have been retained by this directive. Since directives may also be
   * re-connected, `reconnected` should also be implemented to restore the
   * working state of the directive prior to the next render.
   */
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/.pnpm/@lit-labs+preact-signals@1.0.3/node_modules/@lit-labs/preact-signals/development/lib/watch.js
var WatchDirective = class extends AsyncDirective {
  render(signal) {
    var _a16;
    if (signal !== this.__signal) {
      (_a16 = this.__dispose) === null || _a16 === void 0 ? void 0 : _a16.call(this);
      this.__signal = signal;
      let updateFromLit = true;
      this.__dispose = signal.subscribe((value) => {
        if (updateFromLit === false) {
          this.setValue(value);
        }
      });
      updateFromLit = false;
    }
    return signal.peek();
  }
  disconnected() {
    var _a16;
    (_a16 = this.__dispose) === null || _a16 === void 0 ? void 0 : _a16.call(this);
  }
  reconnected() {
    var _a16;
    this.__dispose = (_a16 = this.__signal) === null || _a16 === void 0 ? void 0 : _a16.subscribe((value) => {
      this.setValue(value);
    });
  }
};
var watch = directive(WatchDirective);

// node_modules/.pnpm/@lit-labs+preact-signals@1.0.3/node_modules/@lit-labs/preact-signals/development/lib/html-tag.js
var withWatch = (coreTag) => (strings, ...values) => {
  return coreTag(strings, ...values.map((v2) => v2 instanceof u ? watch(v2) : v2));
};
var html2 = withWatch(html);
var svg2 = withWatch(svg);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/stores.js
var walletsOrProviders$ = new BehaviorSubject([]);
var wallets$ = walletsOrProviders$.pipe(switchMap(aggregateWallets), tap((wallets3) => initializeWallets(wallets3)));
var connectedWallets$ = getConnectedWallets(wallets$);
var accounts$ = getAccounts(wallets$, genericChainSpec);
var walletConfigs = d2(wallets);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/observable-signal.js
var _observable, _subscription;
var ObservableSignal = class extends u {
  constructor(host, observable, initialValue) {
    super();
    __privateAdd(this, _observable);
    __privateAdd(this, _subscription);
    __privateSet(this, _observable, observable);
    this.value = initialValue;
    host.addController(this);
  }
  hostConnected() {
    __privateGet(this, _subscription) ?? __privateSet(this, _subscription, __privateGet(this, _observable).subscribe({
      next: (value) => this.value = value
    }));
  }
  hostDisconnected() {
    var _a16;
    (_a16 = __privateGet(this, _subscription)) == null ? void 0 : _a16.unsubscribe();
    __privateSet(this, _subscription, void 0);
  }
};
_observable = new WeakMap();
_subscription = new WeakMap();
var observableSignal = (host, observable, initialValue) => new ObservableSignal(host, observable, initialValue);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/components/element.js
var _DotConnectElement = class _DotConnectElement extends SignalWatcher(LitElement) {
};
_DotConnectElement.styles = css`
    * {
      --headline-font-family: var(
        --dc-headline-font-family,
        Unbounded,
        sans-serif
      );
      --body-font-family: var(--dc-body-font-family, Inter, sans-serif);

      --primary-color: var(--dc-primary-color, #ff2670);
      --on-primary-color: var(--dc-on-primary-color, #ffffff);

      --surface-color: var(--dc-surface-color, light-dark(#ffffff, #1e1e1e));
      --on-surface-color: var(
        --dc-on-surface-color,
        light-dark(#000000, #ffffff)
      );

      --surface-container-color: color-mix(
        in srgb,
        var(--on-surface-color),
        transparent 95%
      );

      --info-color: var(--dc-info-color, light-dark(#007aff, #0a84ff));
      --success-color: var(--dc-success-color, light-dark(#34c759, #30d158));
      --error-color: var(--dc-error-color, light-dark(#ff3b30, #ff453a));

      --max-border-radius: var(--dc-max-border-radius, 999px);
    }

    :host {
      all: initial;
      color-scheme: inherit;
      font-family: var(--body-font-family);
      color: var(--on-surface-color);
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      font-family: var(--headline-font-family);
      margin: 0;
    }

    button {
      color: var(--on-primary-color);
      font-weight: 600;
      border: none;
      border-radius: min(999px, var(--max-border-radius));
      background-color: var(--primary-color);
      padding: 0.8em 1.25rem;
      cursor: pointer;
      transition: scale 0.25s;

      &.sm,
      &.xs {
        padding: 0.6em 1.25em;
      }

      &.sm {
        font-size: 0.6rem;
      }

      &.xs {
        font-size: 0.5rem;
      }

      &.text {
        color: var(--primary-color);
        padding-inline-start: 0;
        padding-inline-end: 0;
      }

      &.info {
        color: var(--info-color);
      }

      &.success {
        color: var(--success-color);
      }

      &.error {
        color: var(--error-color);
      }

      &.info,
      &.success,
      &.error {
        background-color: var(--surface-container-color);
      }

      &.text,
      &.icon {
        background-color: transparent;
      }

      &:hover {
        scale: 1.04;
      }

      &:active {
        scale: 1;
        filter: brightness(1.125);
      }
    }

    ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }
  `;
var DotConnectElement = _DotConnectElement;

// node_modules/.pnpm/@lit+reactive-element@2.1.0/node_modules/@lit/reactive-element/development/decorators/custom-element.js
var customElement = (tagName) => (classOrTarget, context) => {
  if (context !== void 0) {
    context.addInitializer(() => {
      customElements.define(tagName, classOrTarget);
    });
  } else {
    customElements.define(tagName, classOrTarget);
  }
};

// node_modules/.pnpm/@lit+reactive-element@2.1.0/node_modules/@lit/reactive-element/development/decorators/property.js
var DEV_MODE5 = true;
var issueWarning4;
if (DEV_MODE5) {
  globalThis.litIssuedWarnings ?? (globalThis.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning4 = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!globalThis.litIssuedWarnings.has(warning) && !globalThis.litIssuedWarnings.has(code)) {
      console.warn(warning);
      globalThis.litIssuedWarnings.add(warning);
    }
  };
}
var legacyProperty = (options, proto, name) => {
  const hasOwnProperty = proto.hasOwnProperty(name);
  proto.constructor.createProperty(name, options);
  return hasOwnProperty ? Object.getOwnPropertyDescriptor(proto, name) : void 0;
};
var defaultPropertyDeclaration2 = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
var standardProperty = (options = defaultPropertyDeclaration2, target, context) => {
  const { kind, metadata } = context;
  if (DEV_MODE5 && metadata == null) {
    issueWarning4("missing-class-metadata", `The class ${target} is missing decorator metadata. This could mean that you're using a compiler that supports decorators but doesn't support decorator metadata, such as TypeScript 5.1. Please update your compiler.`);
  }
  let properties = globalThis.litPropertyMetadata.get(metadata);
  if (properties === void 0) {
    globalThis.litPropertyMetadata.set(metadata, properties = /* @__PURE__ */ new Map());
  }
  if (kind === "setter") {
    options = Object.create(options);
    options.wrapped = true;
  }
  properties.set(context.name, options);
  if (kind === "accessor") {
    const { name } = context;
    return {
      set(v2) {
        const oldValue = target.get.call(this);
        target.set.call(this, v2);
        this.requestUpdate(name, oldValue, options);
      },
      init(v2) {
        if (v2 !== void 0) {
          this._$changeProperty(name, void 0, options, v2);
        }
        return v2;
      }
    };
  } else if (kind === "setter") {
    const { name } = context;
    return function(value) {
      const oldValue = this[name];
      target.call(this, value);
      this.requestUpdate(name, oldValue, options);
    };
  }
  throw new Error(`Unsupported decorator location: ${kind}`);
};
function property(options) {
  return (protoOrTarget, nameOrContext) => {
    return typeof nameOrContext === "object" ? standardProperty(options, protoOrTarget, nameOrContext) : legacyProperty(options, protoOrTarget, nameOrContext);
  };
}

// node_modules/.pnpm/@lit+reactive-element@2.1.0/node_modules/@lit/reactive-element/development/decorators/state.js
function state(options) {
  return property({
    ...options,
    // Add both `state` and `attribute` because we found a third party
    // controller that is keying off of PropertyOptions.state to determine
    // whether a field is a private internal property or not.
    state: true,
    attribute: false
  });
}

// node_modules/.pnpm/@lit+reactive-element@2.1.0/node_modules/@lit/reactive-element/development/decorators/query.js
var DEV_MODE6 = true;
var issueWarning5;
if (DEV_MODE6) {
  globalThis.litIssuedWarnings ?? (globalThis.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning5 = (code, warning) => {
    warning += code ? ` See https://lit.dev/msg/${code} for more information.` : "";
    if (!globalThis.litIssuedWarnings.has(warning) && !globalThis.litIssuedWarnings.has(code)) {
      console.warn(warning);
      globalThis.litIssuedWarnings.add(warning);
    }
  };
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/components/circular-progress-indicator.js
var __decorate = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a4;
var CircularProgressIndicator = (_a4 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    this.size = "24";
  }
  render() {
    return html`
      <svg width=${this.size} height=${this.size} viewBox="0 0 24 24">
        <style>
          .spinner_GuJz {
            transform-origin: center;
            animation: spinner_STY6 1.5s linear infinite;
          }
          @keyframes spinner_STY6 {
            100% {
              transform: rotate(360deg);
            }
          }
        </style>
        <g class="spinner_GuJz">
          <circle cx="3" cy="12" r="2" />
          <circle cx="21" cy="12" r="2" />
          <circle cx="12" cy="21" r="2" />
          <circle cx="12" cy="3" r="2" />
          <circle cx="5.64" cy="5.64" r="2" />
          <circle cx="18.36" cy="18.36" r="2" />
          <circle cx="5.64" cy="18.36" r="2" />
          <circle cx="18.36" cy="5.64" r="2" />
        </g>
      </svg>
    `;
  }
}, _a4.styles = [
  __superGet(_a4, _a4, "styles"),
  css`
      svg {
        fill: var(--primary-color);
      }
    `
], _a4);
__decorate([
  property()
], CircularProgressIndicator.prototype, "size", void 0);
CircularProgressIndicator = __decorate([
  customElement("dc-circular-progress-indicator")
], CircularProgressIndicator);

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directives/class-map.js
var ClassMapDirective = class extends Directive {
  constructor(partInfo) {
    var _a16;
    super(partInfo);
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "class" || ((_a16 = partInfo.strings) == null ? void 0 : _a16.length) > 2) {
      throw new Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
  }
  render(classInfo) {
    return " " + Object.keys(classInfo).filter((key) => classInfo[key]).join(" ") + " ";
  }
  update(part, [classInfo]) {
    var _a16, _b3;
    if (this._previousClasses === void 0) {
      this._previousClasses = /* @__PURE__ */ new Set();
      if (part.strings !== void 0) {
        this._staticClasses = new Set(part.strings.join(" ").split(/\s/).filter((s2) => s2 !== ""));
      }
      for (const name in classInfo) {
        if (classInfo[name] && !((_a16 = this._staticClasses) == null ? void 0 : _a16.has(name))) {
          this._previousClasses.add(name);
        }
      }
      return this.render(classInfo);
    }
    const classList = part.element.classList;
    for (const name of this._previousClasses) {
      if (!(name in classInfo)) {
        classList.remove(name);
        this._previousClasses.delete(name);
      }
    }
    for (const name in classInfo) {
      const value = !!classInfo[name];
      if (value !== this._previousClasses.has(name) && !((_b3 = this._staticClasses) == null ? void 0 : _b3.has(name))) {
        if (value) {
          classList.add(name);
          this._previousClasses.add(name);
        } else {
          classList.remove(name);
          this._previousClasses.delete(name);
        }
      }
    }
    return noChange;
  }
};
var classMap = directive(ClassMapDirective);

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directives/if-defined.js
var ifDefined = (value) => value ?? nothing;

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directives/ref.js
var createRef = () => new Ref();
var Ref = class {
};
var lastElementForContextAndCallback = /* @__PURE__ */ new WeakMap();
var RefDirective = class extends AsyncDirective {
  render(_ref) {
    return nothing;
  }
  update(part, [ref2]) {
    var _a16;
    const refChanged = ref2 !== this._ref;
    if (refChanged && this._ref !== void 0) {
      this._updateRefValue(void 0);
    }
    if (refChanged || this._lastElementForRef !== this._element) {
      this._ref = ref2;
      this._context = (_a16 = part.options) == null ? void 0 : _a16.host;
      this._updateRefValue(this._element = part.element);
    }
    return nothing;
  }
  _updateRefValue(element) {
    if (!this.isConnected) {
      element = void 0;
    }
    if (typeof this._ref === "function") {
      const context = this._context ?? globalThis;
      let lastElementForCallback = lastElementForContextAndCallback.get(context);
      if (lastElementForCallback === void 0) {
        lastElementForCallback = /* @__PURE__ */ new WeakMap();
        lastElementForContextAndCallback.set(context, lastElementForCallback);
      }
      if (lastElementForCallback.get(this._ref) !== void 0) {
        this._ref.call(this._context, void 0);
      }
      lastElementForCallback.set(this._ref, element);
      if (element !== void 0) {
        this._ref.call(this._context, element);
      }
    } else {
      this._ref.value = element;
    }
  }
  get _lastElementForRef() {
    var _a16, _b3;
    return typeof this._ref === "function" ? (_a16 = lastElementForContextAndCallback.get(this._context ?? globalThis)) == null ? void 0 : _a16.get(this._ref) : (_b3 = this._ref) == null ? void 0 : _b3.value;
  }
  disconnected() {
    if (this._lastElementForRef === this._element) {
      this._updateRefValue(void 0);
    }
  }
  reconnected() {
    this._updateRefValue(this._element);
  }
};
var ref = directive(RefDirective);

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directives/style-map.js
var important = "important";
var importantFlag = " !" + important;
var flagTrim = 0 - importantFlag.length;
var StyleMapDirective = class extends Directive {
  constructor(partInfo) {
    var _a16;
    super(partInfo);
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "style" || ((_a16 = partInfo.strings) == null ? void 0 : _a16.length) > 2) {
      throw new Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
    }
  }
  render(styleInfo) {
    return Object.keys(styleInfo).reduce((style, prop) => {
      const value = styleInfo[prop];
      if (value == null) {
        return style;
      }
      prop = prop.includes("-") ? prop : prop.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase();
      return style + `${prop}:${value};`;
    }, "");
  }
  update(part, [styleInfo]) {
    const { style } = part.element;
    if (this._previousStyleProperties === void 0) {
      this._previousStyleProperties = new Set(Object.keys(styleInfo));
      return this.render(styleInfo);
    }
    for (const name of this._previousStyleProperties) {
      if (styleInfo[name] == null) {
        this._previousStyleProperties.delete(name);
        if (name.includes("-")) {
          style.removeProperty(name);
        } else {
          style[name] = null;
        }
      }
    }
    for (const name in styleInfo) {
      const value = styleInfo[name];
      if (value != null) {
        this._previousStyleProperties.add(name);
        const isImportant = typeof value === "string" && value.endsWith(importantFlag);
        if (name.includes("-") || isImportant) {
          style.setProperty(name, isImportant ? value.slice(0, flagTrim) : value, isImportant ? important : "");
        } else {
          style[name] = value;
        }
      }
    }
    return noChange;
  }
};
var styleMap = directive(StyleMapDirective);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/components/list-item.js
var __decorate2 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var composedEvent = Symbol("composedEvent");
var _checkboxRef, _a5;
var ListItem = (_a5 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _checkboxRef);
    this.clickable = false;
    this.pending = false;
    this.checked = false;
    __privateSet(this, _checkboxRef, createRef());
  }
  render() {
    return html`<li
      class=${classMap({ clickable: this.clickable })}
      role=${ifDefined(this.clickable ? "button" : void 0)}
      @click=${() => {
      var _a16;
      if (this.type === "checkbox") {
        (_a16 = __privateGet(this, _checkboxRef).value) == null ? void 0 : _a16.click();
      }
    }}
    >
      <div id="leading"><slot name="leading"></slot></div>
      <div id="middle">
        <header id="headline"><slot name="headline"></slot></header>
        <div id="supporting"><slot name="supporting"></slot></div>
      </div>
      <div
        id="trailing"
        style=${styleMap({ opacity: this.pending ? 1 : void 0 })}
      >
        ${(() => {
      if (this.pending) {
        return html`<dc-circular-progress-indicator
              size="1.25rem"
            ></dc-circular-progress-indicator>`;
      }
      switch (this.type) {
        case "checkbox":
          return html`<input
                ${ref(__privateGet(this, _checkboxRef))}
                id="checkbox"
                type="checkbox"
                ?checked=${this.checked}
                @change=${(event) => {
            var _a16;
            if (!(composedEvent in event)) {
              (_a16 = __privateGet(this, _checkboxRef).value) == null ? void 0 : _a16.dispatchEvent(Object.assign(new Event(event.type, { ...event, composed: true }), { [composedEvent]: true }));
            }
          }}
              />`;
        default:
          return html`<slot name="trailing"></slot>`;
      }
    })()}
      </div>
    </li>`;
  }
}, _checkboxRef = new WeakMap(), _a5.styles = [
  __superGet(_a5, _a5, "styles"),
  css`
      li {
        display: flex;
        align-items: center;

        border-radius: min(1rem, var(--max-border-radius));
        padding: 0.5rem;

        transition: backdrop-filter 0.125s;

        &.clickable {
          cursor: pointer;

          &:hover {
            backdrop-filter: invert(8%);

            @starting-style {
              backdrop-filter: invert(0);
            }
          }
        }
      }

      #leading {
        grid-area: leading;

        ::slotted(*) {
          margin-inline-end: 0.75rem;
        }

        ::slotted(.icon) {
          width: 2rem;
          height: 2rem;
        }
      }

      #middle {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      #headline {
        grid-area: headline;
        font-weight: 500;
      }

      #supporting {
        grid-area: supporting;
        font-size: 0.75em;
        color: color-mix(in srgb, currentcolor, transparent 15%);
      }

      #trailing {
        grid-area: trailing;
        transition: opacity 0.125s;

        ::slotted(*) {
          margin-inline-start: 0.75rem;
        }

        ::slotted(.revealable) {
          opacity: 0;
        }

        ::slotted(:is(.icon, input[type="checkbox"])) {
          width: 1.2rem;
          height: 1.2rem;
        }
      }

      li:hover #trailing ::slotted(.revealable) {
        opacity: 1;

        @starting-style {
          opacity: 0;
        }
      }

      #checkbox {
        pointer-events: none;
      }
    `
], _a5);
__decorate2([
  property({ type: Boolean })
], ListItem.prototype, "clickable", void 0);
__decorate2([
  property({ type: Boolean })
], ListItem.prototype, "pending", void 0);
__decorate2([
  property()
], ListItem.prototype, "type", void 0);
__decorate2([
  property({ type: Boolean })
], ListItem.prototype, "checked", void 0);
ListItem = __decorate2([
  customElement("dc-list-item")
], ListItem);

// node_modules/.pnpm/dot-identicon@0.1.1_@types+react@19.1.6_react@19.1.0/node_modules/dot-identicon/build/icon.js
function generatePolkadotIcon(address, { backgroundColor = "transparent" } = {}) {
  const xy = getCircleXY();
  let colors;
  try {
    colors = getColors(address);
  } catch {
    colors = new Array(xy.length).fill("#ddd");
  }
  return [
    {
      cx: C,
      cy: C,
      fill: backgroundColor,
      r: C
    }
  ].concat(xy.map(([cx, cy], index) => ({
    cx,
    cy,
    fill: colors[index],
    r: Z
  })));
}
var S = 64;
var C = S / 2;
var Z = S / 64 * 5;
var SCHEMES = [
  /* target  */
  {
    colors: [0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 1],
    freq: 1
  },
  /* cube    */
  {
    colors: [0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 5],
    freq: 20
  },
  /* quazar  */
  {
    colors: [1, 2, 3, 1, 2, 4, 5, 5, 4, 1, 2, 3, 1, 2, 4, 5, 5, 4, 0],
    freq: 16
  },
  /* flower  */
  {
    colors: [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 3],
    freq: 32
  },
  /* cyclic  */
  {
    colors: [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6],
    freq: 32
  },
  /* vmirror */
  {
    colors: [0, 1, 2, 3, 4, 5, 3, 4, 2, 0, 1, 6, 7, 8, 9, 7, 8, 6, 10],
    freq: 128
  },
  /* hmirror */
  {
    colors: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 8, 6, 7, 5, 3, 4, 2, 11],
    freq: 128
  }
];
var SCHEMES_TOTAL = SCHEMES.map((s2) => s2.freq).reduce((a2, b2) => a2 + b2);
function blake2AsU8a(data, bitLength = 256, key) {
  const byteLength = Math.ceil(bitLength / 8);
  const u8a = data;
  return key ? blake2b(u8a, { dkLen: byteLength, key }) : blake2b(u8a, { dkLen: byteLength });
}
function getRotation() {
  const r = C / 4 * 3;
  const rroot3o2 = r * Math.sqrt(3) / 2;
  const ro2 = r / 2;
  const rroot3o4 = r * Math.sqrt(3) / 4;
  const ro4 = r / 4;
  const r3o4 = r * 3 / 4;
  return { r, r3o4, ro2, ro4, rroot3o2, rroot3o4 };
}
function getCircleXY() {
  const { r, r3o4, ro2, ro4, rroot3o2, rroot3o4 } = getRotation();
  return [
    [C, C - r],
    [C, C - ro2],
    [C - rroot3o4, C - r3o4],
    [C - rroot3o2, C - ro2],
    [C - rroot3o4, C - ro4],
    [C - rroot3o2, C],
    [C - rroot3o2, C + ro2],
    [C - rroot3o4, C + ro4],
    [C - rroot3o4, C + r3o4],
    [C, C + r],
    [C, C + ro2],
    [C + rroot3o4, C + r3o4],
    [C + rroot3o2, C + ro2],
    [C + rroot3o4, C + ro4],
    [C + rroot3o2, C],
    [C + rroot3o2, C - ro2],
    [C + rroot3o4, C - ro4],
    [C + rroot3o4, C - r3o4],
    [C, C]
  ];
}
function findScheme(d3) {
  let cum = 0;
  const schema = SCHEMES.find((schema2) => {
    cum += schema2.freq;
    return d3 < cum;
  });
  if (!schema) {
    throw new Error("Unable to find schema");
  }
  return schema;
}
var zeroHash = new Uint8Array();
function addressToId(address) {
  if (!zeroHash.length) {
    zeroHash = blake2AsU8a(new Uint8Array(32), 512);
  }
  return blake2AsU8a(AccountId().enc(address), 512).map((x, i2) => (x + 256 - zeroHash[i2]) % 256);
}
function getColors(address) {
  const id = addressToId(address);
  const d3 = Math.floor((id[30] + id[31] * 256) % SCHEMES_TOTAL);
  const rot = id[28] % 6 * 3;
  const sat = Math.floor(id[29] * 70 / 256 + 26) % 80 + 30;
  const scheme = findScheme(d3);
  const palette = Array.from(id).map((x, i2) => {
    const b2 = (x + i2 % 28 * 58) % 256;
    if (b2 === 0) {
      return "#444";
    } else if (b2 === 255) {
      return "transparent";
    }
    const h2 = Math.floor(b2 % 64 * 360 / 64);
    const l2 = [53, 15, 35, 75][Math.floor(b2 / 64)];
    return `hsl(${h2}, ${sat}%, ${l2}%)`;
  });
  return scheme.colors.map((_2, i2) => palette[scheme.colors[i2 < 18 ? (i2 + rot) % 18 : 18]]);
}

// node_modules/.pnpm/dot-identicon@0.1.1_@types+react@19.1.6_react@19.1.0/node_modules/dot-identicon/build/polkadot-identicon.js
var __decorate3 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a6;
var PolkadotIdenticon = (_a6 = class extends LitElement {
  constructor() {
    super(...arguments);
    this.size = 24;
    this.backgroundColor = "transparent";
  }
  render() {
    const circles = generatePolkadotIcon(this.address, {
      backgroundColor: this.backgroundColor
    });
    return html`<svg
      name=${this.address}
      width=${this.size}
      height=${this.size}
      viewBox="0 0 64 64"
    >
      ${circles.map(({ cx, cy, r, fill }) => svg`<circle cx=${cx} cy=${cy} r=${r} fill=${fill} />`)}
    </svg>`;
  }
}, _a6.styles = css`
    button {
      cursor: copy;
    }
  `, _a6);
__decorate3([
  property()
], PolkadotIdenticon.prototype, "address", void 0);
__decorate3([
  property()
], PolkadotIdenticon.prototype, "size", void 0);
__decorate3([
  property()
], PolkadotIdenticon.prototype, "backgroundColor", void 0);
PolkadotIdenticon = __decorate3([
  customElement("polkadot-identicon")
], PolkadotIdenticon);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/components/account-list-item.js
var __decorate4 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var AccountListItem = class AccountListItem2 extends DotConnectElement {
  constructor() {
    super(...arguments);
    this.clickable = false;
    this.pending = false;
    this.checked = false;
  }
  get shortenedAddress() {
    return this.address.slice(0, 6) + "..." + this.address.slice(-6);
  }
  render() {
    return html`<dc-list-item
      ?clickable=${this.clickable}
      ?pending=${this.pending}
      type=${ifDefined(this.type)}
      ?checked=${this.checked}
    >
      <div class="icon" slot="leading">
        <polkadot-identicon
          address=${this.address}
          size="100%"
          backgroundColor="var(--surface-container-color)"
        ></polkadot-identicon>
      </div>
      <span slot="headline">${this.name ?? this.shortenedAddress}</span>
      ${this.name === void 0 ? nothing : html`<span slot="supporting">${this.shortenedAddress}</span>`}
      <slot name="trailing" slot="trailing"></slot>
    </dc-list-item>`;
  }
};
__decorate4([
  property()
], AccountListItem.prototype, "address", void 0);
__decorate4([
  property()
], AccountListItem.prototype, "name", void 0);
__decorate4([
  property({ type: Boolean })
], AccountListItem.prototype, "clickable", void 0);
__decorate4([
  property({ type: Boolean })
], AccountListItem.prototype, "pending", void 0);
__decorate4([
  property()
], AccountListItem.prototype, "type", void 0);
__decorate4([
  property({ type: Boolean })
], AccountListItem.prototype, "checked", void 0);
AccountListItem = __decorate4([
  customElement("dc-account-list-item")
], AccountListItem);

// node_modules/.pnpm/@lit+task@1.0.2/node_modules/@lit/task/development/task.js
var TaskStatus = {
  INITIAL: 0,
  PENDING: 1,
  COMPLETE: 2,
  ERROR: 3
};
var initialState = Symbol();
var Task = class {
  /**
   * A Promise that resolve when the current task run is complete.
   *
   * If a new task run is started while a previous run is pending, the Promise
   * is kept and only resolved when the new run is completed.
   */
  get taskComplete() {
    if (this._taskComplete) {
      return this._taskComplete;
    }
    if (this._status === TaskStatus.PENDING) {
      this._taskComplete = new Promise((res, rej) => {
        this._resolveTaskComplete = res;
        this._rejectTaskComplete = rej;
      });
    } else if (this._status === TaskStatus.ERROR) {
      this._taskComplete = Promise.reject(this._error);
    } else {
      this._taskComplete = Promise.resolve(this._value);
    }
    return this._taskComplete;
  }
  constructor(host, task, args) {
    var _a16;
    this._callId = 0;
    this._status = TaskStatus.INITIAL;
    (this._host = host).addController(this);
    const taskConfig = typeof task === "object" ? task : { task, args };
    this._task = taskConfig.task;
    this._argsFn = taskConfig.args;
    this._argsEqual = taskConfig.argsEqual ?? shallowArrayEquals;
    this._onComplete = taskConfig.onComplete;
    this._onError = taskConfig.onError;
    this.autoRun = taskConfig.autoRun ?? true;
    if ("initialValue" in taskConfig) {
      this._value = taskConfig.initialValue;
      this._status = TaskStatus.COMPLETE;
      this._previousArgs = (_a16 = this._getArgs) == null ? void 0 : _a16.call(this);
    }
  }
  hostUpdate() {
    if (this.autoRun === true) {
      this._performTask();
    }
  }
  hostUpdated() {
    if (this.autoRun === "afterUpdate") {
      this._performTask();
    }
  }
  _getArgs() {
    if (this._argsFn === void 0) {
      return void 0;
    }
    const args = this._argsFn();
    if (!Array.isArray(args)) {
      throw new Error("The args function must return an array");
    }
    return args;
  }
  /**
   * Determines if the task should run when it's triggered because of a
   * host update, and runs the task if it should.
   *
   * A task should run when its arguments change from the previous run, based on
   * the args equality function.
   *
   * This method is side-effectful: it stores the new args as the previous args.
   */
  async _performTask() {
    const args = this._getArgs();
    const prev = this._previousArgs;
    this._previousArgs = args;
    if (args !== prev && args !== void 0 && (prev === void 0 || !this._argsEqual(prev, args))) {
      await this.run(args);
    }
  }
  /**
   * Runs a task manually.
   *
   * This can be useful for running tasks in response to events as opposed to
   * automatically running when host element state changes.
   *
   * @param args an optional set of arguments to use for this task run. If args
   *     is not given, the args function is called to get the arguments for
   *     this run.
   */
  async run(args) {
    var _a16, _b3, _c, _d, _e;
    args ?? (args = this._getArgs());
    this._previousArgs = args;
    if (this._status === TaskStatus.PENDING) {
      (_a16 = this._abortController) == null ? void 0 : _a16.abort();
    } else {
      this._taskComplete = void 0;
      this._resolveTaskComplete = void 0;
      this._rejectTaskComplete = void 0;
    }
    this._status = TaskStatus.PENDING;
    let result;
    let error;
    if (this.autoRun === "afterUpdate") {
      queueMicrotask(() => this._host.requestUpdate());
    } else {
      this._host.requestUpdate();
    }
    const key = ++this._callId;
    this._abortController = new AbortController();
    let errored = false;
    try {
      result = await this._task(args, { signal: this._abortController.signal });
    } catch (e2) {
      errored = true;
      error = e2;
    }
    if (this._callId === key) {
      if (result === initialState) {
        this._status = TaskStatus.INITIAL;
      } else {
        if (errored === false) {
          try {
            (_b3 = this._onComplete) == null ? void 0 : _b3.call(this, result);
          } catch {
          }
          this._status = TaskStatus.COMPLETE;
          (_c = this._resolveTaskComplete) == null ? void 0 : _c.call(this, result);
        } else {
          try {
            (_d = this._onError) == null ? void 0 : _d.call(this, error);
          } catch {
          }
          this._status = TaskStatus.ERROR;
          (_e = this._rejectTaskComplete) == null ? void 0 : _e.call(this, error);
        }
        this._value = result;
        this._error = error;
      }
      this._host.requestUpdate();
    }
  }
  /**
   * Aborts the currently pending task run by aborting the AbortSignal
   * passed to the task function.
   *
   * Aborting a task does nothing if the task is not running: ie, in the
   * complete, error, or initial states.
   *
   * Aborting a task does not automatically cancel the task function. The task
   * function must be written to accept the AbortSignal and either forward it
   * to other APIs like `fetch()`, or handle cancellation manually by using
   * [`signal.throwIfAborted()`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted}
   * or the
   * [`abort`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/abort_event}
   * event.
   *
   * @param reason The reason for aborting. Passed to
   *     `AbortController.abort()`.
   */
  abort(reason) {
    var _a16;
    if (this._status === TaskStatus.PENDING) {
      (_a16 = this._abortController) == null ? void 0 : _a16.abort(reason);
    }
  }
  /**
   * The result of the previous task run, if it resolved.
   *
   * Is `undefined` if the task has not run yet, or if the previous run errored.
   */
  get value() {
    return this._value;
  }
  /**
   * The error from the previous task run, if it rejected.
   *
   * Is `undefined` if the task has not run yet, or if the previous run
   * completed successfully.
   */
  get error() {
    return this._error;
  }
  get status() {
    return this._status;
  }
  render(renderer) {
    var _a16, _b3, _c, _d;
    switch (this._status) {
      case TaskStatus.INITIAL:
        return (_a16 = renderer.initial) == null ? void 0 : _a16.call(renderer);
      case TaskStatus.PENDING:
        return (_b3 = renderer.pending) == null ? void 0 : _b3.call(renderer);
      case TaskStatus.COMPLETE:
        return (_c = renderer.complete) == null ? void 0 : _c.call(renderer, this.value);
      case TaskStatus.ERROR:
        return (_d = renderer.error) == null ? void 0 : _d.call(renderer, this.error);
      default:
        throw new Error(`Unexpected status: ${this._status}`);
    }
  }
};
var shallowArrayEquals = (oldArgs, newArgs) => oldArgs === newArgs || oldArgs.length === newArgs.length && oldArgs.every((v2, i2) => !notEqual(v2, newArgs[i2]));

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/ledger/connected-ledger-account-list-item.js
var __decorate5 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var genericAccountId = AccountId();
var _accountTask, _a7;
var ConnectedLedgerAccountListItem = (_a7 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _accountTask);
    this.connectedAccounts = observableSignal(this, of([]), []);
    __privateSet(this, _accountTask, new Task(this, {
      task: async ([wallet2, path]) => wallet2 === void 0 ? Promise.withResolvers().promise : wallet2.getConnectedAccount(path).catch(logAndThrow),
      args: () => [this.wallet, this.accountPath]
    }));
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("open")) {
      __privateGet(this, _accountTask).run();
    }
  }
  updated(changedProperties) {
    if (changedProperties.has("wallet")) {
      this.connectedAccounts = observableSignal(this, getAccounts([this.wallet], genericChainSpec), []);
    }
  }
  render() {
    return __privateGet(this, _accountTask).render({
      pending: () => html`<div id="loading-container">
          <dc-list-item pending>
            <span slot="headline">Fetching account...</span>
          </dc-list-item>
        </div>`,
      complete: (account) => {
        const name = `Ledger account ${this.accountPath + 1}`;
        const connected2 = this.connectedAccounts.value.some((connectedAccount) => connectedAccount.id === account.id);
        return html`<dc-account-list-item
          .address=${genericAccountId.dec(account.publicKey)}
          name=${name}
          type="checkbox"
          clickable
          ?checked=${connected2}
          @change=${() => {
          if (connected2) {
            this.wallet.accountStore.delete(account);
          } else {
            this.wallet.accountStore.add({ ...account, name });
          }
        }}
        ></dc-account-list-item>`;
      },
      error: () => html`<dc-list-item>
          <span slot="headline">Failed to load account</span>
          <button
            slot="trailing"
            class="xs"
            @click=${() => __privateGet(this, _accountTask).run()}
          >
            Retry
          </button>
        </dc-list-item>`
    });
  }
}, _accountTask = new WeakMap(), _a7.styles = [
  __superGet(_a7, _a7, "styles"),
  css`
      input[type="checkbox"] {
        pointer-events: none;
      }

      #loading-container {
        min-height: 3.125rem;
      }
    `
], _a7);
__decorate5([
  property({ attribute: false })
], ConnectedLedgerAccountListItem.prototype, "wallet", void 0);
__decorate5([
  property({ type: Number })
], ConnectedLedgerAccountListItem.prototype, "accountPath", void 0);
__decorate5([
  state()
], ConnectedLedgerAccountListItem.prototype, "connectedAccounts", void 0);
ConnectedLedgerAccountListItem = __decorate5([
  customElement("dc-connected-ledger-account-list-item")
], ConnectedLedgerAccountListItem);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/ledger/connected-ledger-accounts-dialog.js
var __decorate6 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ConnectedLedgerAccountsDialog_1;
var _connectLedgerTask, _a8;
var ConnectedLedgerAccountsDialog = (_a8 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _connectLedgerTask);
    this.open = false;
    this.accountCount = ConnectedLedgerAccountsDialog_1.accountIncrement;
    __privateSet(this, _connectLedgerTask, new Task(this, {
      task: ([wallet2]) => wallet2 === void 0 ? Promise.withResolvers().promise : wallet2.getConnectedAccount().catch(logAndThrow),
      args: () => [this.wallet],
      autoRun: false
    }));
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("wallet")) {
      __privateGet(this, _connectLedgerTask).run();
    }
    if (changedProperties.has("open")) {
      if (this.open) {
        __privateGet(this, _connectLedgerTask).run();
        this.accountCount = ConnectedLedgerAccountsDialog_1.accountIncrement;
      }
    }
  }
  render() {
    return html`
      <dc-dialog
        ?open=${this.open}
        @close=${(event) => this.dispatchEvent(new Event(event.type, event))}
      >
        <span slot="title">Connectable accounts</span>
        <div slot="content">
          ${__privateGet(this, _connectLedgerTask).render({
      pending: () => html`<p>Connect your Ledger device to continue.</p>`,
      complete: () => html`
              ${Array.from({ length: this.accountCount }).map((_2, index) => html`<dc-connected-ledger-account-list-item
                    .wallet=${this.wallet}
                    accountPath=${index}
                  ></dc-connected-ledger-account-list-item>`)}
              <button
                id="load-more-button"
                @click=${() => this.accountCount += ConnectedLedgerAccountsDialog_1.accountIncrement}
              >
                Load more accounts
              </button>
            `,
      error: () => html`<p>Failed to connect Ledger device.</p>
                <button
                  id="retry-button"
                  @click=${() => __privateGet(this, _connectLedgerTask).run()}
                >
                  Try again
                </button>`
    })}
        </div>
      </dc-dialog>
    `;
  }
}, _connectLedgerTask = new WeakMap(), ConnectedLedgerAccountsDialog_1 = _a8, _a8.accountIncrement = 3, _a8.styles = [
  __superGet(_a8, _a8, "styles"),
  css`
      p {
        text-align: center;
      }

      #retry-button,
      #load-more-button {
        margin-top: 0.5rem;
        width: 100%;
      }
    `
], _a8);
__decorate6([
  property({ type: Boolean })
], ConnectedLedgerAccountsDialog.prototype, "open", void 0);
__decorate6([
  property({ attribute: false })
], ConnectedLedgerAccountsDialog.prototype, "wallet", void 0);
__decorate6([
  state()
], ConnectedLedgerAccountsDialog.prototype, "accountCount", void 0);
ConnectedLedgerAccountsDialog = ConnectedLedgerAccountsDialog_1 = __decorate6([
  customElement("dc-connected-ledger-accounts-dialog")
], ConnectedLedgerAccountsDialog);

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directives/repeat.js
var generateMap = (list, start, end) => {
  const map = /* @__PURE__ */ new Map();
  for (let i2 = start; i2 <= end; i2++) {
    map.set(list[i2], i2);
  }
  return map;
};
var RepeatDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error("repeat() can only be used in text expressions");
    }
  }
  _getValuesAndKeys(items, keyFnOrTemplate, template) {
    let keyFn;
    if (template === void 0) {
      template = keyFnOrTemplate;
    } else if (keyFnOrTemplate !== void 0) {
      keyFn = keyFnOrTemplate;
    }
    const keys = [];
    const values = [];
    let index = 0;
    for (const item of items) {
      keys[index] = keyFn ? keyFn(item, index) : index;
      values[index] = template(item, index);
      index++;
    }
    return {
      values,
      keys
    };
  }
  render(items, keyFnOrTemplate, template) {
    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;
  }
  update(containerPart, [items, keyFnOrTemplate, template]) {
    const oldParts = getCommittedValue(containerPart);
    const { values: newValues, keys: newKeys } = this._getValuesAndKeys(items, keyFnOrTemplate, template);
    if (!Array.isArray(oldParts)) {
      this._itemKeys = newKeys;
      return newValues;
    }
    const oldKeys = this._itemKeys ?? (this._itemKeys = []);
    const newParts = [];
    let newKeyToIndexMap;
    let oldKeyToIndexMap;
    let oldHead = 0;
    let oldTail = oldParts.length - 1;
    let newHead = 0;
    let newTail = newValues.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(oldParts[oldHead], newValues[newHead]);
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(oldParts[oldTail], newValues[newTail]);
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(oldParts[oldHead], newValues[newTail]);
        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(oldParts[oldTail], newValues[newHead]);
        insertPart(containerPart, oldParts[oldHead], oldParts[oldTail]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === void 0) {
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          const oldPart = oldIndex !== void 0 ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            const newPart = insertPart(containerPart, oldParts[oldHead]);
            setChildPartValue(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);
            insertPart(containerPart, oldParts[oldHead], oldPart);
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    while (newHead <= newTail) {
      const newPart = insertPart(containerPart, newParts[newTail + 1]);
      setChildPartValue(newPart, newValues[newHead]);
      newParts[newHead++] = newPart;
    }
    while (oldHead <= oldTail) {
      const oldPart = oldParts[oldHead++];
      if (oldPart !== null) {
        removePart(oldPart);
      }
    }
    this._itemKeys = newKeys;
    setCommittedValue(containerPart, newParts);
    return noChange;
  }
};
var repeat = directive(RepeatDirective);

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directives/when.js
function when(condition, trueCase, falseCase) {
  return condition ? trueCase(condition) : falseCase == null ? void 0 : falseCase(condition);
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/ledger/ledger-dialog.js
var __decorate7 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a9;
var LedgerDialog = (_a9 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    this.open = false;
    this.addDialogOpen = false;
    this.connectedAccounts = observableSignal(this, of([]), []);
  }
  updated(changedProperties) {
    if (changedProperties.has("wallet")) {
      this.connectedAccounts = observableSignal(this, getAccounts([this.wallet], genericChainSpec), []);
    }
  }
  render() {
    return html`<dc-dialog
        ?open=${this.open}
        @close=${(event) => this.dispatchEvent(new Event(event.type, event))}
      >
        <span slot="title">Ledger</span>
        <section slot="content">
          <header>
            <h3>Connected accounts</h3>
            <button class="text" @click=${() => this.addDialogOpen = true}>
              Add more
            </button>
          </header>
          ${repeat(this.connectedAccounts.value, (account) => account.id, (account, index) => html`<dc-account-list-item
                  address=${account.address}
                  name=${ifDefined(account.name)}
                >
                  <button
                    slot="trailing"
                    class="error sm"
                    @click=${() => this.wallet.accountStore.delete(account)}
                  >
                    Remove
                  </button></dc-account-list-item
                >${this.connectedAccounts.value.length <= 1 || index === this.connectedAccounts.value.length - 1 ? nothing : html`<hr />`}`)}
        </section>
      </dc-dialog>
      ${when(this.addDialogOpen, () => html`<dc-connected-ledger-accounts-dialog
            open
            @close=${() => this.addDialogOpen = false}
            .wallet=${this.wallet}
          ></dc-connected-ledger-accounts-dialog>`)}`;
  }
}, _a9.styles = [
  __superGet(_a9, _a9, "styles"),
  css`
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;

        padding: 0 0.5rem 0.75rem 0.5rem;

        h3 {
          font-size: 0.8em;
        }
      }

      hr {
        margin-inline-start: 3.2rem;
        margin-inline-end: 0.5rem;
        border-top: 1px solid var(--color-on-surface);
        opacity: 0.25;
      }
    `
], _a9);
__decorate7([
  property({ type: Boolean })
], LedgerDialog.prototype, "open", void 0);
__decorate7([
  property({ attribute: false })
], LedgerDialog.prototype, "wallet", void 0);
__decorate7([
  state()
], LedgerDialog.prototype, "addDialogOpen", void 0);
__decorate7([
  state()
], LedgerDialog.prototype, "connectedAccounts", void 0);
LedgerDialog = __decorate7([
  customElement("dc-ledger-dialog")
], LedgerDialog);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/icons/close.js
function close({ size = 24 }) {
  return html`<svg
    width=${size}
    height=${size}
    viewBox="0 0 29 29"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke="currentcolor"
  >
    <g>
      <path
        d="M4.89252 4.23135L24.6915 24.0303"
        fill="none"
        data-nofill="true"
      ></path>
      <path
        d="M24.6915 4.23135L4.89248 24.0303"
        fill="none"
        data-nofill="true"
      ></path>
    </g>
  </svg>`;
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/icons/users.js
function users({ size = 24 }) {
  return html`<svg
    width=${size}
    height=${size}
    viewBox="0 0 28 28"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke="currentcolor"
  >
    <g>
      <path
        d="M10.9523 11.4719L9.92866 10.2412C8.18155 8.14076 8.32148 5.05539 10.2515 3.12174C12.318 1.05141 15.6726 1.05141 17.7391 3.12174C19.6691 5.05539 19.8091 8.14076 18.062 10.2412L17.0385 11.4716C16.3847 12.2576 16.7593 13.4563 17.7443 13.7303L19.1309 14.1159C22.9276 15.1717 25.5547 18.6291 25.5547 22.5698V26.371H2.44531V22.5633C2.44531 18.6259 5.06981 15.1713 8.86305 14.1156L10.2468 13.7306C11.2316 13.4565 11.6061 12.2578 10.9523 11.4719Z"
      ></path>
    </g>
  </svg>`;
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/icons/wallet.js
function wallet({ size = 24 }) {
  return html`<svg
    width=${size}
    height=${size}
    viewBox="0 0 28 28"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke="currentcolor"
  >
    <g>
      <path d="M26.7599 3.24988H1.23975V24.7496H26.7599V3.24988Z"></path>
      <path
        d="M26.7742 8.98047H17.7689C14.9968 8.98047 12.7495 11.2277 12.7495 13.9999C12.7495 16.772 14.9968 19.0192 17.7689 19.0192H26.7742V8.98047Z"
      ></path>
      <circle cx="18" cy="14" r="1"></circle>
    </g>
  </svg>`;
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/icons/wallets.js
function wallets2({ size = 24 }) {
  return html`<svg
    width=${size}
    height=${size}
    viewBox="0 0 28 28"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke="currentcolor"
  >
    <g>
      <path d="M6.11719 7V2.86328H26.4695V20.0093H22.8445"></path>
      <path d="M22.4695 7.49976H2.11719V24.6457H22.4695V7.49976Z"></path>
      <path
        d="M21.4808 12.0699H15.2991C13.0883 12.0699 11.2961 13.8621 11.2961 16.0729C11.2961 18.2837 13.0883 20.0758 15.2991 20.0758H21.4808C22.0331 20.0758 22.4808 19.6281 22.4808 19.0758V13.0699C22.4808 12.5177 22.0331 12.0699 21.4808 12.0699Z"
      ></path>
      <path d="M15.0181 16.0181L15 16" stroke-miterlimit="10"></path>
    </g>
  </svg>`;
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/icons/copy.js
function copy({ size = 24 } = {}) {
  return html`<svg
    width=${size}
    height=${size}
    viewBox="0 0 28 28"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke="currentcolor"
  >
    <g>
      <path d="M8.99414 8.5V2H25.9941V19H19.4941"></path>
      <path d="M18.9941 9H1.99414V26H18.9941V9Z"></path>
    </g>
  </svg>`;
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/components/dialog.js
var __decorate8 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _dialogRef, _Dialog_instances, isBackdropClick_fn, _a10;
var Dialog = (_a10 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _Dialog_instances);
    __privateAdd(this, _dialogRef);
    this.open = false;
    __privateSet(this, _dialogRef, createRef());
  }
  updated(changedProperties) {
    var _a16, _b3;
    if (changedProperties.has("open")) {
      if (this.open) {
        (_a16 = __privateGet(this, _dialogRef).value) == null ? void 0 : _a16.showModal();
      } else {
        (_b3 = __privateGet(this, _dialogRef).value) == null ? void 0 : _b3.close();
      }
    }
  }
  static get styles() {
    return [
      super.styles,
      css`
        dialog {
          width: 100dvw;

          @media (min-width: 20rem) {
            width: revert;
            min-width: min(23rem, 100dvw);
          }

          box-shadow: 0px 8px 32px rgba(0, 0, 0, 0.32);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: min(1.5rem, var(--max-border-radius));
          padding: 0;
          background-color: var(--surface-color);

          opacity: 0;
          translate: 0 2rem;

          transition:
            opacity 0.25s,
            translate 0.25s,
            overlay 0.25s allow-discrete,
            display 0.25s allow-discrete;

          &[open] {
            opacity: 1;
            translate: 0 0;

            @starting-style {
              opacity: 0;
              translate: 0 2rem;
            }
          }
        }

        dialog::backdrop {
          background-color: rgba(0, 0, 0, 0);
          backdrop-filter: blur(0px);
          transition:
            background-color 0.25s,
            backdrop-filter 0.25s,
            overlay 0.25s allow-discrete,
            display 0.25s allow-discrete;
        }

        dialog[open]::backdrop {
          background-color: rgba(0, 0, 0, 0.6);
          backdrop-filter: blur(16px);

          @starting-style {
            background-color: rgba(0, 0, 0, 0);
            backdrop-filter: blur(0px);
          }
        }

        header {
          position: sticky;
          top: 0;

          display: flex;
          align-items: center;
          gap: 1rem;

          margin: 0 1.2rem;
          border-bottom: 1px solid var(--on-surface-color);
          background-color: var(--surface-color);
          padding: 1rem 0;

          h2 {
            flex: 1;
            font-size: 1em;
            text-align: center;
            margin-inline-start: 2rem;
          }

          #close-button {
            cursor: pointer;
          }
        }

        #content {
          margin: 1.2rem;
        }
      `
    ];
  }
  render() {
    return html`<dialog
      ${ref(__privateGet(this, _dialogRef))}
      @close=${(event) => this.dispatchEvent(new Event(event.type, event))}
      @pointerdown=${(event) => {
      var _a16;
      if (__privateMethod(this, _Dialog_instances, isBackdropClick_fn).call(this, event)) {
        (_a16 = __privateGet(this, _dialogRef).value) == null ? void 0 : _a16.addEventListener("pointerup", (event2) => {
          var _a17;
          if (__privateMethod(this, _Dialog_instances, isBackdropClick_fn).call(this, event2)) {
            (_a17 = __privateGet(this, _dialogRef).value) == null ? void 0 : _a17.close();
          }
        }, { once: true });
      }
    }}
    >
      <header>
        <h2><slot name="title"></slot></h2>
        <div
          id="close-button"
          role="button"
          @click=${() => {
      var _a16;
      return (_a16 = __privateGet(this, _dialogRef).value) == null ? void 0 : _a16.close();
    }}
        >
          ${close({ size: "1rem" })}
        </div>
      </header>
      <div id="content">
        <slot name="content"></slot>
      </div>
    </dialog>`;
  }
}, _dialogRef = new WeakMap(), _Dialog_instances = new WeakSet(), isBackdropClick_fn = function(event) {
  if (__privateGet(this, _dialogRef).value === void 0) {
    return false;
  }
  if (__privateGet(this, _dialogRef).value !== event.target) {
    return false;
  }
  const boundingClientRect = __privateGet(this, _dialogRef).value.getBoundingClientRect();
  return event.clientX < boundingClientRect.left || event.clientX > boundingClientRect.right || event.clientY < boundingClientRect.top || event.clientY > boundingClientRect.bottom;
}, _a10);
__decorate8([
  property({ type: Boolean })
], Dialog.prototype, "open", void 0);
Dialog = __decorate8([
  customElement("dc-dialog")
], Dialog);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/components/qr-code.js
var import_qrcode = __toESM(require_browser(), 1);
var __decorate9 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _padding, _QrCode_instances, size_get, logoWrapperSize_get, generateMatrix_fn, generateDots_fn, _a11;
var QrCode = (_a11 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _QrCode_instances);
    __privateAdd(this, _padding);
    this.ecl = "M";
    this.size = 320;
    this.logoSize = 50;
    this.logoMargin = 10;
    __privateSet(this, _padding, 20);
  }
  render() {
    return html`
      <div id="container" style=${styleMap({ padding: `${__privateGet(this, _padding)}px` })}>
        <div id="qr-code-container">
          <div id="logo-container">
            ${this.logoSrc === void 0 ? wallet({ size: this.logoSize }) : html`<img
                  src=${this.logoSrc}
                  style=${styleMap({
      width: `${this.logoSize}px`,
      height: `${this.logoSize}px`
    })}
                />`}
          </div>
          <svg height=${__privateGet(this, _QrCode_instances, size_get)} width=${__privateGet(this, _QrCode_instances, size_get)}>
            <title>QR Code</title>
            <defs>
              <clipPath id="clip-wrapper">
                <rect
                  height=${__privateGet(this, _QrCode_instances, logoWrapperSize_get)}
                  width=${__privateGet(this, _QrCode_instances, logoWrapperSize_get)}
                />
              </clipPath>
              <clipPath id="clip-logo">
                <rect height=${this.logoSize} width=${this.logoSize} />
              </clipPath>
            </defs>
            <rect fill="transparent" height=${__privateGet(this, _QrCode_instances, size_get)} width=${__privateGet(this, _QrCode_instances, size_get)} />
            ${__privateMethod(this, _QrCode_instances, generateDots_fn).call(this)}
          </svg>
        </div>
      </div>
    `;
  }
}, _padding = new WeakMap(), _QrCode_instances = new WeakSet(), size_get = function() {
  return this.size - __privateGet(this, _padding) * 2;
}, logoWrapperSize_get = function() {
  return this.logoSize + this.logoMargin * 2;
}, generateMatrix_fn = function(value, errorCorrectionLevel) {
  const arr = Array.prototype.slice.call((0, import_qrcode.create)(value, { errorCorrectionLevel }).modules.data, 0);
  const sqrt = Math.sqrt(arr.length);
  return arr.reduce((rows, key, index) => (index % sqrt === 0 ? rows.push([key]) : rows[rows.length - 1].push(key)) && rows, []);
}, generateDots_fn = function() {
  const dots = [];
  const matrix = __privateMethod(this, _QrCode_instances, generateMatrix_fn).call(this, this.uri, this.ecl);
  const cellSize = __privateGet(this, _QrCode_instances, size_get) / matrix.length;
  const qrList = [
    { x: 0, y: 0 },
    { x: 1, y: 0 },
    { x: 0, y: 1 }
  ];
  qrList.forEach(({ x, y: y2 }) => {
    const x1 = (matrix.length - 7) * cellSize * x;
    const y1 = (matrix.length - 7) * cellSize * y2;
    for (let i2 = 0; i2 < 3; i2++) {
      dots.push(svg`<rect
            height=${cellSize * (7 - i2 * 2)}
            key=${`${i2}-${x}-${y2}`}
            rx=${(i2 - 2) * -5 + (i2 === 0 ? 2 : 0)}
            ry=${(i2 - 2) * -5 + (i2 === 0 ? 2 : 0)}
            width=${cellSize * (7 - i2 * 2)}
            x=${x1 + cellSize * i2}
            y=${y1 + cellSize * i2}
            style=${styleMap({
        fill: i2 % 2 !== 0 ? "var(--surface-color)" : "var(--on-surface-color)"
      })}
          />`);
    }
  });
  const clearArenaSize = Math.floor((this.logoSize + 25) / cellSize);
  const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
  const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
  matrix.forEach((row, outerIndex) => {
    row.forEach((_2, innerIndex) => {
      if (matrix[outerIndex][innerIndex]) {
        if (!(outerIndex < 7 && innerIndex < 7 || outerIndex > matrix.length - 8 && innerIndex < 7 || outerIndex < 7 && innerIndex > matrix.length - 8)) {
          if (!(outerIndex > matrixMiddleStart && outerIndex < matrixMiddleEnd && innerIndex > matrixMiddleStart && innerIndex < matrixMiddleEnd)) {
            dots.push(svg`<circle
                  cx=${outerIndex * cellSize + cellSize / 2}
                  cy=${innerIndex * cellSize + cellSize / 2}
                  key="circle-${outerIndex}-${innerIndex}"
                  r=${cellSize / 3}
                  style=${styleMap({
              fill: "var(--on-surface-color)"
            })}
                />`);
          }
        }
      }
    });
  });
  return dots;
}, _a11.styles = [
  __superGet(_a11, _a11, "styles"),
  css`
      svg {
        all: revert;
      }

      #container {
        width: min-content;
      }

      #qr-code-container {
        position: relative;
        width: min-content;
      }

      #logo-container {
        position: absolute;
        inset: 0;
        display: flex;

        img {
          margin: auto;
          border-color: rgba(0, 0, 0, 0.06);
          border-radius: min(1.2rem, var(--max-border-radius));
        }
      }
    `
], _a11);
__decorate9([
  property()
], QrCode.prototype, "ecl", void 0);
__decorate9([
  property()
], QrCode.prototype, "uri", void 0);
__decorate9([
  property({ type: Number })
], QrCode.prototype, "size", void 0);
__decorate9([
  property()
], QrCode.prototype, "logoSrc", void 0);
__decorate9([
  property({ type: Number })
], QrCode.prototype, "logoSize", void 0);
__decorate9([
  property({ type: Number })
], QrCode.prototype, "logoMargin", void 0);
QrCode = __decorate9([
  customElement("dc-qr-code")
], QrCode);

// node_modules/.pnpm/lit-html@3.3.0/node_modules/lit-html/development/directives/join.js
function* join(items, joiner) {
  const isFunction = typeof joiner === "function";
  if (items !== void 0) {
    let i2 = -1;
    for (const value of items) {
      if (i2 > -1) {
        yield isFunction ? joiner(i2) : joiner;
      }
      i2++;
      yield value;
    }
  }
}

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/connection-dialog.js
var __decorate10 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _availableWallets, _installedWallets, _deepLinkWallets, _hardwareWallets, _nonInstalledWallets, _a12;
var ConnectionDialog = (_a12 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _availableWallets);
    __privateAdd(this, _installedWallets);
    __privateAdd(this, _deepLinkWallets);
    __privateAdd(this, _hardwareWallets);
    __privateAdd(this, _nonInstalledWallets);
    this.open = false;
    __privateSet(this, _availableWallets, observableSignal(this, wallets$, []));
    __privateSet(this, _installedWallets, w(() => __privateGet(this, _availableWallets).value.filter((wallet2) => !__privateGet(this, _deepLinkWallets).value.includes(wallet2) && !__privateGet(this, _hardwareWallets).value.includes(wallet2))));
    __privateSet(this, _deepLinkWallets, w(() => __privateGet(this, _availableWallets).value.filter((wallet2) => wallet2 instanceof DeepLinkWallet)));
    __privateSet(this, _hardwareWallets, w(() => __privateGet(this, _availableWallets).value.filter((wallet2) => ["ledger"].includes(wallet2.id))));
    __privateSet(this, _nonInstalledWallets, w(() => walletConfigs.value.filter((config) => "downloadUrl" in config && !__privateGet(this, _installedWallets).value.some((wallet2) => config.selector(wallet2)))));
  }
  show() {
    this.open = true;
  }
  close() {
    this.open = false;
  }
  static get styles() {
    return [
      super.styles,
      css`
        h3 {
          font-size: 0.8em;
          margin: 1rem 0.5rem 0.5rem 0.5rem;
        }

        hr {
          margin-inline-start: 3.2rem;
          margin-inline-end: 0.5rem;
          border-top: 1px solid var(--color-on-surface);
          opacity: 0.25;
        }
      `
    ];
  }
  render() {
    return html`<dc-dialog
      ?open=${this.open}
      @close=${(event) => {
      this.close();
      this.dispatchEvent(new Event(event.type, event));
    }}
    >
      <span slot="title">Connect wallet</span>
      <div slot="content">
        ${when(__privateGet(this, _installedWallets).value.length > 0, () => html`<section>
              <header><h3>Installed</h3></header>
              <ul>
                ${join(__privateGet(this, _installedWallets).value.map((wallet2) => html`<dc-wallet .wallet=${wallet2}></dc-wallet>`), html`<hr />`)}
              </ul>
            </section>`)}
        ${when("USB" in globalThis && __privateGet(this, _hardwareWallets).value.length > 0, () => html`<section>
              <header><h3>Hardware</h3></header>
              <ul>
                ${join(__privateGet(this, _hardwareWallets).value.map((wallet2) => html`<dc-hardware-wallet
                        .wallet=${wallet2}
                      ></dc-hardware-wallet>`), html`<hr />`)}
              </ul>
            </section>`)}
        ${when(__privateGet(this, _deepLinkWallets).value.length > 0, () => html`<section>
              <header><h3>Remote</h3></header>
              <ul>
                ${join(__privateGet(this, _deepLinkWallets).value.map((wallet2) => html`<dc-deep-link-wallet
                        .wallet=${wallet2}
                      ></dc-deep-link-wallet>`), html`<hr />`)}
              </ul>
            </section>`)}
        ${when(__privateGet(this, _nonInstalledWallets).value.length > 0, () => html`<section>
              <header><h3>Popular</h3></header>
              <ul>
                ${join(__privateGet(this, _nonInstalledWallets).value.filter(DownloadableWallet.shouldRender).map((wallet2) => html`<dc-downloadable-wallet
                          .wallet=${wallet2}
                        ></dc-downloadable-wallet>`), html`<hr />`)}
              </ul>
            </section>`)}
      </div>
    </dc-dialog>`;
  }
}, _availableWallets = new WeakMap(), _installedWallets = new WeakMap(), _deepLinkWallets = new WeakMap(), _hardwareWallets = new WeakMap(), _nonInstalledWallets = new WeakMap(), _a12);
__decorate10([
  property({ type: Boolean })
], ConnectionDialog.prototype, "open", void 0);
ConnectionDialog = __decorate10([
  customElement("dc-connection-dialog")
], ConnectionDialog);
var _connectedWallets;
var _BaseWalletConnection = class _BaseWalletConnection extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _connectedWallets);
    __privateSet(this, _connectedWallets, observableSignal(this, connectedWallets$, []));
    this.accounts = observableSignal(this, of([]), []);
    this.connected = w(() => __privateGet(this, _connectedWallets).value.includes(this.wallet));
    this.pending = d2(false);
  }
  get walletInfo() {
    return walletConfigs.value.find((config) => config.selector(this.wallet));
  }
  updated(changedProperties) {
    if (changedProperties.has("wallet")) {
      this.accounts = observableSignal(this, this.wallet.accounts$, []);
    }
  }
  render() {
    var _a16;
    return html`<dc-list-item ?pending=${this.pending.value}>
      <div slot="leading" class="icon">
        ${this.walletInfo === void 0 ? wallet({ size: "100%" }) : html`<img src=${this.walletInfo.logo.href} />`}
      </div>
      <span slot="headline">${((_a16 = this.walletInfo) == null ? void 0 : _a16.name) ?? this.wallet.name}</span>
      <span
        id="connection-status"
        slot="supporting"
        class=${classMap({ connected: this.connected.value })}
        >${this.connected.value ? html`Connected | ${this.accounts.value.length}
              <span class="icon">${users({ size: "1em" })}</span>` : "Not connected"}</span
      >
      ${this.trailing()}
    </dc-list-item>`;
  }
  trailing() {
    return html``;
  }
};
_connectedWallets = new WeakMap();
_BaseWalletConnection.styles = [
  __superGet(_BaseWalletConnection, _BaseWalletConnection, "styles"),
  css`
      button {
        min-width: 5rem;
      }

      #connection-status.connected {
        color: var(--success-color);
      }
    `
];
var BaseWalletConnection = _BaseWalletConnection;
__decorate10([
  property({ attribute: false })
], BaseWalletConnection.prototype, "wallet", void 0);
__decorate10([
  state()
], BaseWalletConnection.prototype, "accounts", void 0);
var WalletConnection = class WalletConnection2 extends BaseWalletConnection {
  trailing() {
    return html`<button
      slot="trailing"
      class=${classMap({
      success: !this.connected.value,
      error: this.connected.value,
      sm: true
    })}
      @click=${async () => {
      if (this.pending.value) {
        return;
      }
      try {
        this.pending.value = true;
        if (this.connected.value) {
          await disconnectWallet(this.wallet);
        } else {
          await connectWallet(this.wallet);
        }
      } catch (error) {
        console.error(error);
      } finally {
        this.pending.value = false;
      }
    }}
    >
      ${this.connected.value ? "Disconnect" : "Connect"}
    </button>`;
  }
};
WalletConnection = __decorate10([
  customElement("dc-wallet")
], WalletConnection);
var _uri, _a13;
var DeepLinkWalletConnection = (_a13 = class extends BaseWalletConnection {
  constructor() {
    super();
    __privateAdd(this, _uri, d2(void 0));
    E(() => {
      if (this.connected.value) {
        __privateGet(this, _uri).value = void 0;
      }
    });
  }
  trailing() {
    return html`<button
      slot="trailing"
      class=${classMap({
      success: !this.connected.value,
      error: this.connected.value,
      sm: true
    })}
      @click=${async () => {
      if (this.pending.value) {
        return;
      }
      try {
        this.pending.value = true;
        if (this.connected.value) {
          await disconnectWallet(this.wallet);
        } else {
          const { uri } = await this.wallet.initiateConnectionHandshake();
          __privateGet(this, _uri).value = uri;
        }
      } catch (error) {
        console.error(error);
      } finally {
        this.pending.value = false;
      }
    }}
    >
      ${this.connected.value ? "Disconnect" : "Connect"}
    </button>`;
  }
  render() {
    var _a16;
    return html`<div style="display: content;">
      ${super.render()}
      ${__privateGet(this, _uri).value === void 0 ? nothing : html`<dc-dialog
            ?open=${true}
            @close=${() => __privateGet(this, _uri).value = void 0}
          >
            <span slot="title">Scan QR code</span>
            <div slot="content">
              <dc-qr-code
                .uri=${__privateGet(this, _uri).value}
                .logoSrc=${(_a16 = this.walletInfo) == null ? void 0 : _a16.logo.href}
              ></dc-qr-code>
              <div id="url-container">
                <button
                  class="text info"
                  @click=${() => globalThis.navigator.clipboard.writeText(__privateGet(this, _uri).value)}
                >
                  Copy link ${copy({ size: "1em" })}
                </button>
              </div>
            </div>
          </dc-dialog>`}
    </div>`;
  }
}, _uri = new WeakMap(), _a13.styles = [
  __superGet(_a13, _a13, "styles"),
  css`
      #url-container {
        display: flex;
        justify-content: center;

        button {
          padding: 0;
          cursor: copy;

          svg {
            vertical-align: -0.125em;
          }
        }
      }
    `
], _a13);
DeepLinkWalletConnection = __decorate10([
  customElement("dc-deep-link-wallet")
], DeepLinkWalletConnection);
var HardwareWalletConnection = class HardwareWalletConnection2 extends BaseWalletConnection {
  constructor() {
    super(...arguments);
    this.open = false;
  }
  trailing() {
    return html`<button
      slot="trailing"
      class=${classMap({
      success: !this.connected.value,
      info: this.connected.value,
      sm: true
    })}
      @click=${() => this.open = this.connected.value ? "manage" : "connect"}
    >
      ${this.connected.value ? "Manage" : "Connect"}
    </button>`;
  }
  render() {
    return html`
      ${super.render()}
      ${when(this.open === "manage", () => html`<dc-ledger-dialog
            open
            @close=${() => this.open = false}
            .wallet=${this.wallet}
          ></dc-ledger-dialog>`)}
      ${when(this.open === "connect", () => html`<dc-connected-ledger-accounts-dialog
            open
            @close=${() => this.open = false}
            .wallet=${this.wallet}
          ></dc-connected-ledger-accounts-dialog>`)}
    `;
  }
};
__decorate10([
  state()
], HardwareWalletConnection.prototype, "open", void 0);
HardwareWalletConnection = __decorate10([
  customElement("dc-hardware-wallet")
], HardwareWalletConnection);
var _DownloadableWallet_instances, downloadUrl_get, _a14;
var DownloadableWallet = (_a14 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _DownloadableWallet_instances);
  }
  // TODO: this is a hack
  static shouldRender(wallet2) {
    return getDownloadUrl(wallet2) !== void 0;
  }
  render() {
    if (__privateGet(this, _DownloadableWallet_instances, downloadUrl_get) === void 0) {
      return nothing;
    }
    const isMobile = __privateGet(this, _DownloadableWallet_instances, downloadUrl_get).platform === "android" || __privateGet(this, _DownloadableWallet_instances, downloadUrl_get).platform === "ios";
    return html`<dc-list-item>
      <div slot="leading" class="icon">
        <img src=${this.wallet.logo.href} />
      </div>
      <span slot="headline">${this.wallet.name}</span>
      <!-- No way to detect wether or not wallet is installed on mobile browser -->
      ${isMobile ? nothing : html`<span slot="supporting">Not installed</span>`}
      <a
        slot="trailing"
        style="display: content; text-decoration: none;"
        href=${__privateGet(this, _DownloadableWallet_instances, downloadUrl_get).url}
        target="_blank"
      >
        <button class="info sm">Get</button></a
      >
    </dc-list-item>`;
  }
}, _DownloadableWallet_instances = new WeakSet(), downloadUrl_get = function() {
  return getDownloadUrl(this.wallet);
}, _a14.styles = [
  __superGet(_a14, _a14, "styles"),
  css`
      button {
        min-width: 5rem;
      }
    `
], _a14);
__decorate10([
  property({ attribute: false })
], DownloadableWallet.prototype, "wallet", void 0);
DownloadableWallet = __decorate10([
  customElement("dc-downloadable-wallet")
], DownloadableWallet);

// node_modules/.pnpm/dot-connect@0.18.0_@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5_0ce1a9b55c7d4e2e4b3b22f55ef3cc6f/node_modules/dot-connect/build/elements/connection-button.js
var __decorate11 = function(decorators, target, key, desc2) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var _dialogOpen, _connectedWallets2, _accounts, _a15;
var ConnectionButton = (_a15 = class extends DotConnectElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _dialogOpen, d2(false));
    __privateAdd(this, _connectedWallets2, observableSignal(this, connectedWallets$, []));
    __privateAdd(this, _accounts, observableSignal(this, accounts$, []));
  }
  render() {
    return html`
      <button
        id="button"
        part="button"
        @click=${() => __privateGet(this, _dialogOpen).value = true}
      >
        ${__privateGet(this, _connectedWallets2).value.length > 0 ? html`Connected | ${__privateGet(this, _connectedWallets2).value.length}
              <span class="icon"
                >${__privateGet(this, _connectedWallets2).value.length === 1 ? wallet({ size: "1em" }) : wallets2({ size: "1em" })}</span
              >
              ${__privateGet(this, _accounts).value.length}
              <span class="icon">${users({ size: "1em" })}</span>` : html`Connect
              <span class="icon">${wallets2({ size: "1em" })}</span>`}
      </button>
      <dc-connection-dialog
        ?open=${__privateGet(this, _dialogOpen).value}
        @close=${() => __privateGet(this, _dialogOpen).value = false}
      ></dc-connection-dialog>
    `;
  }
}, _dialogOpen = new WeakMap(), _connectedWallets2 = new WeakMap(), _accounts = new WeakMap(), _a15.styles = [
  __superGet(_a15, _a15, "styles"),
  css`
      :host {
        font-size: 1.5em;
      }

      #button {
        text-wrap-mode: nowrap;
      }

      .icon {
        display: contents;
        > * {
          vertical-align: -0.125em;
        }
      }
    `
], _a15);
ConnectionButton = __decorate11([
  customElement("dc-connection-button")
], ConnectionButton);

export {
  walletsOrProviders$,
  walletConfigs,
  ConnectionDialog,
  ConnectionButton
};
/*! Bundled license information:

@lit/reactive-element/development/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/reactive-element.js:
lit-html/development/lit-html.js:
lit-element/development/lit-element.js:
lit-html/development/directive.js:
lit-html/development/async-directive.js:
@lit/reactive-element/development/decorators/custom-element.js:
@lit/reactive-element/development/decorators/property.js:
@lit/reactive-element/development/decorators/state.js:
@lit/reactive-element/development/decorators/event-options.js:
@lit/reactive-element/development/decorators/base.js:
@lit/reactive-element/development/decorators/query.js:
@lit/reactive-element/development/decorators/query-all.js:
@lit/reactive-element/development/decorators/query-async.js:
@lit/reactive-element/development/decorators/query-assigned-nodes.js:
@lit/task/development/task.js:
@lit/task/development/index.js:
lit-html/development/directives/repeat.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/preact-signals/development/lib/signal-watcher.js:
@lit-labs/preact-signals/development/lib/watch.js:
@lit-labs/preact-signals/development/lib/html-tag.js:
@lit-labs/preact-signals/development/index.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive-helpers.js:
lit-html/development/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-assigned-elements.js:
lit-html/development/directives/when.js:
lit-html/development/directives/join.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/class-map.js:
lit-html/development/directives/if-defined.js:
lit-html/development/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-6HYL3RYW.js.map
