import {
  createClientFromLightClientProvider,
  isLightClientProvider
} from "./chunk-HK3DZUUN.js";
import {
  createClient
} from "./chunk-AKNCNGJG.js";
import {
  AccountId,
  Bytes,
  Struct,
  enhanceCodec,
  getDynamicBuilder,
  getLookupFn,
  metadata,
  u8,
  unifyMetadata
} from "./chunk-EVM4Y7G3.js";
import {
  Wallet
} from "./chunk-OVJJME56.js";
import {
  combineLatest,
  from,
  isObservable,
  map,
  of,
  switchMap
} from "./chunk-2T3XQHSK.js";

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/aggregate-wallets.js
var providerWallets = /* @__PURE__ */ new WeakMap();
function aggregateWallets(providersOrWallets) {
  return Promise.all(providersOrWallets.map((walletOrProvider) => walletOrProvider instanceof Wallet ? [walletOrProvider] : providerWallets.get(walletOrProvider) ?? providerWallets.set(walletOrProvider, Promise.resolve(walletOrProvider.getWallets())).get(walletOrProvider))).then((wallets) => wallets.flat());
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/connect-wallet.js
async function connectWallet(wallet) {
  const walletsToConnect = Array.isArray(wallet) ? wallet : [wallet];
  await Promise.all(walletsToConnect.map((wallet2) => wallet2.connect()));
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/disconnect-wallet.js
async function disconnectWallet(wallet) {
  const walletsToDisconnect = Array.isArray(wallet) ? wallet : [wallet];
  await Promise.all(walletsToDisconnect.map((wallet2) => wallet2.disconnect()));
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/utils/native-token-info-from-chain-spec-data.js
function nativeTokenInfoFromChainSpecData(chainSpecData) {
  const symbol = chainSpecData.properties.tokenSymbol;
  const decimals = chainSpecData.properties.tokenDecimals;
  return {
    code: typeof symbol === "string" ? symbol : Array.isArray(symbol) && typeof symbol[0] === "string" ? symbol[0] : void 0,
    decimals: typeof decimals === "number" ? decimals : Array.isArray(decimals) && typeof decimals[0] === "number" ? decimals[0] : void 0
  };
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/utils/to-observable.js
function toObservable(value) {
  if (isObservable(value)) {
    return value;
  }
  if (value instanceof Promise) {
    return from(value);
  }
  return of(value);
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/get-accounts.js
function getAccounts(wallets, chainSpec) {
  return combineLatest([toObservable(wallets), toObservable(chainSpec)]).pipe(switchMap(([wallets2, chainSpec2]) => {
    if (wallets2.length === 0) {
      return of([]);
    }
    const maybeSs58Format = chainSpec2 == null ? void 0 : chainSpec2.properties.ss58Format;
    const ss58Format = typeof maybeSs58Format === "number" ? maybeSs58Format : void 0;
    const ss58AccountId = AccountId(ss58Format);
    return combineLatest(wallets2.map((wallet) => wallet.accounts$.pipe(map((accounts) => accounts.map((account) => {
      const polkadotSigner = (() => {
        if (typeof account.polkadotSigner !== "function") {
          return account.polkadotSigner;
        }
        if (chainSpec2 === void 0) {
          return void 0;
        }
        const nativeTokenInfo = nativeTokenInfoFromChainSpecData(chainSpec2);
        return account.polkadotSigner({
          tokenSymbol: nativeTokenInfo.code ?? "",
          tokenDecimals: nativeTokenInfo.decimals ?? 0
        });
      })();
      if (polkadotSigner === void 0) {
        return void 0;
      }
      return {
        ...account,
        polkadotSigner,
        address: ss58AccountId.dec(polkadotSigner.publicKey),
        wallet
      };
    }).filter((account) => account !== void 0))))).pipe(map((accounts) => accounts.flat()), map(chainSpec2 === void 0 ? (accounts) => accounts : (accounts) => accounts.filter((account) => !account.genesisHash || chainSpec2.genesisHash.includes(account.genesisHash))));
  }));
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/get-block-extrinsics.js
async function unstable_getBlockExtrinsics(client, typedApi, blockHash) {
  const v15MetadataBinary = await typedApi.apis["Metadata"]["metadata_at_version"](15);
  if (v15MetadataBinary === void 0) {
    return;
  }
  const metadataResult = metadata.dec(v15MetadataBinary.asBytes());
  if (metadataResult.metadata.tag !== "v15") {
    return;
  }
  const metadata2 = metadataResult.metadata.value;
  const dynamicBuilder = await getOrCreateDynamicBuilder(client, metadata2);
  const version$ = enhanceCodec(u8, (value) => +!!value.signed << 7 | value.version, (value) => ({
    version: value & ~(1 << 7),
    signed: !!(value & 1 << 7)
  }));
  const address$ = dynamicBuilder.buildDefinition(metadata2.extrinsic.address);
  const signature$ = dynamicBuilder.buildDefinition(metadata2.extrinsic.signature);
  const rawExtra$ = dynamicBuilder.buildDefinition(metadata2.extrinsic.extra);
  const extra$ = enhanceCodec(rawExtra$, (extra) => metadata2.extrinsic.signedExtensions.map((signedExtension) => extra["Check" + signedExtension.identifier.slice(0, 1).toUpperCase() + signedExtension.identifier.slice(1, 0)]), (extra) => Object.fromEntries(metadata2.extrinsic.signedExtensions.map((signedExtension, index) => {
    const name = signedExtension.identifier.replace(/^Check/, "");
    return [
      name.slice(0, 1).toLowerCase() + name.slice(1),
      extra[index]
    ];
  })));
  const rawCall$ = dynamicBuilder.buildDefinition(metadata2.extrinsic.call);
  const call$ = enhanceCodec(rawCall$, (call) => ({
    type: call.module,
    value: { type: call.func, value: call.args }
  }), (call) => ({
    module: call.type,
    func: call.value.type,
    args: call.value.value
  }));
  const inherentExtrinsic$ = Struct({
    version: version$,
    body: Struct({ call: call$ })
  });
  const signedExtrinsic$ = Struct({
    version: version$,
    body: Struct({
      sender: address$,
      signature: signature$,
      extra: extra$,
      call: call$
    })
  });
  const simpleVersion$ = Struct({
    version: version$
  });
  const extrinsic$ = enhanceCodec(Bytes(), (extrinsic) => extrinsic.signed ? signedExtrinsic$.enc({
    version: { version: extrinsic.version, signed: extrinsic.signed },
    body: {
      sender: extrinsic.sender,
      signature: extrinsic.signature,
      extra: extrinsic.extra,
      call: extrinsic.call
    }
  }) : inherentExtrinsic$.enc({
    version: { version: extrinsic.version, signed: extrinsic.signed },
    body: { call: extrinsic.call }
  }), (extrinsicBytes) => {
    const { version: { signed } } = simpleVersion$.dec(extrinsicBytes);
    const rawExtrinsic = (signed ? signedExtrinsic$.dec : inherentExtrinsic$.dec)(extrinsicBytes);
    return { ...rawExtrinsic.version, ...rawExtrinsic.body };
  });
  const blockBody = await client.getBlockBody(blockHash);
  return blockBody.map(extrinsic$.dec);
}
var dynamicBuilders = /* @__PURE__ */ new WeakMap();
async function getOrCreateDynamicBuilder(client, metadata2) {
  if (dynamicBuilders.has(client)) {
    return dynamicBuilders.get(client);
  }
  const lookup = getLookupFn(unifyMetadata(metadata2));
  const dynamicBuilder = getDynamicBuilder(lookup);
  return dynamicBuilders.set(client, dynamicBuilder).get(client);
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/get-block.js
function getBlock(client, options) {
  switch (options == null ? void 0 : options.tag) {
    case "best":
      return client.bestBlocks$.pipe(map((blockInfos) => blockInfos.at(0)));
    case "finalized":
    default:
      return client.finalizedBlock$;
  }
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/get-client.js
async function getClient(chainConfig) {
  const providerOrGetter = await chainConfig.provider;
  if (isLightClientProvider(providerOrGetter)) {
    return createClientFromLightClientProvider(providerOrGetter);
  }
  const providerOrController = await (providerOrGetter.length > 0 ? providerOrGetter : providerOrGetter());
  if (isLightClientProvider(providerOrController)) {
    return createClientFromLightClientProvider(providerOrController);
  }
  return createClient(providerOrController);
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/get-connected-wallets.js
function getConnectedWallets(wallets) {
  return toObservable(wallets).pipe(switchMap((wallets2) => {
    if (wallets2.length === 0) {
      return of([]);
    }
    return combineLatest(wallets2.map((wallet) => wallet.connected$.pipe(map((connected) => [wallet, connected]))));
  }), map((wallets2) => wallets2.filter(([_, connected]) => connected).map(([wallet]) => wallet)));
}

// node_modules/.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/build/actions/query.js
function query(api, instruction, options) {
  var _a, _b;
  switch (instruction.instruction) {
    case "get-constant":
      return (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        api.constants[instruction.pallet][instruction.constant]()
      );
    case "call-api":
      return api.apis[instruction.pallet][instruction.api](...instruction.args, { signal: options == null ? void 0 : options.signal, at: instruction.at });
    case "read-storage": {
      const storageEntry = api.query[instruction.pallet][
        instruction.storage
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ];
      return ((_a = instruction.at) == null ? void 0 : _a.startsWith("0x")) ? storageEntry.getValue(...instruction.args, { at: instruction.at }) : storageEntry.watchValue(...instruction.args, ...[instruction.at].filter((x) => x !== void 0));
    }
    case "read-storage-entries":
      return ((_b = instruction.at) == null ? void 0 : _b.startsWith("0x")) ? (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        api.query[instruction.pallet][instruction.storage].getEntries(...instruction.args, {
          signal: options == null ? void 0 : options.signal,
          at: instruction.at
        }).then((response) => response.map(({ keyArgs, value }) => Object.assign([keyArgs, value], {
          /** @deprecated Use index access instead. */
          keyArgs,
          /** @deprecated Use index access instead. */
          value
        })))
      ) : (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        api.query[instruction.pallet][instruction.storage].watchEntries(...instruction.args, {
          at: instruction.at
        }).pipe(map((response) => response.entries.map(({ args, value }) => Object.assign([args, value], {
          /** @deprecated Use index access instead. */
          keyArgs: args,
          /** @deprecated Use index access instead. */
          value
        }))))
      );
  }
}
function preflight(instruction) {
  var _a;
  if ("at" in instruction && ((_a = instruction.at) == null ? void 0 : _a.startsWith("0x"))) {
    return "promise";
  }
  switch (instruction.instruction) {
    case "get-constant":
    case "call-api":
      return "promise";
    case "read-storage-entries":
    case "read-storage":
      return "observable";
  }
}

export {
  aggregateWallets,
  connectWallet,
  disconnectWallet,
  nativeTokenInfoFromChainSpecData,
  getAccounts,
  unstable_getBlockExtrinsics,
  getBlock,
  getClient,
  getConnectedWallets,
  query,
  preflight
};
//# sourceMappingURL=chunk-Y7OA44XQ.js.map
