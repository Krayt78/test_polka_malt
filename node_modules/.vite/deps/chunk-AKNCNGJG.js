import {
  AbortError,
  AccountId,
  Binary,
  Blake2256,
  Bytes,
  Enum,
  FixedSizeBinary,
  Option,
  Self,
  Struct,
  Tuple,
  Variant,
  Vector,
  _void,
  blockHeader,
  compact,
  compactBn,
  compactNumber,
  createDecoder,
  createV4Tx,
  decAnyMetadata,
  enhanceEncoder,
  fromHex,
  getDynamicBuilder,
  getLookupFn,
  getSignBytes,
  mapObject,
  mergeUint8,
  metadata,
  noop as noop2,
  str,
  toHex,
  u128,
  u16,
  u32,
  u64,
  u8,
  unifyMetadata
} from "./chunk-EVM4Y7G3.js";
import {
  BehaviorSubject,
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  Subscriber,
  Subscription,
  catchError,
  combineLatest,
  combineLatestWith,
  concat,
  concatMap,
  connectable,
  defer,
  delay,
  distinct,
  distinctUntilChanged,
  exhaustMap,
  filter,
  firstValueFrom,
  from,
  identity,
  lastValueFrom,
  map,
  merge,
  mergeAll,
  mergeMap,
  noop,
  of,
  pairwise,
  pipe,
  scan,
  share,
  shareReplay,
  startWith,
  switchAll,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  tap,
  throwError,
  timer,
  withLatestFrom
} from "./chunk-2T3XQHSK.js";

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/typedef.mjs
var smallCompact = compactNumber;
var StructCodec = Vector(Tuple(str, smallCompact));
var Primitive = {
  bool: "boolean",
  str: "string",
  num: "number",
  big: "bigint",
  bits: "bitseq",
  void: "void"
};
var TerminalCodec = Variant(
  Object.fromEntries(
    Object.values(Primitive).map((p) => [p, _void])
  )
);
var EnumCodec = Vector(
  Tuple(
    str,
    Variant({
      inline: Self(() => TypedefCodec),
      lookup: smallCompact
    })
  )
);
var TupleCodec = Vector(smallCompact);
var ArrayCodec = Struct({
  typeRef: smallCompact,
  length: Option(smallCompact)
});
var BinaryCodec = Option(smallCompact);
var OptionCodec = smallCompact;
var ResultCodec = Struct({
  ok: smallCompact,
  ko: smallCompact
});
var TypedefCodec = Variant({
  struct: StructCodec,
  terminal: TerminalCodec,
  enum: EnumCodec,
  tuple: TupleCodec,
  array: ArrayCodec,
  binary: BinaryCodec,
  option: OptionCodec,
  result: ResultCodec
});
var primitiveToTerminal = {
  i256: Primitive.big,
  i128: Primitive.big,
  i64: Primitive.big,
  i32: Primitive.num,
  i16: Primitive.num,
  i8: Primitive.num,
  u256: Primitive.big,
  u128: Primitive.big,
  u64: Primitive.big,
  u32: Primitive.num,
  u16: Primitive.num,
  u8: Primitive.num,
  bool: Primitive.bool,
  char: Primitive.str,
  str: Primitive.str
};
var terminal = (type) => ({
  type: "terminal",
  value: { type }
});
function mapLookupToTypedef(entry, resolve = () => {
}) {
  switch (entry.type) {
    case "AccountId20":
    case "AccountId32":
      return terminal(Primitive.str);
    case "array":
      if (entry.value.type === "primitive" && entry.value.value === "u8") {
        return { type: "binary", value: entry.len };
      }
      resolve(entry.value.id);
      return {
        type: "array",
        value: {
          typeRef: entry.value.id,
          length: entry.len
        }
      };
    case "bitSequence":
      return terminal(Primitive.bits);
    case "compact":
      return terminal(entry.isBig ? Primitive.big : Primitive.num);
    case "enum":
      return {
        type: "enum",
        value: Object.entries(entry.value).map(
          ([key, params]) => {
            if (params.type !== "lookupEntry")
              return [
                key,
                { type: "inline", value: mapLookupToTypedef(params, resolve) }
              ];
            resolve(params.value.id);
            return [
              key,
              {
                type: "lookup",
                value: params.value.id
              }
            ];
          }
        )
      };
    case "struct": {
      const value2 = Object.entries(entry.value).map(
        ([key, prop]) => [key, prop.id]
      );
      value2.forEach(([, v]) => resolve(v));
      return {
        type: "struct",
        value: value2
      };
    }
    case "tuple": {
      const value2 = entry.value.map((v) => v.id);
      value2.forEach(resolve);
      return {
        type: "tuple",
        value: value2
      };
    }
    case "option":
      resolve(entry.value.id);
      return {
        type: "option",
        value: entry.value.id
      };
    case "primitive":
      return terminal(primitiveToTerminal[entry.value]);
    case "result":
      resolve(entry.value.ok.id);
      resolve(entry.value.ko.id);
      return {
        type: "result",
        value: {
          ok: entry.value.ok.id,
          ko: entry.value.ko.id
        }
      };
    case "sequence":
      if (entry.value.type === "primitive" && entry.value.value === "u8") {
        return { type: "binary", value: void 0 };
      }
      resolve(entry.value.id);
      return {
        type: "array",
        value: { typeRef: entry.value.id }
      };
    case "void":
      return terminal(Primitive.void);
  }
}

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/isCompatible.mjs
function isCompatible(value2, destNode, getNode) {
  if (destNode.type === "option" && value2 == null) {
    return true;
  }
  const nextCall = (value22, destNode2) => isCompatible(value22, destNode2, getNode);
  const checkTerminal = (terminal2) => {
    switch (terminal2.value.type) {
      case Primitive.str:
      case Primitive.big:
      case Primitive.bool:
      case Primitive.num:
        return typeof value2 === terminal2.value.type;
      case Primitive.bits:
        return typeof value2 === "object" && value2 != null && typeof value2.bitsLen === "number" && value2.bytes instanceof Uint8Array;
      case Primitive.void:
        return true;
    }
  };
  switch (destNode.type) {
    case "terminal":
      return checkTerminal(destNode);
    case "binary":
      return value2 instanceof Binary && (destNode.value == null || value2.asBytes().length >= destNode.value);
    case "array":
      if (!Array.isArray(value2)) return false;
      const valueArr = value2;
      if (destNode.value.length != null && valueArr.length < destNode.value.length) {
        return false;
      }
      return valueArr.slice(0, destNode.value.length).every((value22) => nextCall(value22, getNode(destNode.value.typeRef)));
    case "enum":
      if (!value2) return false;
      const valueEnum = value2;
      const destVariants = Object.fromEntries(destNode.value);
      if (!(valueEnum.type in destVariants)) {
        return false;
      }
      const variantValue = destVariants[valueEnum.type];
      if (variantValue == null) {
        return true;
      }
      return nextCall(
        valueEnum.value,
        variantValue.type === "inline" ? variantValue.value : getNode(variantValue.value)
      );
    case "option":
      if (value2 == null) {
        return true;
      }
      return nextCall(value2, getNode(destNode.value));
    case "struct":
      if (!value2) return false;
      return destNode.value.every(
        ([key, typeRef]) => nextCall(value2[key], getNode(typeRef))
      );
    case "tuple":
      if (!value2) return false;
      return destNode.value.every(
        (typeRef, idx) => nextCall(value2[idx], getNode(typeRef))
      );
    case "result":
      if (!("success" in value2 && "value" in value2)) return false;
      return nextCall(
        value2.value,
        getNode(value2.success ? destNode.value.ok : destNode.value.ko)
      );
  }
}

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/doubleSet.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, key + "", value2);
var DoubleSet = class {
  constructor(values = []) {
    __publicField(this, "value", /* @__PURE__ */ new Map());
    values.forEach(([a, b]) => this.add(a, b));
  }
  has(a, b) {
    var _a;
    return ((_a = this.value.get(a)) == null ? void 0 : _a.has(b)) ?? false;
  }
  add(a, b) {
    if (!this.value.has(a)) {
      this.value.set(a, /* @__PURE__ */ new Set());
    }
    this.value.get(a).add(b);
  }
  addAll(values) {
    values.forEach(([a, b]) => this.add(a, b));
  }
  delete(a, b) {
    if (!this.value.has(a)) return;
    const set = this.value.get(a);
    set.delete(b);
    if (!set.size) {
      this.value.delete(a);
    }
  }
  isEmpty() {
    return !this.value.size;
  }
  get values() {
    return Array.from(this.value).flatMap(
      ([a, values]) => Array.from(values).map((b) => [a, b])
    );
  }
};

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/isStaticCompatible.mjs
var CompatibilityLevel = ((CompatibilityLevel2) => {
  CompatibilityLevel2[CompatibilityLevel2["Incompatible"] = 0] = "Incompatible";
  CompatibilityLevel2[CompatibilityLevel2["Partial"] = 1] = "Partial";
  CompatibilityLevel2[CompatibilityLevel2["BackwardsCompatible"] = 2] = "BackwardsCompatible";
  CompatibilityLevel2[CompatibilityLevel2["Identical"] = 3] = "Identical";
  return CompatibilityLevel2;
})(CompatibilityLevel || {});
function isStaticCompatible(originNode, getOriginNode, destNode, getDestNode, cache) {
  if (!destNode && !originNode) {
    return unconditional(
      3
      /* Identical */
    );
  }
  if (!destNode) return unconditional(
    2
    /* BackwardsCompatible */
  );
  if (!originNode)
    return unconditional(
      destNode.type === "option" ? 2 : 0
      /* Incompatible */
    );
  if (!cache.has(destNode)) {
    cache.set(destNode, /* @__PURE__ */ new Map());
  }
  const destNodeCache = cache.get(destNode);
  if (destNodeCache.has(originNode)) {
    const result2 = destNodeCache.get(originNode);
    if (result2 === null) {
      return {
        level: 3,
        assumptions: new DoubleSet([[originNode, destNode]])
      };
    }
    return unconditional(result2);
  }
  destNodeCache.set(originNode, null);
  const result = getIsStaticCompatible(
    originNode,
    destNode,
    (originNode2, destNode2) => isStaticCompatible(
      typeof originNode2 === "number" ? getOriginNode(originNode2) : originNode2,
      getOriginNode,
      typeof destNode2 === "number" ? getDestNode(destNode2) : destNode2,
      getDestNode,
      cache
    )
  );
  result.assumptions.delete(originNode, destNode);
  if (result.assumptions.isEmpty() || result.level === 0) {
    destNodeCache.set(originNode, result.level);
  } else {
    destNodeCache.delete(originNode);
  }
  return result;
}
function getIsStaticCompatible(originNode, destNode, nextCall) {
  if (originNode.type !== destNode.type) {
    if (destNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode, destNode.value),
        2
        /* BackwardsCompatible */
      );
    }
    if (originNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode.value, destNode),
        1
        /* Partial */
      );
    }
    return unconditional(
      0
      /* Incompatible */
    );
  }
  switch (destNode.type) {
    case "terminal":
      return unconditional(
        destNode.value.type === originNode.value.type ? 3 : 0
        /* Incompatible */
      );
    case "binary":
      const binaryOrigin = originNode;
      return unconditional(
        compareOptionalLengths(binaryOrigin.value, destNode.value)
      );
    case "array":
      const arrayOrigin = originNode;
      const lengthCheck = unconditional(
        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length)
      );
      return strictMerge([
        lengthCheck,
        () => nextCall(arrayOrigin.value.typeRef, destNode.value.typeRef)
      ]);
    case "enum": {
      const enumOrigin = originNode;
      const destVariants = Object.fromEntries(
        destNode.value.map(([key, value2]) => [key, value2.value])
      );
      const maxLevel2 = enumOrigin.value.length === destNode.value.length ? 3 : 2;
      return withMaxLevel(
        mergeResults(
          enumOrigin.value.map(
            ([type, value2]) => () => type in destVariants ? nextCall(value2.value, destVariants[type]) : unconditional(
              0
              /* Incompatible */
            )
          )
        ),
        maxLevel2
      );
    }
    case "option":
      return nextCall(originNode.value, destNode.value);
    case "struct":
      const structOrigin = originNode;
      const originProperties = Object.fromEntries(structOrigin.value);
      const maxLevel = structOrigin.value.length === destNode.value.length ? 3 : 2;
      return withMaxLevel(
        strictMerge(
          destNode.value.map(
            ([key, value2]) => () => nextCall(originProperties[key], value2)
          )
        ),
        maxLevel
      );
    case "tuple": {
      const tupleOrigin = originNode;
      const lengthCheck2 = unconditional(
        compareArrayLengths(tupleOrigin.value, destNode.value)
      );
      return strictMerge([
        lengthCheck2,
        ...destNode.value.map(
          (value2, idx) => () => nextCall(tupleOrigin.value[idx], value2)
        )
      ]);
    }
    case "result":
      const resultOrigin = originNode;
      return mergeResults([
        nextCall(resultOrigin.value.ok, destNode.value.ok),
        nextCall(resultOrigin.value.ko, destNode.value.ko)
      ]);
  }
}
var withMaxLevel = (result, level) => ({
  ...result,
  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result
  level: Math.min(result.level, level)
});
var noAssumptions = new DoubleSet();
var unconditional = (level) => ({
  level,
  assumptions: noAssumptions
});
var strictMerge = (results) => {
  let merged = unconditional(
    3
    /* Identical */
  );
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level === 0) return result;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return merged;
};
var mergeResults = (results) => {
  if (!results.length) return unconditional(
    3
    /* Identical */
  );
  let hasCompatibles = false;
  let merged = unconditional(
    3
    /* Identical */
  );
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level === 0) {
      merged.level = Math.min(
        merged.level,
        1
        /* Partial */
      );
      continue;
    }
    hasCompatibles = true;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return hasCompatibles ? merged : unconditional(
    0
    /* Incompatible */
  );
};
var compareArrayLengths = (origin, dest) => dest.length === origin.length ? 3 : origin.length >= dest.length ? 2 : 0;
var compareOptionalLengths = (origin, dest) => dest === origin ? 3 : dest == null || origin >= dest ? 2 : origin == null ? 1 : 0;

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/entryPoint.mjs
var EntryPointNodeCodec = Variant({
  lookup: compactNumber,
  typedef: TypedefCodec
});
var lookupNode = (value2) => ({
  type: "lookup",
  value: value2
});
var typedefNode = (value2) => ({
  type: "typedef",
  value: value2
});
var voidEntryPointNode = typedefNode({
  type: "terminal",
  value: { type: Primitive.void }
});
var EntryPointCodec = Struct({
  args: EntryPointNodeCodec,
  values: EntryPointNodeCodec
});
function storageEntryPoint(storageEntry) {
  if (storageEntry.type.tag === "plain")
    return {
      args: voidEntryPointNode,
      values: lookupNode(storageEntry.type.value)
    };
  const { key, value: value2 } = storageEntry.type.value;
  return {
    args: lookupNode(key),
    values: lookupNode(value2)
  };
}
function runtimeCallEntryPoint(entry) {
  return {
    args: typedefNode({
      type: "tuple",
      value: entry.inputs.map((v) => v.type)
    }),
    values: lookupNode(entry.output)
  };
}
function enumValueEntryPointNode(entry) {
  return entry.type === "lookupEntry" ? lookupNode(entry.value.id) : typedefNode(mapLookupToTypedef(entry));
}
function singleValueEntryPoint(value2) {
  return {
    args: voidEntryPointNode,
    values: lookupNode(value2)
  };
}
function entryPointsAreCompatible(descriptorEntry, getDescriptorNode, runtimeEntry, getRuntimeNode, cache) {
  const resolveNode = (node, getTypedef) => node.type === "lookup" ? getTypedef(node.value) : node.value;
  return {
    args: isStaticCompatible(
      resolveNode(descriptorEntry.args, getDescriptorNode),
      getDescriptorNode,
      resolveNode(runtimeEntry.args, getRuntimeNode),
      getRuntimeNode,
      cache
    ).level,
    values: isStaticCompatible(
      resolveNode(runtimeEntry.values, getRuntimeNode),
      getRuntimeNode,
      resolveNode(descriptorEntry.values, getDescriptorNode),
      getDescriptorNode,
      cache
    ).level
  };
}
function valueIsCompatibleWithDest(dest, getDestNode, value2) {
  const node = dest.type === "lookup" ? getDestNode(dest.value) : dest.value;
  return isCompatible(value2, node, getDestNode);
}

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/noop.mjs
var noop3 = () => {
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/methods.mjs
var chainHead = {
  body: "",
  call: "",
  continue: "",
  follow: "",
  header: "",
  stopOperation: "",
  storage: "",
  unfollow: "",
  unpin: "",
  followEvent: ""
};
var chainSpec = {
  chainName: "",
  genesisHash: "",
  properties: ""
};
var transaction = {
  broadcast: "",
  stop: ""
};
Object.entries({ chainHead, chainSpec, transaction }).forEach(
  ([fnGroupName, methods]) => {
    Object.keys(methods).forEach((methodName) => {
      methods[methodName] = `${fnGroupName}_v1_${methodName}`;
    });
  }
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/transaction/transaction.mjs
var getTransaction = (request) => (tx, error) => {
  let cancel = request(transaction.broadcast, [tx], {
    onSuccess: (subscriptionId) => {
      cancel = subscriptionId === null ? noop3 : () => {
        request(transaction.stop, [subscriptionId]);
      };
      if (subscriptionId === null) {
        error(new Error("Max # of broadcasted transactions has been reached"));
      }
    },
    onError: error
  });
  return () => {
    cancel();
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/errors.mjs
var StopError = class extends Error {
  constructor() {
    super("ChainHead stopped");
    this.name = "StopError";
  }
};
var DisjointError = class extends Error {
  constructor() {
    super("ChainHead disjointed");
    this.name = "DisjointError";
  }
};
var OperationLimitError = class extends Error {
  constructor() {
    super("ChainHead operations limit reached");
    this.name = "OperationLimitError";
  }
};
var OperationError = class extends Error {
  constructor(error) {
    super(error);
    this.name = "OperationError";
  }
};
var OperationInaccessibleError = class extends Error {
  constructor() {
    super("ChainHead operation inaccessible");
    this.name = "OperationInaccessibleError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/deferred-promise.mjs
function deferred() {
  let res = () => {
  };
  let rej = () => {
  };
  const promise = new Promise((_res, _rej) => {
    res = _res;
    rej = _rej;
  });
  return { promise, res, rej };
}

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/subscriptions-manager.mjs
var getSubscriptionsManager = () => {
  const subscriptions = /* @__PURE__ */ new Map();
  return {
    has: subscriptions.has.bind(subscriptions),
    subscribe(id, subscriber) {
      subscriptions.set(id, subscriber);
    },
    unsubscribe(id) {
      subscriptions.delete(id);
    },
    next(id, data) {
      var _a;
      (_a = subscriptions.get(id)) == null ? void 0 : _a.next(data);
    },
    error(id, e) {
      const subscriber = subscriptions.get(id);
      if (subscriber) {
        subscriptions.delete(id);
        subscriber.error(e);
      }
    },
    errorAll(e) {
      const subscribers = [...subscriptions.values()];
      subscriptions.clear();
      subscribers.forEach((s) => {
        s.error(e);
      });
    }
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/abortablePromiseFn.mjs
var abortablePromiseFn = (fn) => (...args) => new Promise((res, rej) => {
  let cancel = noop2;
  const [actualArgs, abortSignal] = args[args.length - 1] instanceof AbortSignal ? [args.slice(0, args.length - 1), args[args.length - 1]] : [args];
  const onAbort = () => {
    cancel();
    rej(new AbortError());
  };
  abortSignal == null ? void 0 : abortSignal.addEventListener("abort", onAbort, { once: true });
  const withCleanup = (fn2) => (x) => {
    cancel = noop2;
    abortSignal == null ? void 0 : abortSignal.removeEventListener("abort", onAbort);
    fn2(x);
  };
  cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs]);
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/operation-promise.mjs
var createOperationPromise = (operationName, factory) => (request) => abortablePromiseFn((res, rej, ...args) => {
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  const [requestArgs, logicCb] = factory(...args);
  request(operationName, requestArgs, {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached")
        return rej(new OperationLimitError());
      const { operationId } = response;
      const stopOperation = () => {
        request(chainHead.stopOperation, [operationId]);
      };
      if (!isRunning) return stopOperation();
      let done = noop3;
      const _res = (x) => {
        isRunning = false;
        done();
        res(x);
      };
      const _rej = (x) => {
        isRunning = false;
        done();
        rej(x);
      };
      done = followSubscription(operationId, {
        next: (e) => {
          const _e = e;
          if (_e.event === "operationError")
            rej(new OperationError(_e.error));
          else if (_e.event === "operationInaccessible")
            rej(new OperationInaccessibleError());
          else logicCb(e, _res, _rej);
        },
        error: _rej
      });
      cancel = () => {
        if (isRunning) {
          done();
          stopOperation();
        }
      };
    },
    onError: rej
  });
  return () => {
    cancel();
  };
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/body.mjs
var createBodyFn = createOperationPromise(
  chainHead.body,
  (hash) => [
    [hash],
    (e, res) => {
      res(e.value);
    }
  ]
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/call.mjs
var createCallFn = createOperationPromise(
  chainHead.call,
  (hash, fnName, callParameters) => [
    [hash, fnName, callParameters],
    (e, res) => {
      res(e.output);
    }
  ]
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/header.mjs
var createHeaderFn = (request) => (hash) => new Promise((res, rej) => {
  request(chainHead.header, [hash], {
    onSuccess: res,
    onError: rej
  });
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/storage-subscription.mjs
var createStorageCb = (request) => (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {
  if (inputs.length === 0) {
    onDone();
    return noop2;
  }
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  request(chainHead.storage, [hash, inputs, childTrie], {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached" || response.discardedItems === inputs.length)
        return onError(new OperationLimitError());
      const { operationId } = response;
      const stopOperation = () => {
        request(chainHead.stopOperation, [operationId]);
      };
      if (!isRunning) return stopOperation();
      const doneListening = followSubscription(response.operationId, {
        next: (event) => {
          switch (event.event) {
            case "operationStorageItems": {
              onItems(event.items);
              break;
            }
            case "operationStorageDone": {
              _onDone();
              break;
            }
            case "operationError": {
              _onError(new OperationError(event.error));
              break;
            }
            case "operationInaccessible": {
              _onError(new OperationInaccessibleError());
              break;
            }
            default:
              request(chainHead.continue, [event.operationId]);
          }
        },
        error: onError
      });
      cancel = () => {
        doneListening();
        request(chainHead.stopOperation, [response.operationId]);
      };
      const _onError = (e) => {
        cancel = noop2;
        doneListening();
        onError(e);
      };
      const _onDone = () => {
        cancel = noop2;
        doneListening();
        onDone();
      };
      onDiscardedItems(response.discardedItems);
    },
    onError
  });
  return () => {
    cancel();
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/storage.mjs
var createStorageFn = (request) => {
  const cbStore = createStorageCb(request);
  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {
    const isDescendants = type.startsWith("descendants");
    let result = isDescendants ? [] : null;
    const onItems = isDescendants ? (items) => {
      result.push(items);
    } : (items) => {
      var _a;
      result = (_a = items[0]) == null ? void 0 : _a[type];
    };
    const cancel = cbStore(
      hash,
      [{ key, type }],
      childTrie ?? null,
      onItems,
      reject,
      () => {
        try {
          resolve(isDescendants ? result.flat() : result);
        } catch (e) {
          reject(e);
        }
      },
      (nDiscarded) => {
        if (nDiscarded > 0) {
          cancel();
          reject(new OperationLimitError());
        }
      }
    );
    return cancel;
  });
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/unpin.mjs
var createUnpinFn = (request) => (hashes) => hashes.length > 0 ? new Promise((res, rej) => {
  request(chainHead.unpin, [hashes], {
    onSuccess() {
      res();
    },
    onError: rej
  });
}) : Promise.resolve();

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/client/DestroyedError.mjs
var DestroyedError = class extends Error {
  constructor() {
    super("Client destroyed");
    this.name = "DestroyedError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/chainhead.mjs
function isOperationEvent(event) {
  return event.operationId !== void 0;
}
function getChainHead(request) {
  return (withRuntime, onFollowEvent, onFollowError) => {
    const subscriptions = getSubscriptionsManager();
    const ongoingRequests = /* @__PURE__ */ new Set();
    const deferredFollow = deferred();
    let followSubscription = deferredFollow.promise;
    const onAllFollowEventsNext = (event) => {
      if (isOperationEvent(event)) {
        if (!subscriptions.has(event.operationId))
          console.warn("Uknown operationId on", event);
        return subscriptions.next(event.operationId, event);
      }
      if (event.event !== "stop") {
        if (event.event === "initialized") {
          return onFollowEvent({
            type: event.event,
            finalizedBlockHashes: event.finalizedBlockHashes,
            finalizedBlockRuntime: event.finalizedBlockRuntime
          });
        }
        const { event: type, ...rest } = event;
        return onFollowEvent({ type, ...rest });
      }
      onFollowError(new StopError());
      unfollow(false);
    };
    const onAllFollowEventsError = (error) => {
      onFollowError(error);
      unfollow(!(error instanceof DestroyedError));
    };
    const onFollowRequestSuccess = (subscriptionId, follow) => {
      const done = follow(subscriptionId, {
        next: onAllFollowEventsNext,
        error: onAllFollowEventsError
      });
      unfollow = (sendUnfollow = true) => {
        followSubscription = null;
        unfollow = noop3;
        done();
        sendUnfollow && request(chainHead.unfollow, [subscriptionId]);
        subscriptions.errorAll(new DisjointError());
        ongoingRequests.forEach((cb) => {
          cb();
        });
        ongoingRequests.clear();
      };
      followSubscription = subscriptionId;
      deferredFollow.res(subscriptionId);
    };
    const onFollowRequestError = (e) => {
      if (e instanceof DestroyedError) {
        unfollow(false);
      } else {
        onFollowError(e);
      }
      followSubscription = null;
      deferredFollow.res(e);
    };
    let unfollow = request(
      chainHead.follow,
      [withRuntime],
      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError }
    );
    const fRequest = (method, params, cb) => {
      const disjoint = () => {
        cb == null ? void 0 : cb.onError(new DisjointError());
      };
      if (followSubscription === null) {
        disjoint();
        return noop3;
      }
      const onSubscription = (subscription) => {
        if (!cb) return request(method, [subscription, ...params]);
        ongoingRequests.add(disjoint);
        const onSubscribeOperation = (operationId, subscriber) => {
          if (followSubscription === null) {
            subscriber.error(new DisjointError());
            return noop3;
          }
          subscriptions.subscribe(operationId, subscriber);
          return () => {
            subscriptions.unsubscribe(operationId);
          };
        };
        const cleanup = request(method, [subscription, ...params], {
          onSuccess: (response) => {
            ongoingRequests.delete(disjoint);
            cb.onSuccess(response, onSubscribeOperation);
          },
          onError: (e) => {
            ongoingRequests.delete(disjoint);
            cb.onError(e);
          }
        });
        return () => {
          ongoingRequests.delete(disjoint);
          cleanup();
        };
      };
      if (typeof followSubscription === "string")
        return onSubscription(followSubscription);
      let onCancel = noop3;
      followSubscription.then((x) => {
        if (x instanceof Error) return disjoint();
        if (followSubscription) onCancel = onSubscription(x);
      });
      return () => {
        onCancel();
      };
    };
    return {
      unfollow() {
        unfollow();
        followSubscription = null;
      },
      body: createBodyFn(fRequest),
      call: createCallFn(fRequest),
      header: createHeaderFn(fRequest),
      storage: createStorageFn(fRequest),
      storageSubscription: createStorageCb(fRequest),
      unpin: createUnpinFn(fRequest),
      _request: fRequest
    };
  };
}

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/client/RpcError.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField2 = (obj, key, value2) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value2);
var RpcError = class extends Error {
  constructor(e) {
    super(e.message);
    __publicField2(this, "code");
    __publicField2(this, "data");
    this.code = e.code;
    this.data = e.data;
    this.name = "RpcError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/client/createClient.mjs
var nextClientId = 1;
var createClient = (gProvider) => {
  let clientId = nextClientId++;
  const responses = /* @__PURE__ */ new Map();
  const subscriptions = getSubscriptionsManager();
  let connection = null;
  const send = (id, method, params) => {
    connection.send(
      JSON.stringify({
        jsonrpc: "2.0",
        id,
        method,
        params
      })
    );
  };
  function onMessage(message) {
    try {
      let id, result, error, params, subscription;
      const parsed = JSON.parse(message);
      ({ id, result, error, params } = parsed);
      if (id) {
        const cb = responses.get(id);
        if (!cb) return;
        responses.delete(id);
        return error ? cb.onError(new RpcError(error)) : cb.onSuccess(result, (opaqueId, subscriber) => {
          const subscriptionId2 = opaqueId;
          subscriptions.subscribe(subscriptionId2, subscriber);
          return () => {
            subscriptions.unsubscribe(subscriptionId2);
          };
        });
      }
      ;
      ({ subscription, result, error } = params);
      if (!subscription || !error && !Object.hasOwn(params, "result")) throw 0;
      const subscriptionId = subscription;
      if (error) {
        subscriptions.error(subscriptionId, new RpcError(error));
      } else {
        subscriptions.next(subscriptionId, result);
      }
    } catch (e) {
      console.warn("Error parsing incomming message: " + message);
      console.error(e);
    }
  }
  connection = gProvider(onMessage);
  const disconnect = () => {
    connection == null ? void 0 : connection.disconnect();
    connection = null;
    subscriptions.errorAll(new DestroyedError());
    responses.forEach((r) => r.onError(new DestroyedError()));
    responses.clear();
  };
  let nextId = 1;
  const request = (method, params, cb) => {
    if (!connection) throw new Error("Not connected");
    const id = `${clientId}-${nextId++}`;
    if (cb) responses.set(id, cb);
    send(id, method, params);
    return () => {
      responses.delete(id);
    };
  };
  return {
    request,
    disconnect
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainspec.mjs
var createGetChainSpec = (clientRequest) => {
  const request = abortablePromiseFn(
    (onSuccess, onError, method, params) => clientRequest(method, params, { onSuccess, onError })
  );
  let cachedPromise = null;
  return async () => {
    if (cachedPromise) return cachedPromise;
    return cachedPromise = Promise.all([
      request(chainSpec.chainName, []),
      request(chainSpec.genesisHash, []),
      request(chainSpec.properties, [])
    ]).then(([name, genesisHash, properties]) => ({
      name,
      genesisHash,
      properties
    }));
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/index.mjs
var clientCache = /* @__PURE__ */ new Map();
var createClient2 = (provider) => {
  const cached = clientCache.get(provider);
  if (cached) {
    cached.refCount++;
    return cached.client;
  }
  const { request, disconnect } = createClient(provider);
  const destroy = () => {
    const cached2 = clientCache.get(provider);
    if (!cached2 || cached2.refCount <= 1) {
      clientCache.delete(provider);
      disconnect();
    } else {
      cached2.refCount--;
    }
  };
  const client = {
    chainHead: getChainHead(request),
    transaction: getTransaction(request),
    getChainSpecData: createGetChainSpec(request),
    destroy,
    request: abortablePromiseFn(
      (onSuccess, onError, method, params) => request(method, params, { onSuccess, onError })
    ),
    _request: request
  };
  clientCache.set(provider, { client, refCount: 1 });
  return client;
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/operationLimitRecovery.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value2) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField3 = (obj, key, value2) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value2);
var PendingTaskQueue = class {
  constructor() {
    __publicField3(this, "first");
    __publicField3(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value2) {
    const newNode = { value: value2 };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value2) {
    this.first = { value: value2, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    var _a, _b;
    const result = (_a = this.first) == null ? void 0 : _a.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        (_b = this.first.prev) == null ? true : delete _b.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
};
var getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    var _a;
    (_a = tearDownOperations.get(observable)) == null ? void 0 : _a();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data) return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    let isOperationLimit = false;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        (isOperationLimit = e instanceof OperationLimitError) ? addTask(data, true) : observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    if (!subscription.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
        onEmptySlot();
      });
    } else if (!isOperationLimit) onEmptySlot();
  };
  const withRecovery = (topPriority = false) => (source$) => new Observable((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/errors.mjs
var BlockNotPinnedError = class extends Error {
  constructor(hash, label) {
    super(`Block ${hash} is not pinned (${label})`);
    this.name = "BlockNotPinnedError";
  }
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/optionalHash.mjs
var dynamicBlocks = /* @__PURE__ */ new Set(["best", "finalized", null]);
var operable = (source$) => {
  const result = source$.pipe(
    catchError(
      (e) => e instanceof OperationInaccessibleError ? timer(750).pipe(concatMap(() => result)) : throwError(() => e)
    )
  );
  return result;
};
var getWithOptionalhash$ = (finalized$, best$, usingBlock) => {
  return (fn) => (hash, ...args) => {
    if (!dynamicBlocks.has(hash))
      return operable(fn(hash, ...args)).pipe(
        usingBlock(hash)
      );
    const hash$ = hash === "best" ? best$ : finalized$;
    const result$ = hash$.pipe(
      take(1),
      mergeMap((h) => fn(h, ...args).pipe(usingBlock(h))),
      catchError((e) => {
        return e instanceof BlockNotPinnedError ? result$ : throwError(() => e);
      })
    );
    return operable(result$);
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/fromAbortControllerFn.mjs
var fromAbortControllerFn = (fn) => (...args) => new Observable((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value2) => {
      observer.next(value2);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/lazyFollower.mjs
var withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/withStopRecovery.mjs
function withStopRecovery(blocks$, fn, label) {
  return (hash, ...args) => {
    const source$ = fn(hash, ...args);
    return new Observable((observer) => {
      let sourceSub = null;
      let isSubscribed = false;
      const performSourceSub = () => {
        if (isSubscribed) return;
        isSubscribed = true;
        sourceSub = source$.subscribe({
          next: (v) => observer.next(v),
          error: (e) => observer.error(e),
          complete: () => observer.complete()
        });
        sourceSub.add(() => {
          isSubscribed = false;
          sourceSub = null;
        });
      };
      let isRecovering = false;
      const blockSub = blocks$.subscribe({
        next: (v) => {
          const block = v.blocks.get(hash);
          if (!block) {
            if (isRecovering) {
              observer.error(new BlockNotPinnedError(hash, label));
            }
          } else if (block.recovering) {
            sourceSub == null ? void 0 : sourceSub.unsubscribe();
          } else {
            performSourceSub();
          }
          isRecovering = v.recovering;
        },
        error: (e) => observer.error(e)
      });
      return () => {
        blockSub.unsubscribe();
        sourceSub == null ? void 0 : sourceSub.unsubscribe();
      };
    });
  };
}

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/new-blocks.mjs
var getNewBlocks$ = (pinnedBlocks$) => pinnedBlocks$.pipe(
  scan(
    ({ reportedBlocks: prevReportedBlocks }, { blocks }) => {
      const reportedBlocks = new Set(blocks.keys());
      const newBlocks = [];
      if (reportedBlocks.size > prevReportedBlocks.size) {
        blocks.forEach(({ hash, number, parent }) => {
          if (!prevReportedBlocks.has(hash)) {
            newBlocks.push({
              hash,
              number,
              parent
            });
          }
        });
      }
      return { reportedBlocks, newBlocks };
    },
    {
      reportedBlocks: /* @__PURE__ */ new Set(),
      newBlocks: new Array(0)
    }
  ),
  mergeMap(({ newBlocks }) => newBlocks),
  share()
);

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/storage-queries.mjs
var getRecoveralStorage$ = (getFollower, withRecovery) => {
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new Observable(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        if (nDiscarded > 0)
          observer.next(
            recoveralStorage$(
              hash,
              queries.slice(-nDiscarded),
              childTrie,
              true
            )
          );
      }
    )
  ).pipe(mergeAll(), withRecovery(isHighPriority));
  return recoveralStorage$;
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/follow.mjs
var withInitializedNumber = (getHeader) => (source$) => new Observable((observer) => {
  let pending = null;
  return source$.subscribe({
    next(event) {
      if (event.type === "initialized") {
        pending = [];
        getHeader(event.finalizedBlockHashes[0]).then((header) => {
          if (!observer.closed) {
            observer.next({
              ...event,
              number: header.number,
              parentHash: header.parentHash
            });
            pending.forEach((e) => {
              observer.next(e);
            });
            pending = null;
          }
        }).catch((e) => {
          if (!observer.closed) observer.error(e);
        });
      } else if (pending) pending.push(event);
      else observer.next(event);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
});
var getFollow$ = (chainHead2) => {
  let follower = null;
  let unfollow = noop;
  const getFollower = () => {
    if (!follower) throw new Error("Missing chainHead subscription");
    return follower;
  };
  const getHeader = (hash) => getFollower().header(hash).then(blockHeader.dec);
  const follow$ = connectable(
    new Observable((observer) => {
      follower = chainHead2(
        true,
        (e) => {
          observer.next(e);
        },
        (e) => {
          follower = null;
          observer.error(e);
        }
      );
      unfollow = () => {
        observer.complete();
        follower == null ? void 0 : follower.unfollow();
      };
    }).pipe(withInitializedNumber(getHeader), retryChainHeadError())
  );
  const startFollow = () => {
    follow$.connect();
    return () => {
      unfollow();
    };
  };
  return {
    getHeader,
    getFollower,
    startFollow,
    follow$
  };
};
var retryChainHeadError = () => (source$) => new Observable((observer) => {
  const subscription = new Subscription();
  const subscribe = () => source$.subscribe({
    next: (v) => observer.next(v),
    error: (e) => {
      subscription.add(subscribe());
      if (e instanceof StopError) {
        observer.next({ type: "stop-error" });
      } else {
        console.warn("ChainHead follow request failed, retryingâ€¦", e);
      }
    },
    complete: () => observer.complete()
  });
  subscription.add(subscribe());
  return subscription;
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/get-runtime-creator.mjs
var versionedArgs = (v) => toHex(u32.enc(v));
var opaqueBytes = Bytes();
var optionalOpaqueBytes = Option(opaqueBytes);
var u32ListDecoder = Vector(u32).dec;
var getRuntimeCreator = (call$, getCodeHash$, getCachedMetadata, setCachedMetadata) => {
  const getMetadata$ = (getHash) => {
    const withRecovery = (fn) => {
      const result = (...args) => {
        const hash = getHash();
        return hash ? fn(hash, ...args).pipe(
          catchError((e) => {
            if (e instanceof BlockNotPinnedError) return result(...args);
            if (e instanceof OperationInaccessibleError)
              return timer(750).pipe(mergeMap(() => result(...args)));
            throw e;
          })
        ) : EMPTY;
      };
      return result;
    };
    const recoverCall$ = withRecovery(call$);
    const recoverCodeHash$ = withRecovery(getCodeHash$);
    const versions$ = recoverCall$("Metadata_metadata_versions", "").pipe(
      map(u32ListDecoder),
      catchError(() => of([14]))
    );
    const versioned$ = (availableVersions) => {
      const [v] = availableVersions.filter((x) => x > 13 && x < 17).sort((a, b) => b - a);
      return v === 14 ? recoverCall$("Metadata_metadata", "").pipe(map(opaqueBytes.dec)) : recoverCall$("Metadata_metadata_at_version", versionedArgs(v)).pipe(
        map((x) => optionalOpaqueBytes.dec(x))
      );
    };
    const metadataRaw$ = versions$.pipe(mergeMap(versioned$));
    return recoverCodeHash$().pipe(
      mergeMap(
        (codeHash) => getCachedMetadata(codeHash).pipe(
          catchError(() => of(null)),
          mergeMap(
            (metadataRaw) => metadataRaw ? of(metadataRaw) : metadataRaw$.pipe(
              tap((raw) => {
                setCachedMetadata(codeHash, raw);
              })
            )
          ),
          map((metadataRaw) => ({
            codeHash,
            metadataRaw,
            metadata: unifyMetadata(metadata.dec(metadataRaw))
          }))
        )
      )
    );
  };
  return (getHash) => {
    const initialHash = getHash();
    const usages = /* @__PURE__ */ new Set([initialHash]);
    const runtimeContext$ = getMetadata$(
      getHash
    ).pipe(
      map(({ metadata: metadata2, metadataRaw, codeHash }) => {
        const lookup = getLookupFn(metadata2);
        const dynamicBuilder = getDynamicBuilder(lookup);
        const events = dynamicBuilder.buildStorage("System", "Events");
        const assetPayment = metadata2.extrinsic.signedExtensions.find(
          (x) => x.identifier === "ChargeAssetTxPayment"
        );
        let assetId = null;
        if (assetPayment) {
          const assetTxPayment = lookup(assetPayment.type);
          if (assetTxPayment.type === "struct") {
            const optionalAssetId = assetTxPayment.value.asset_id;
            if (optionalAssetId.type === "option")
              assetId = optionalAssetId.value.id;
          }
        }
        return {
          assetId,
          metadataRaw,
          codeHash,
          lookup,
          dynamicBuilder,
          events: {
            key: events.keys.enc(),
            dec: events.value.dec
          },
          accountId: AccountId(dynamicBuilder.ss58Prefix)
        };
      }),
      shareReplay(1)
    );
    const result = {
      at: initialHash,
      runtime: runtimeContext$,
      addBlock: (block) => {
        usages.add(block);
        return result;
      },
      deleteBlocks: (blocks) => {
        blocks.forEach((block) => {
          usages.delete(block);
        });
        return usages.size;
      },
      usages
    };
    runtimeContext$.subscribe({
      error() {
      }
    });
    return result;
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/shareLatest.mjs
var shareLatest = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/pinned-blocks.mjs
var createRuntimeGetter = (pinned, startAt) => {
  return () => {
    const runtime = pinned.runtimes[startAt];
    if (!runtime) return pinned.blocks.has(startAt) ? startAt : null;
    const winner = [...runtime.usages].at(-1);
    return winner ?? null;
  };
};
var deleteBlock = (blocks, blockHash) => {
  var _a;
  (_a = blocks.get(blocks.get(blockHash).parent)) == null ? void 0 : _a.children.delete(blockHash);
  blocks.delete(blockHash);
};
var deleteBlocks = (blocks, toDelete) => {
  toDelete.forEach((hash) => {
    deleteBlock(blocks.blocks, hash);
  });
  Object.entries(blocks.runtimes).map(([key, value2]) => ({
    key,
    usages: value2.deleteBlocks(toDelete)
  })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unusedRuntime) => {
    delete blocks.runtimes[unusedRuntime];
  });
};
var getPinnedBlocks$ = (follow$, call$, getCodeHash$, getCachedMetadata$, setCachedMetadata, blockUsage$, onUnpin, deleteFromCache) => {
  const cleanup$ = new Subject();
  const cleanupEvt$ = cleanup$.pipe(
    exhaustMap(() => timer(0)),
    map(
      () => ({
        type: "cleanup"
      })
    )
  );
  const pinnedBlocks$ = merge(
    blockUsage$,
    cleanupEvt$,
    follow$
  ).pipe(
    scan((acc, event) => {
      const unpinAndDelete = (toUnpin) => {
        deleteBlocks(acc, toUnpin);
        onUnpin(toUnpin);
      };
      switch (event.type) {
        case "initialized":
          if (acc.recovering) {
            const isConnected = event.finalizedBlockHashes.some(
              (hash) => acc.blocks.has(hash)
            );
            if (!isConnected) {
              acc = getInitialPinnedBlocks();
            }
          }
          const [finalizedHash] = event.finalizedBlockHashes.slice(-1);
          acc.finalized = acc.best = finalizedHash;
          const lastIdx = event.finalizedBlockHashes.length - 1;
          event.finalizedBlockHashes.forEach((hash, i) => {
            const preexistingBlock = acc.blocks.get(hash);
            if (preexistingBlock) {
              preexistingBlock.recovering = false;
              preexistingBlock.unpinnable = i !== lastIdx;
            } else {
              acc.blocks.set(hash, {
                hash,
                parent: i === 0 ? event.parentHash : event.finalizedBlockHashes[i - 1],
                children: new Set(
                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]]
                ),
                unpinnable: i !== lastIdx,
                runtime: hash,
                refCount: 0,
                number: event.number + i,
                recovering: false
              });
            }
          });
          const finalizedRuntime = Object.values(acc.runtimes).find(
            (runtime) => runtime.usages.has(finalizedHash)
          );
          acc.finalizedRuntime = finalizedRuntime ?? (acc.runtimes[finalizedHash] = getRuntime(
            createRuntimeGetter(acc, finalizedHash)
          ));
          return acc;
        case "stop-error":
          for (const block of acc.blocks.values()) {
            block.recovering = true;
          }
          acc.recovering = true;
          return acc;
        case "newBlock": {
          const { parentBlockHash: parent, blockHash: hash } = event;
          if (acc.blocks.has(hash)) {
            acc.blocks.get(hash).recovering = false;
          } else {
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash);
            const block = {
              hash,
              number: parentNode.number + 1,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: event.newRuntime ? hash : parentNode.runtime,
              unpinnable: false,
              refCount: 0,
              recovering: false
            };
            acc.blocks.set(hash, block);
            if (event.newRuntime) {
              acc.runtimes[hash] = getRuntime(createRuntimeGetter(acc, hash));
            }
            acc.runtimes[block.runtime].addBlock(hash);
          }
          return acc;
        }
        case "bestBlockChanged": {
          if (acc.recovering) {
            for (const [hash, block] of acc.blocks) {
              if (block.recovering) {
                deleteBlock(acc.blocks, hash);
                deleteFromCache(hash);
              }
            }
            acc.recovering = false;
          }
          acc.best = event.bestBlockHash;
          return acc;
        }
        case "finalized": {
          acc.finalized = event.finalizedBlockHashes.slice(-1)[0];
          const { blocks } = acc;
          if (blocks.get(acc.best).number < blocks.get(acc.finalized).number)
            acc.best = acc.finalized;
          acc.finalizedRuntime = acc.runtimes[blocks.get(acc.finalized).runtime];
          event.prunedBlockHashes.forEach((hash) => {
            const block = acc.blocks.get(hash);
            if (block) {
              block.unpinnable = true;
            }
          });
          let current = blocks.get(blocks.get(acc.finalized).parent);
          while (current && !current.unpinnable) {
            current.unpinnable = true;
            current = blocks.get(current.parent);
          }
          cleanup$.next();
          return acc;
        }
        case "cleanup": {
          const toUnpin = [...acc.blocks.values()].filter(({ unpinnable, refCount }) => unpinnable && !refCount).map(({ hash }) => hash);
          unpinAndDelete(toUnpin);
          return acc;
        }
        case "blockUsage": {
          if (!acc.blocks.has(event.value.hash)) return acc;
          const block = acc.blocks.get(event.value.hash);
          block.refCount += event.value.type === "hold" ? 1 : -1;
          if (block.refCount === 0 && !block.recovering && block.unpinnable) {
            const toUnpin = [block.hash];
            unpinAndDelete(toUnpin);
          }
          return acc;
        }
      }
    }, getInitialPinnedBlocks()),
    filter((x) => !!x.finalizedRuntime.runtime),
    map((x) => ({ ...x })),
    shareLatest
  );
  const getRuntime = getRuntimeCreator(
    withStopRecovery(pinnedBlocks$, call$, "pinned-blocks"),
    withStopRecovery(pinnedBlocks$, getCodeHash$, "pinned-blocks"),
    getCachedMetadata$,
    setCachedMetadata
  );
  return pinnedBlocks$;
};
var getInitialPinnedBlocks = () => ({
  best: "",
  finalized: "",
  runtimes: {},
  blocks: /* @__PURE__ */ new Map(),
  finalizedRuntime: {},
  recovering: false
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/track-tx.mjs
var getTrackTx = (blocks$, getBody, getIsValid, getEvents) => {
  const whileBlockPresent = (hash) => takeUntil(blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))));
  const analyzeBlock = (hash, tx, alreadyPresent) => {
    if (alreadyPresent)
      return of({ hash, found: { type: false, validity: null } });
    const whilePresent = whileBlockPresent(hash);
    return getBody(hash).pipe(
      mergeMap((txs) => {
        const index = txs.indexOf(tx);
        return index > -1 ? whilePresent(getEvents(hash)).pipe(
          map((events) => ({
            hash,
            found: {
              type: true,
              index,
              events
            }
          }))
        ) : getIsValid(hash, tx).pipe(
          map((validity) => ({
            hash,
            found: { type: false, validity }
          }))
        );
      }),
      whilePresent
    );
  };
  const findInBranch = (hash, tx, alreadyPresent) => analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(
    mergeMap((analyzed) => {
      var _a;
      const { found } = analyzed;
      return found.type || ((_a = found.validity) == null ? void 0 : _a.success) === false ? of(analyzed) : blocks$.pipe(
        whileBlockPresent(hash),
        mergeMap((x) => x.blocks.get(hash).children),
        distinct(),
        mergeMap((hash2) => findInBranch(hash2, tx, alreadyPresent))
      );
    })
  );
  return (tx) => blocks$.pipe(
    take(1),
    mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys())))
  );
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/validate-tx.mjs
var external = new Uint8Array([2]);
var getValidateTxArgs = (tx, hash) => toHex(mergeUint8(external, fromHex(tx), fromHex(hash)));
var TaggedTransactionQueue = "TaggedTransactionQueue";
var validateTransaction = "validate_transaction";
var [, defaultInvalidTxDecoder] = Variant({
  InvalidTransaction: Variant({
    Call: _void,
    Payment: _void,
    Future: _void,
    Stale: _void,
    BadProof: _void,
    AncientBirthBlock: _void,
    ExhaustsResources: _void,
    Custom: u8,
    BadMandatory: _void,
    MandatoryValidation: _void,
    BadSigner: _void
  }),
  UnknownTransaction: Variant({
    CannotLookup: _void,
    NoUnsignedValidator: _void,
    Custom: u8
  })
});
var defaultValidateTxDecoder = createDecoder((input) => {
  const firstByte = u8.dec(input);
  if (firstByte > 1)
    throw new Error("Unable to decode validateTransaction result");
  if (!firstByte) return { success: true, value: void 0 };
  let value2;
  try {
    value2 = defaultInvalidTxDecoder(input);
  } catch (_) {
    value2 = {
      type: "UnknownInvalidTx"
    };
  }
  return { success: false, value: value2 };
});
var getValidateTx = (call$, getRuntimeContext) => (blockHash, tx) => {
  const decoder$ = getRuntimeContext(blockHash).pipe(
    map((ctx) => {
      try {
        return ctx.dynamicBuilder.buildRuntimeCall(
          TaggedTransactionQueue,
          validateTransaction
        ).value[1];
      } catch (_) {
        return defaultValidateTxDecoder;
      }
    })
  );
  return call$(
    blockHash,
    `${TaggedTransactionQueue}_${validateTransaction}`,
    getValidateTxArgs(tx, blockHash)
  ).pipe(
    withLatestFrom(decoder$),
    map(([result, decoder]) => decoder(result))
  );
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/with-default-value.mjs
var withDefaultValue = (defaultValue) => (source$) => new Observable((observer) => {
  let hasEmited = false;
  const subscription = source$.subscribe({
    next(v) {
      hasEmited = true;
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  if (!hasEmited) observer.next(defaultValue);
  return subscription;
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/delay-unsubscription.mjs
var delayUnsubscription = (ms) => (source) => new Observable((observer) => {
  const subscription = source.subscribe({
    next(v) {
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  const unsubscribe = () => subscription.unsubscribe();
  return () => {
    Promise.resolve().then(unsubscribe);
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/concatMapEager.mjs
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new Observable((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    let isCompleted = false;
    let subscription = inner$.subscribe({
      next(x) {
        if (observerIdx === idx) {
          observer.next(x);
        } else {
          results.get(idx).push(x);
        }
      },
      complete() {
        isCompleted = true;
        innerSubscriptions.delete(idx);
        if (idx === observerIdx) {
          observerIdx++;
          while (results.has(observerIdx)) {
            results.get(observerIdx).forEach((x) => observer.next(x));
            results.delete(observerIdx);
            if (innerSubscriptions.has(observerIdx)) {
              break;
            }
            observerIdx++;
          }
        }
        nextSubscription();
      },
      error(e) {
        observer.error(e);
      }
    });
    if (!isCompleted) innerSubscriptions.set(idx, subscription);
  };
  topSubscription = new Subscription();
  topSubscription.add(
    source$.subscribe({
      next(outterValue) {
        const idx = mapperIdx++;
        queues.set(
          idx,
          defer(() => mapper(outterValue, idx))
        );
        if (innerSubscriptions.size < concurrent) {
          nextSubscription();
        }
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        if (innerSubscriptions.size === 0) {
          observer.complete();
        }
      }
    })
  );
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/chainHead.mjs
var toBlockInfo = ({ hash, number, parent }) => ({
  hash,
  number,
  parent
});
var getChainHead$ = (chainHead2, getCachedMetadata, setCachedMetadata) => {
  const { getFollower, startFollow, follow$, getHeader } = getFollow$(chainHead2);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new Subject();
  const holdBlock = (hash) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    return () => {
      setTimeout(() => {
        blockUsage$.next({
          type: "blockUsage",
          value: { type: "release", hash }
        });
      }, 0);
    };
  };
  const usingBlock = (blockHash) => (base) => new Observable((observer) => {
    const release = holdBlock(blockHash);
    const subscription = base.subscribe(observer);
    subscription.add(release);
    return subscription;
  });
  const withRefcount = (fn) => (hash, ...args) => fn(hash, ...args).pipe(usingBlock(hash));
  const withInMemory = (fn, label) => (hash, ...args) => new Observable((observer) => {
    let isPresent = false;
    pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {
      isPresent = blocks.blocks.has(hash);
    });
    return isPresent ? fn(hash, ...args).subscribe(observer) : observer.error(new BlockNotPinnedError(hash, label));
  });
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof DisjointError) return;
    throw e;
  });
  const commonEnhancer = (fn, label) => withInMemory(
    withRefcount(
      withStopRecovery(
        pinnedBlocks$,
        withRecoveryFn(fromAbortControllerFn(fn)),
        `stop-${label}`
      )
    ),
    label
  );
  const cache = /* @__PURE__ */ new Map();
  const stg = withRefcount(
    withRecoveryFn(fromAbortControllerFn(lazyFollower("storage")))
  );
  const getCodeHash = (blockHash) => (
    // ":code" => "0x3a636f6465"
    stg(blockHash, "hash", "0x3a636f6465", null).pipe(map((x) => x))
  );
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))),
    getCodeHash,
    getCachedMetadata,
    setCachedMetadata,
    blockUsage$,
    (blocks) => {
      unpin(blocks);
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    },
    (block) => {
      cache.delete(block);
    }
  );
  const getRuntimeContext$ = withRefcount(
    (hash) => pinnedBlocks$.pipe(
      take(1),
      mergeMap(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      )
    )
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const hashCache = cache.get(hash) ?? /* @__PURE__ */ new Map();
    const cached = hashCache.get(key);
    if (cached) return cached;
    cache.set(hash, hashCache);
    let connector;
    const result = stream.pipe(
      share({
        connector: () => connector = new ReplaySubject()
      }),
      tap({
        complete() {
          hashCache.set(key, connector);
        }
      }),
      delayUnsubscription()
    );
    hashCache.set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    filter((x) => !x.recovering),
    distinctUntilChanged((a, b) => a.finalized === b.finalized),
    scan((acc, value2) => {
      let current = value2.blocks.get(value2.finalized);
      const result = [current];
      const latest = acc.at(-1);
      if (!latest) return result;
      while (current.number > latest.number + 1) {
        current = value2.blocks.get(current.parent);
        if (!current) break;
        result.unshift(current);
      }
      return result;
    }, []),
    mergeAll(),
    map(toBlockInfo),
    shareLatest
  );
  const best$ = pinnedBlocks$.pipe(
    distinctUntilChanged((a, b) => a.best === b.best),
    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    filter((x) => !x.recovering),
    distinctUntilChanged(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    scan((acc, pinned) => {
      const getBlockInfo = (hash) => acc.get(hash) || toBlockInfo(pinned.blocks.get(hash));
      const best = getBlockInfo(pinned.best);
      const finalized = getBlockInfo(pinned.finalized);
      const len = best.number - finalized.number + 1;
      const result = new Array(len);
      for (let i = 0, hash = best.hash; i < len; i++) {
        result[i] = getBlockInfo(hash);
        hash = result[i].parent;
      }
      return new Map(result.map((b) => [b.hash, b]));
    }, /* @__PURE__ */ new Map()),
    map((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    switchMap(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(map((x) => (x == null ? void 0 : x.lookup.metadata) ?? null));
  const withOptionalHash$ = getWithOptionalhash$(
    finalized$.pipe(map((b) => b.hash)),
    best$.pipe(map((b) => b.hash)),
    usingBlock
  );
  const _body$ = withOptionalHash$(commonEnhancer(lazyFollower("body"), "body"));
  const body$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const _storage$ = commonEnhancer(lazyFollower("storage"), "storage");
  const storage$ = withOptionalHash$(
    (hash, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.pipe(
      take(1),
      mergeMap(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      ),
      mergeMap((ctx) => {
        const key = keyMapper(ctx);
        const unMapped$ = upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}`,
          _storage$(hash, type, key, childTrie)
        );
        return mapper ? upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}-dec`,
          unMapped$.pipe(
            map((raw) => ({ raw, mapped: mapper(raw, ctx) }))
          )
        ) : unMapped$;
      })
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOptionalHash$(
    withStopRecovery(
      pinnedBlocks$,
      (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false),
      `storageQueries`
    )
  );
  const header$ = withOptionalHash$(
    withStopRecovery(
      pinnedBlocks$,
      (hash) => defer(() => getHeader(hash)),
      "header"
    )
  );
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  ).pipe(map((x) => x.mapped));
  const __call$ = commonEnhancer(lazyFollower("call"), "call");
  const call$ = withOptionalHash$(
    (hash, fn, args) => upsertCachedStream(hash, `call-${fn}-${args}`, __call$(hash, fn, args))
  );
  const validateTx$ = getValidateTx(call$, getRuntimeContext$);
  const innerBody$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$);
  const trackTxWithoutEvents$ = getTrackTx(
    pinnedBlocks$,
    innerBody$,
    validateTx$,
    () => of()
  );
  const genesis$ = runtime$.pipe(
    filter(Boolean),
    take(1),
    mergeMap((runtime) => {
      const { enc } = runtime.dynamicBuilder.buildStorage(
        "System",
        "BlockHash"
      ).keys;
      let key;
      try {
        key = enc(0);
      } catch {
        key = enc(0n);
      }
      return storage$(null, "value", () => key, null);
    }),
    shareReplay(1)
  );
  merge(runtime$, bestBlocks$).subscribe({
    error() {
    }
  });
  let unfollow = noop;
  let started = false;
  let nSubscribers = 0;
  const start = (_nSubscribers) => {
    nSubscribers += _nSubscribers;
    started = true;
    unfollow = startFollow();
  };
  return [
    {
      follow$,
      finalized$,
      best$,
      bestBlocks$,
      newBlocks$: getNewBlocks$(pinnedBlocks$),
      runtime$,
      metadata$,
      genesis$,
      header$,
      body$,
      call$,
      storage$,
      storageQueries$,
      eventsAt$,
      holdBlock,
      trackTx$,
      trackTxWithoutEvents$,
      validateTx$,
      pinnedBlocks$,
      withRuntime,
      getRuntimeContext$: withOptionalHash$(getRuntimeContext$),
      unfollow: () => {
        if (started == null) return;
        nSubscribers--;
        if (started && !nSubscribers) {
          started = null;
          unfollow();
          unfollow = noop;
        }
      }
    },
    start
  ];
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/tx.mjs
var getBroadcastTx$ = (baseTransaction) => (transaction2) => new Observable(
  (observer) => baseTransaction(transaction2, (e) => {
    observer.error(e);
  })
);

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/getObservableClient.mjs
var ofNullFn = () => of(null);
var clientCache2 = /* @__PURE__ */ new Map();
var getObservableClient = (substrateClient, cache = {}) => {
  const { getMetadata, setMetadata } = cache;
  const cached = clientCache2.get(substrateClient);
  if (cached) {
    cached.refCount++;
    return cached.client;
  }
  const destroy = () => {
    const cached2 = clientCache2.get(substrateClient);
    if (!cached2 || cached2.refCount <= 1) {
      clientCache2.delete(substrateClient);
      substrateClient.destroy();
    } else {
      cached2.refCount--;
    }
  };
  let cachedChainhead = null;
  let currentSubscribers = 0;
  let expectedSubscribers = null;
  const client = {
    chainHead$: (_expectedSubscribers) => {
      currentSubscribers++;
      expectedSubscribers || (expectedSubscribers = _expectedSubscribers || 1);
      cachedChainhead || (cachedChainhead = getChainHead$(
        substrateClient.chainHead,
        getMetadata || ofNullFn,
        setMetadata || noop
      ));
      const [result, start] = cachedChainhead;
      if (expectedSubscribers === currentSubscribers) {
        const copiedCurrentSubscribers = currentSubscribers;
        currentSubscribers = 0;
        expectedSubscribers = null;
        cachedChainhead = null;
        start(copiedCurrentSubscribers);
      }
      return result;
    },
    broadcastTx$: getBroadcastTx$(substrateClient.transaction),
    destroy
  };
  clientCache2.set(substrateClient, { client, refCount: 1 });
  return client;
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/block-operations.mjs
var isBestOrFinalizedBlock = (blocks$, blockHash) => blocks$.pipe(
  takeWhile((b) => b.blocks.has(blockHash)),
  distinctUntilChanged(
    (a, b) => a.finalized === b.finalized && a.best === b.best
  ),
  map((pinned) => {
    if (pinned.blocks.get(blockHash).number > pinned.blocks.get(pinned.best).number)
      return null;
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.best);
    let isFinalized = pinned.finalized === current.hash;
    while (current.number > number) {
      current = pinned.blocks.get(current.parent);
      isFinalized = isFinalized || pinned.finalized === current.hash;
    }
    if (isFinalized) return "finalized";
    return current.hash === blockHash ? "best" : null;
  }),
  distinctUntilChanged(),
  takeWhile((x) => x !== "finalized", true)
);

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/compatibility.mjs
var RuntimeToken = class {
  constructor() {
  }
  // @ts-ignore
  _runtime(value2) {
  }
};
var CompatibilityToken = class {
  constructor() {
  }
  // @ts-ignore
  _compatibility(value2) {
  }
};
var compatibilityTokenApi = /* @__PURE__ */ new WeakMap();
var runtimeTokenApi = /* @__PURE__ */ new WeakMap();
var getCompatibilityApi = (token) => token instanceof RuntimeToken ? runtimeTokenApi.get(token) : compatibilityTokenApi.get(token);
var OpType = ((OpType2) => {
  OpType2["Storage"] = "storage";
  OpType2["Tx"] = "tx";
  OpType2["Event"] = "events";
  OpType2["Const"] = "constants";
  OpType2["ViewFns"] = "viewFns";
  OpType2["Api"] = "apis";
  return OpType2;
})(OpType || {});
var EntryPointsCodec = Vector(EntryPointCodec);
var TypedefsCodec = Vector(TypedefCodec);
var TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec);
var createCompatibilityToken = (chainDefinition, chainHead2) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead2.runtime$.pipe(filter((v) => v != null));
    let latest = await firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = Promise.all([
    chainDefinition.metadataTypes.then(TypesCodec.dec),
    chainDefinition.descriptors,
    awaitedRuntime
  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {
    const token = new CompatibilityToken();
    compatibilityTokenApi.set(token, {
      runtime,
      getEntryPoint(opType, pallet, name) {
        var _a, _b;
        const idx = (_b = (_a = descriptors[opType]) == null ? void 0 : _a[pallet]) == null ? void 0 : _b[name];
        if (idx == null)
          throw new Error(
            `Descriptor for ${opType} ${pallet}.${name} does not exist`
          );
        return entryPoints[idx];
      },
      typedefNodes
    });
    return token;
  });
  return promise;
};
var createRuntimeToken = (chainHead2) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead2.runtime$.pipe(filter((v) => v != null));
    let latest = await firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = awaitedRuntime.then((runtime) => {
    const token = new RuntimeToken();
    runtimeTokenApi.set(token, {
      runtime
    });
    return token;
  });
  return promise;
};
var metadataCache = /* @__PURE__ */ new WeakMap();
var getMetadataCache = (ctx) => {
  if (!metadataCache.has(ctx.metadataRaw)) {
    metadataCache.set(ctx.metadataRaw, {
      compat: /* @__PURE__ */ new Map(),
      lookup: ctx.lookup,
      typeNodes: []
    });
  }
  return metadataCache.get(ctx.metadataRaw);
};
var compatibilityHelper = (descriptors, getDescriptorEntryPoint, getRuntimeEntryPoint) => {
  const getRuntimeTypedef = (ctx, id) => {
    var _a;
    const cache = getMetadataCache(ctx);
    return (_a = cache.typeNodes)[id] || (_a[id] = mapLookupToTypedef(cache.lookup(id)));
  };
  function getCompatibilityLevels(descriptors2, ctx) {
    if (descriptors2 instanceof RuntimeToken) {
      return {
        args: CompatibilityLevel.Identical,
        values: CompatibilityLevel.Identical
      };
    }
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    ctx || (ctx = compatibilityApi.runtime());
    const runtimeEntryPoint = getRuntimeEntryPoint(ctx);
    if (runtimeEntryPoint == null)
      return {
        args: CompatibilityLevel.Incompatible,
        values: CompatibilityLevel.Incompatible
      };
    const descriptorNodes = compatibilityApi.typedefNodes;
    const cache = getMetadataCache(ctx);
    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi);
    return entryPointsAreCompatible(
      descriptorEntryPoint,
      (id) => descriptorNodes[id],
      runtimeEntryPoint,
      (id) => getRuntimeTypedef(ctx, id),
      cache.compat
    );
  }
  const getCompatibilityLevel = withOptionalToken(
    descriptors,
    (runtime) => minCompatLevel(getCompatibilityLevels(runtime))
  );
  const isCompatible2 = withOptionalToken(
    descriptors,
    (threshold, runtime) => getCompatibilityLevel(runtime) >= threshold
  );
  const compatibleRuntime$ = (chainHead2, hash) => combineLatest([descriptors, chainHead2.getRuntimeContext$(hash)]);
  const withCompatibleRuntime = (chainHead2, mapper) => (source$) => combineLatest([
    source$.pipe(chainHead2.withRuntime(mapper)),
    descriptors
  ]).pipe(map(([[x, ctx], descriptors2]) => [x, descriptors2, ctx]));
  const argsAreCompatible = (descriptors2, ctx, args) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const levels = getCompatibilityLevels(descriptors2, ctx);
    if (levels.args === CompatibilityLevel.Incompatible) return false;
    if (levels.args > CompatibilityLevel.Partial) return true;
    if (levels.values === CompatibilityLevel.Incompatible) return false;
    const entryPoint = getRuntimeEntryPoint(ctx);
    if (entryPoint == null) return false;
    return valueIsCompatibleWithDest(
      entryPoint.args,
      (id) => getRuntimeTypedef(ctx, id),
      args
    );
  };
  const valuesAreCompatible = (descriptors2, ctx, values) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const level = getCompatibilityLevels(descriptors2, ctx).values;
    if (level === CompatibilityLevel.Incompatible) return false;
    if (level > CompatibilityLevel.Partial) return true;
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    const entryPoint = getDescriptorEntryPoint(compatibilityApi);
    return valueIsCompatibleWithDest(
      entryPoint.values,
      (id) => compatibilityApi.typedefNodes[id],
      values
    );
  };
  return {
    isCompatible: isCompatible2,
    getCompatibilityLevel,
    getCompatibilityLevels,
    descriptors,
    withCompatibleRuntime,
    compatibleRuntime$,
    argsAreCompatible,
    valuesAreCompatible,
    getRuntimeTypedef
  };
};
var minCompatLevel = (levels) => Math.min(levels.args, levels.values);
var withOptionalToken = (compatibilityToken, fn) => (...args) => {
  const lastElement = args.at(-1);
  if (lastElement instanceof CompatibilityToken || lastElement instanceof RuntimeToken) {
    return fn(...args);
  }
  return compatibilityToken.then((token) => fn(...args, token));
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/constants.mjs
var createConstantEntry = (palletName, name, {
  valuesAreCompatible,
  descriptors,
  isCompatible: isCompatible2,
  getCompatibilityLevel
}) => {
  const cachedResults = /* @__PURE__ */ new WeakMap();
  const getValueWithContext = (ctx) => {
    if (cachedResults.has(ctx)) {
      return cachedResults.get(ctx);
    }
    const pallet = ctx.lookup.metadata.pallets.find(
      (p) => p.name === palletName
    );
    const constant = pallet == null ? void 0 : pallet.constants.find((c) => c.name === name);
    if (constant == null)
      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`);
    const result = ctx.dynamicBuilder.buildConstant(palletName, name).dec(constant.value);
    cachedResults.set(ctx, result);
    return result;
  };
  const fn = (token) => {
    if (token) {
      const ctx = getCompatibilityApi(token).runtime();
      const value2 = getValueWithContext(ctx);
      if (!valuesAreCompatible(token, ctx, value2))
        throw new Error(
          `Incompatible runtime entry Constant(${palletName}.${name})`
        );
      return value2;
    }
    return descriptors.then(fn);
  };
  return Object.assign(fn, { isCompatible: isCompatible2, getCompatibilityLevel });
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/shareLatest.mjs
var shareLatest2 = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/event.mjs
var createEventEntry = (pallet, name, chainHead2, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  withCompatibleRuntime,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  const shared$ = chainHead2.finalized$.pipe(
    withCompatibleRuntime(chainHead2, (x) => x.hash),
    map(([block, runtime, ctx]) => {
      var _a, _b;
      const eventsIdx = (_b = (_a = ctx.lookup.metadata.pallets.find(
        (p) => p.name === pallet
      )) == null ? void 0 : _a.events) == null ? void 0 : _b.type;
      if (eventsIdx == null || ctx.lookup.metadata.lookup[eventsIdx].def.tag !== "variant" || ctx.lookup.metadata.lookup[eventsIdx].def.value.find(
        (ev) => ev.name === name
      ) == null)
        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`);
      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError();
      return [block, runtime, ctx];
    }),
    concatMapEager(
      ([block, runtime, ctx]) => chainHead2.eventsAt$(block.hash).pipe(
        map((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))
              throw compatibilityError();
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      )
    ),
    shareLatest2
  );
  const watch = (f) => shared$.pipe(mergeMap((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => firstValueFrom(shared$);
  const filter2 = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter: filter2, getCompatibilityLevel, isCompatible: isCompatible2 };
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/firstValueFromWithSignal.mjs
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    let subscription = null;
    let isDone = false;
    const onAbort = signal ? () => {
      subscription == null ? void 0 : subscription.unsubscribe();
      reject(new AbortError());
    } : noop;
    subscription = source.subscribe({
      next: (value2) => {
        resolve(value2);
        subscription == null ? void 0 : subscription.unsubscribe();
        isDone = true;
      },
      error: (e) => {
        signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        reject(e);
        isDone = true;
      },
      complete: () => {
        signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        reject(new Error("Observable completed without emitting"));
        isDone = true;
      }
    });
    if (!isDone) signal == null ? void 0 : signal.addEventListener("abort", onAbort);
  });
}

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/optional-arg.mjs
var isOptionalArg = (lastArg) => typeof lastArg === "object" && lastArg !== null && Object.entries(lastArg).every(
  ([k, v]) => k === "at" && (v === void 0 || typeof v === "string") || k === "signal" && (v === void 0 || v instanceof AbortSignal)
);

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/runtime-call.mjs
var createRuntimeCallEntry = (api, method, chainHead2, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const callName = `${api}_${method}`;
  const compatibilityError = () => new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead2, at).pipe(
      mergeMap(([runtime, ctx]) => {
        let codecs;
        try {
          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        } catch {
          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        return chainHead2.call$(at, callName, toHex(codecs.args.enc(args))).pipe(
          map(codecs.value.dec),
          map((value2) => {
            if (!valuesAreCompatible(runtime, ctx, value2))
              throw compatibilityError();
            return value2;
          })
        );
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible: isCompatible2 });
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/lossLessExhaustMap.mjs
var EMPTY_VALUE = Symbol("EMPTY_VALUE");
var lossLessExhaustMap = (mapper) => (source$) => new Observable((observer) => {
  let idx = 0;
  let innerSubscription = null;
  let queuedValue = EMPTY_VALUE;
  let isOutterDone = false;
  const setInnerSubscription = () => {
    const observable = mapper(queuedValue, idx++);
    queuedValue = EMPTY_VALUE;
    innerSubscription = observable.subscribe({
      next(vv) {
        observer.next(vv);
      },
      error(ee) {
        observer.error(ee);
      },
      complete() {
        if (queuedValue !== EMPTY_VALUE) setInnerSubscription();
        else {
          innerSubscription = null;
          if (isOutterDone) observer.complete();
        }
      }
    });
  };
  const subscription = source$.subscribe({
    next(v) {
      queuedValue = v;
      if (!innerSubscription) setInnerSubscription();
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (!innerSubscription) observer.complete();
      isOutterDone = true;
    }
  });
  return () => {
    innerSubscription == null ? void 0 : innerSubscription.unsubscribe();
    subscription.unsubscribe();
  };
});

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/storage.mjs
var toMapped = map((x) => x.mapped);
var createStorageEntry = (pallet, name, chainHead2, getWatchEntries, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  getCompatibilityLevels,
  descriptors: descriptorsPromise,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const isBlockHash = pallet === "System" && name === "BlockHash";
  const sysNumberMapper$ = chainHead2.runtime$.pipe(
    filter(Boolean),
    take(1),
    map(
      ({ dynamicBuilder }) => typeof dynamicBuilder.buildStorage("System", "Number").value.dec(new Uint8Array(32)) === "bigint" ? BigInt : identity
    ),
    shareReplay()
  );
  const bigIntOrNumber = pipe(
    combineLatestWith(sysNumberMapper$),
    map(([input, mapper]) => mapper(input))
  );
  const incompatibleError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const getCodec = (ctx) => {
    try {
      return ctx.dynamicBuilder.buildStorage(pallet, name);
    } catch (e) {
      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`);
    }
  };
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const isBest = target === "best";
    const actualArgs = isBest || target === "finalized" ? args.slice(0, -1) : args;
    return chainHead2[isBest ? "best$" : "finalized$"].pipe(
      lossLessExhaustMap(
        () => getRawValue$(...actualArgs, isBest ? { at: "best" } : {})
      ),
      distinctUntilChanged((a, b) => a.raw === b.raw),
      toMapped
    );
  };
  const getRawValue$ = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    if (isSystemNumber)
      return chainHead2.pinnedBlocks$.pipe(
        map((blocks) => {
          const hash = at === "finalized" || !at ? blocks.finalized : at === "best" ? blocks.best : at;
          const block = blocks.blocks.get(hash);
          if (!block) {
            throw new BlockNotPinnedError(hash, "System.Number");
          }
          return block.number;
        }),
        distinctUntilChanged(),
        bigIntOrNumber,
        map((mapped) => ({ raw: mapped, mapped }))
      );
    if (isBlockHash && Number(args[0]) === 0) {
      return chainHead2.genesis$.pipe(
        map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) }))
      );
    }
    return from(descriptorsPromise).pipe(
      mergeMap(
        (descriptors) => chainHead2.storage$(
          at,
          "value",
          (ctx) => {
            const codecs = getCodec(ctx);
            const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
            if (args !== actualArgs && !isLastArgOptional)
              throw invalidArgs(args);
            if (!argsAreCompatible(descriptors, ctx, actualArgs))
              throw incompatibleError();
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (data, ctx) => {
            const codecs = getCodec(ctx);
            const value2 = data === null ? codecs.fallback : codecs.value.dec(data);
            if (!valuesAreCompatible(descriptors, ctx, value2))
              throw incompatibleError();
            return value2;
          }
        )
      )
    );
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal } = isLastArgOptional ? lastArg : {};
    return firstValueFromWithSignal(
      getRawValue$(...args).pipe(toMapped),
      signal
    );
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const descriptors = await descriptorsPromise;
    const result$ = chainHead2.storage$(
      at,
      "descendantsValues",
      (ctx) => {
        const codecs = getCodec(ctx);
        if (minCompatLevel(getCompatibilityLevels(descriptors, ctx)) === CompatibilityLevel.Incompatible)
          throw incompatibleError();
        if (args.length > codecs.len) throw invalidArgs(args);
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs(args);
        return codecs.keys.enc(...actualArgs);
      },
      null,
      (values, ctx) => {
        const codecs = getCodec(ctx);
        const decodedValues = values.map(({ key, value: value2 }) => ({
          keyArgs: codecs.keys.dec(key),
          value: codecs.value.dec(value2)
        }));
        if (decodedValues.some(
          ({ value: value2 }) => !valuesAreCompatible(descriptors, ctx, value2)
        ))
          throw incompatibleError();
        return decodedValues;
      }
    ).pipe(toMapped);
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  const watchEntries = (...args) => {
    const lastArg = args.at(-1);
    const isLastArgOptional = isOptionalArg(lastArg);
    return getWatchEntries(
      pallet,
      name,
      isLastArgOptional ? args.slice(0, -1) : args,
      isLastArgOptional && lastArg.at === "best"
    );
  };
  return {
    isCompatible: isCompatible2,
    getCompatibilityLevel,
    getValue,
    getValues,
    getEntries,
    watchValue,
    watchEntries
  };
};

// node_modules/.pnpm/@polkadot-api+signer@0.2.1/node_modules/@polkadot-api/signer/dist/esm/from-raw-signer.mjs
function getPolkadotSigner(publicKey, signingType, sign) {
  const signTx = async (callData, signedExtensions, metadata2, _, hasher = Blake2256) => {
    const decMeta = unifyMetadata(decAnyMetadata(metadata2));
    const extra = [];
    const additionalSigned2 = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed extension`);
      extra.push(signedExtension.value);
      additionalSigned2.push(signedExtension.additionalSigned);
    });
    const toSign = mergeUint8(callData, ...extra, ...additionalSigned2);
    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign);
    return createV4Tx(decMeta, publicKey, signed, extra, callData, signingType);
  };
  return {
    publicKey,
    signTx,
    signBytes: getSignBytes(sign)
  };
}
var oneU8 = Uint8Array.from([1]);

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/system-version.mjs
var getSystemVersionStruct = (lookupFn, dynamicBuilder) => {
  const constant = lookupFn.metadata.pallets.find((x) => x.name === "System").constants.find((s) => s.name === "Version");
  const systemVersion = lookupFn(constant.type);
  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec;
  if (systemVersion.type !== "struct") throw new Error("not a struct");
  return systemVersionDec(constant.value);
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/mortal-enc.mjs
function trailingZeroes(n) {
  let i = 0;
  while (!(n & 1)) {
    i++;
    n >>= 1;
  }
  return i;
}
var nextPower = (n) => 1 << Math.ceil(Math.log2(n));
var mortal = enhanceEncoder(
  Bytes(2)[0],
  (value2) => {
    const period = Math.min(Math.max(nextPower(value2.period), 4), 1 << 16);
    const phase = value2.startAtBlock % period;
    const factor = Math.max(period >> 12, 1);
    const left = Math.min(Math.max(trailingZeroes(period) - 1, 1), 15);
    const right = phase / factor << 4;
    return u16[0](left | right);
  }
);

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/charge-asset-tx-enc.mjs
var [ChargeAssetTxPaymentEnc] = Struct({
  tip: compact,
  asset: Option(Bytes(Infinity))
});

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/sign-extensions.mjs
var empty = new Uint8Array();
var zero = Uint8Array.from([0]);
var value = (value2) => ({
  value: value2,
  additionalSigned: empty
});
var additionalSigned = (additionalSigned2) => ({
  value: empty,
  additionalSigned: additionalSigned2
});
var both = (value2, additionalSigned2) => ({
  value: value2,
  additionalSigned: additionalSigned2
});
var getSignExtensionsCreator = (genesis, lookupFn, dynamicBuilder) => {
  const signedExtensionsEncoders = {};
  lookupFn.metadata.extrinsic.signedExtensions.forEach(
    ({ identifier, type, additionalSigned: additionalSigned2 }) => {
      signedExtensionsEncoders[identifier] = [type, additionalSigned2].map(
        (x) => dynamicBuilder.buildDefinition(x)[0]
      );
    }
  );
  return ({
    mortality,
    tip = 0n,
    nonce,
    customSignedExtensions = {},
    ...rest
  }) => {
    const invalidKeys = [];
    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder);
    const getFromCustomEntry = (key) => {
      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key];
      const customEntry = customSignedExtensions[key];
      try {
        return mapObject(
          {
            value: valueEnc,
            additionalSigned: additionalEnc
          },
          (encoder, key2) => {
            const input = customEntry == null ? void 0 : customEntry[key2];
            return input instanceof Uint8Array ? input : encoder(input);
          }
        );
      } catch {
        invalidKeys.push(key);
        return null;
      }
    };
    const result = mapObject(
      signedExtensionsEncoders,
      ([valueEnc, additionalEnc], key) => {
        if (customSignedExtensions[key]) return getFromCustomEntry(key);
        switch (key) {
          case "CheckNonce":
            return value(valueEnc(nonce));
          case "CheckMortality":
            return mortality.mortal ? both(
              mortal({
                period: mortality.period,
                startAtBlock: mortality.startAtBlock.height
              }),
              fromHex(mortality.startAtBlock.hash)
            ) : both(zero, genesis);
          case "ChargeTransactionPayment":
            return value(valueEnc(tip));
          case "ChargeAssetTxPayment":
            return value(
              ChargeAssetTxPaymentEnc({
                tip,
                asset: rest.asset
              })
            );
          case "CheckGenesis":
            return additionalSigned(genesis);
          case "CheckMetadataHash":
            return both(zero, zero);
          case "CheckSpecVersion":
            return additionalSigned(
              additionalEnc(systemVersion["spec_version"])
            );
          case "CheckTxVersion":
            return additionalSigned(
              additionalEnc(systemVersion["transaction_version"])
            );
          default:
            return getFromCustomEntry(key);
        }
      }
    );
    invalidKeys.forEach((key) => {
      delete result[key];
    });
    return mapObject(result, (x, identifier) => ({ ...x, identifier }));
  };
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/create-tx.mjs
var NONCE_RUNTIME_CALL = "AccountNonceApi_account_nonce";
var lenToDecoder = {
  1: u8.dec,
  2: u16.dec,
  4: u32.dec,
  8: u64.dec
};
var getNonceAtBlock$ = (call$, from2, at) => call$(at, NONCE_RUNTIME_CALL, from2).pipe(
  map((result) => {
    const bytes = fromHex(result);
    const decoder = lenToDecoder[bytes.length];
    if (!decoder)
      throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`);
    return decoder(bytes);
  })
);
var createTx = (chainHead2, signer, callData, atBlock, customSignedExtensions, hinted = {}) => combineLatest([
  hinted.nonce ? of(hinted.nonce) : getNonce$(chainHead2, toHex(signer.publicKey)),
  chainHead2.getRuntimeContext$(atBlock.hash),
  chainHead2.genesis$
]).pipe(
  take(1),
  mergeMap(([nonce, ctx, genesis]) => {
    const signExtCreator = getSignExtensionsCreator(
      fromHex(genesis),
      ctx.lookup,
      ctx.dynamicBuilder
    );
    const mortality = hinted.mortality ?? { period: 64, mortal: true };
    const signExtensions = signExtCreator({
      nonce,
      tip: hinted.tip ?? 0n,
      mortality: mortality.mortal ? {
        mortal: true,
        period: mortality.period,
        startAtBlock: {
          height: atBlock.number,
          hash: atBlock.hash
        }
      } : { mortal: false },
      customSignedExtensions,
      asset: hinted.asset
    });
    return signer.signTx(
      callData,
      signExtensions,
      ctx.metadataRaw,
      atBlock.number
    );
  })
);
var getNonce$ = (chainHead2, from2) => {
  const followHead$ = (head) => chainHead2.newBlocks$.pipe(
    scan((acc, block) => block.parent === acc ? block.hash : acc, head),
    startWith(head),
    distinctUntilChanged()
  );
  const followNonce$ = (head) => followHead$(head).pipe(
    take(2),
    switchMap((hash) => getNonceAtBlock$(chainHead2.call$, from2, hash))
  );
  const getHeadsNonce$ = (heads) => combineLatest(
    heads.map(
      (head) => followNonce$(head).pipe(
        map((value2) => ({
          success: true,
          value: value2
        })),
        catchError(
          (err) => of({
            success: false,
            value: err
          })
        )
      )
    )
  ).pipe(take(1));
  return chainHead2.pinnedBlocks$.pipe(
    filter((v) => !v.recovering && v.blocks.size > 0),
    take(1),
    map(({ blocks, best }) => {
      const bestBlock = blocks.get(best);
      return [...blocks.values()].filter(
        (v) => !v.unpinnable && v.children.size === 0 && v.number >= bestBlock.number
      ).map((v) => v.hash);
    }),
    switchMap(getHeadsNonce$),
    map((result) => {
      const winner = result.reduce(
        (acc, v) => v.success ? v.value >= (acc ?? 0) ? v.value : acc : acc,
        null
      );
      if (winner == null) {
        throw result[0].value;
      }
      return winner;
    })
  );
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/continue-with.mjs
var NOTIN = {};
var continueWith = (mapper) => (source) => new Observable((observer) => {
  let latestValue = NOTIN;
  let subscription = source.subscribe({
    next(v) {
      observer.next(latestValue = v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (latestValue === NOTIN) observer.complete();
      else subscription = mapper(latestValue).subscribe(observer);
    }
  });
  return () => {
    subscription.unsubscribe();
  };
});

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/submit-fns.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value2) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField4 = (obj, key, value2) => __defNormalProp4(obj, key + "", value2);
var hashFromTx = (tx) => toHex(Blake2256(fromHex(tx)));
var computeState = (analized$, blocks$) => new Observable((observer) => {
  const analyzedBlocks = /* @__PURE__ */ new Map();
  let pinnedBlocks;
  let latestState;
  const computeNextState = () => {
    var _a;
    let current = pinnedBlocks.best;
    let analyzed = analyzedBlocks.get(current);
    let analyzedNumber = pinnedBlocks.blocks.get(current).number;
    while (!analyzed) {
      const block = pinnedBlocks.blocks.get(current);
      if (!block) break;
      analyzed = analyzedBlocks.get(current = block.parent);
      analyzedNumber--;
    }
    if (!analyzed) return;
    const isFinalized = analyzedNumber <= pinnedBlocks.blocks.get(pinnedBlocks.finalized).number;
    const found = analyzed.found.type;
    if (found && (latestState == null ? void 0 : latestState.found) && latestState.hash === analyzed.hash) {
      if (isFinalized) observer.complete();
      return;
    }
    observer.next(
      latestState = analyzed.found.type ? {
        found,
        hash: analyzed.hash,
        number: analyzedNumber,
        index: analyzed.found.index,
        events: analyzed.found.events
      } : {
        found,
        validity: analyzed.found.validity
      }
    );
    if (isFinalized) {
      if (found) observer.complete();
      else if (((_a = analyzed.found.validity) == null ? void 0 : _a.success) === false)
        observer.error(new InvalidTxError(analyzed.found.validity.value));
    }
  };
  const subscription = blocks$.pipe(
    distinctUntilChanged(
      (a, b) => a.finalized === b.finalized && a.best === b.best
    )
  ).subscribe({
    next: (pinned) => {
      pinnedBlocks = pinned;
      if (analyzedBlocks.size === 0) return;
      computeNextState();
    },
    error(e) {
      observer.error(e);
    }
  });
  subscription.add(
    analized$.subscribe({
      next: (block) => {
        analyzedBlocks.set(block.hash, block);
        computeNextState();
      },
      error(e) {
        observer.error(e);
      }
    })
  );
  return subscription;
}).pipe(distinctUntilChanged((a, b) => a === b));
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => ({ ...x.event, topics: x.topics }));
  const lastEvent = events[events.length - 1];
  if (lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicFailed") {
    return {
      ok: false,
      events,
      dispatchError: lastEvent.value.value.dispatch_error
    };
  }
  return { ok: true, events };
};
var InvalidTxError = class extends Error {
  // likely to be a `TransactionValidityError`
  constructor(e) {
    super(
      JSON.stringify(
        e,
        (_, value2) => {
          if (typeof value2 === "bigint") return value2.toString();
          return value2 instanceof Binary ? value2.asHex() : value2;
        },
        2
      )
    );
    __publicField4(this, "error");
    this.name = "InvalidTxError";
    this.error = e;
  }
};
var submit$ = (chainHead2, broadcastTx$, tx, at, emitSign = false) => {
  const txHash = hashFromTx(tx);
  const getTxEvent = (type, rest) => ({
    type,
    txHash,
    ...rest
  });
  const at$ = chainHead2.pinnedBlocks$.pipe(
    take(1),
    map((blocks) => {
      const block = blocks.blocks.get(at);
      return block ? block.hash : blocks.finalized;
    })
  );
  const validate$ = at$.pipe(
    mergeMap(
      (at2) => chainHead2.validateTx$(at2, tx).pipe(
        filter((x) => !x.success),
        map((x) => {
          throw new InvalidTxError(x.value);
        })
      )
    )
  );
  const track$ = new Observable((observer) => {
    const subscription = chainHead2.trackTx$(tx).subscribe(observer);
    subscription.add(
      broadcastTx$(tx).subscribe({
        error(e) {
          observer.error(e);
        }
      })
    );
    return subscription;
  });
  const bestBlockState$ = computeState(track$, chainHead2.pinnedBlocks$).pipe(
    map((x) => {
      var _a;
      if (!x.found)
        return getTxEvent("txBestBlocksState", {
          found: false,
          isValid: ((_a = x.validity) == null ? void 0 : _a.success) !== false
        });
      return getTxEvent("txBestBlocksState", {
        found: true,
        block: {
          index: x.index,
          number: x.number,
          hash: x.hash
        },
        ...getTxSuccessFromSystemEvents(x.events, x.index)
      });
    })
  );
  return concat(
    emitSign ? of(getTxEvent("signed", {})) : EMPTY,
    validate$,
    of(getTxEvent("broadcasted", {})),
    bestBlockState$.pipe(
      continueWith(
        ({ found, type, ...rest }) => found ? of(getTxEvent("finalized", rest)) : EMPTY
      )
    )
  );
};
var submit = async (chainHead2, broadcastTx$, transaction2, at) => lastValueFrom(submit$(chainHead2, broadcastTx$, transaction2, at)).then((x) => {
  if (x.type !== "finalized") throw null;
  const result = { ...x };
  delete result.type;
  return result;
});

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/tx.mjs
var accountIdEnc = AccountId().enc;
var fakeSignature = new Uint8Array(64);
var fakeSignatureEth = new Uint8Array(65);
var getFakeSignature = (isEth) => () => isEth ? fakeSignatureEth : fakeSignature;
var [, queryInfoDecFallback] = Struct({
  weight: Struct({
    ref_time: compactBn,
    proof_size: compactBn
  }),
  class: Variant({
    Normal: _void,
    Operational: _void,
    Mandatory: _void
  }),
  partial_fee: u128
});
var createTxEntry = (pallet, name, chainHead2, broadcast, {
  isCompatible: isCompatibleHelper,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  getRuntimeTypedef
}, checkCompatibility) => {
  const fn = (arg) => {
    const getCallDataWithContext = (runtime, arg2, txOptions = {}) => {
      const ctx = getCompatibilityApi(runtime).runtime();
      const { dynamicBuilder, assetId, lookup } = ctx;
      let codecs;
      try {
        codecs = dynamicBuilder.buildCall(pallet, name);
      } catch {
        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
      }
      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg2))
        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
      let returnOptions = txOptions;
      if (txOptions.asset) {
        if (assetId == null || !isCompatible(
          txOptions.asset,
          mapLookupToTypedef(lookup(assetId)),
          (id) => getRuntimeTypedef(ctx, id)
        ))
          throw new Error(`Incompatible runtime asset`);
        returnOptions = {
          ...txOptions,
          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset)
        };
      }
      const { location, codec } = codecs;
      return {
        callData: Binary.fromBytes(
          mergeUint8(new Uint8Array(location), codec.enc(arg2))
        ),
        options: returnOptions
      };
    };
    const getCallData$ = (arg2, options = {}) => compatibleRuntime$(chainHead2, null).pipe(
      map(([runtime]) => getCallDataWithContext(runtime, arg2, options))
    );
    const getEncodedData = (token) => {
      if (!token)
        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)));
      return getCallDataWithContext(token, arg).callData;
    };
    const sign$ = (from2, { ..._options }, atBlock) => getCallData$(arg, _options).pipe(
      mergeMap(
        ({ callData, options }) => createTx(
          chainHead2,
          from2,
          callData.asBytes(),
          atBlock,
          _options.customSignedExtensions || {},
          options
        )
      )
    );
    const _sign = (from2, { at, ..._options } = {}) => {
      return (!at || at === "finalized" ? chainHead2.finalized$ : at === "best" ? chainHead2.best$ : chainHead2.bestBlocks$.pipe(
        map((x) => x.find((b) => b.hash === at))
      )).pipe(
        take(1),
        mergeMap(
          (atBlock) => atBlock ? sign$(from2, _options, atBlock).pipe(
            map((signed) => ({
              tx: toHex(signed),
              block: atBlock
            }))
          ) : throwError(() => new Error(`Uknown block ${at}`))
        )
      );
    };
    const sign = (from2, options) => firstValueFrom(_sign(from2, options)).then((x) => x.tx);
    const signAndSubmit = (from2, _options) => firstValueFrom(_sign(from2, _options)).then(
      ({ tx, block }) => submit(chainHead2, broadcast, tx, block.hash)
    );
    const signSubmitAndWatch = (from2, _options) => _sign(from2, _options).pipe(
      mergeMap(
        ({ tx, block }) => submit$(chainHead2, broadcast, tx, block.hash, true)
      )
    );
    const getPaymentInfo = async (from2, _options) => {
      if (typeof from2 === "string")
        from2 = from2.startsWith("0x") ? fromHex(from2) : accountIdEnc(from2);
      const isEth = from2.length === 20;
      const fakeSigner = getPolkadotSigner(
        from2,
        isEth ? "Ecdsa" : "Sr25519",
        getFakeSignature(isEth)
      );
      const encoded = fromHex(await sign(fakeSigner, _options));
      const args = toHex(mergeUint8(encoded, u32.enc(encoded.length)));
      const decoder$ = chainHead2.getRuntimeContext$(null).pipe(
        map((ctx) => {
          try {
            return ctx.dynamicBuilder.buildRuntimeCall(
              "TransactionPaymentApi",
              "query_info"
            ).value[1];
          } catch {
            return queryInfoDecFallback;
          }
        })
      );
      const call$ = chainHead2.call$(
        null,
        "TransactionPaymentApi_query_info",
        args
      );
      return firstValueFrom(
        combineLatest([call$, decoder$]).pipe(
          map(([result, decoder]) => decoder(result))
        )
      );
    };
    const getEstimatedFees = async (from2, _options) => (await getPaymentInfo(from2, _options)).partial_fee;
    return {
      getPaymentInfo,
      getEstimatedFees,
      decodedCall: {
        type: pallet,
        value: Enum(name, arg)
      },
      getEncodedData,
      sign,
      signSubmitAndWatch,
      signAndSubmit
    };
  };
  return Object.assign(fn, {
    getCompatibilityLevel,
    isCompatible: isCompatibleHelper
  });
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/self-dependent.mjs
var selfDependent = () => {
  const activeSubject = new BehaviorSubject(
    new Subject()
  );
  return [
    activeSubject.pipe(switchAll()),
    () => tap({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new Subject());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new Subject());
      }
    })
  ];
};

// node_modules/.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/dist/rxstate.core.es2017.js
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value2) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField5 = (obj, key, value2) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var SUSPENSE = Symbol("SUSPENSE");
var StatePromise = class extends Promise {
  constructor(cb) {
    super(cb);
  }
};
var NoSubscribersError = class extends Error {
  constructor() {
    super();
    this.name = "NoSubscribersError";
  }
};
var EmptyObservableError = class extends Error {
  constructor() {
    super();
    this.name = "EmptyObservableError";
  }
};
var EMPTY_VALUE2 = {};
var StateObservable = class extends Observable {
  constructor(source$, defaultValue, teardown = noop) {
    super((subscriber) => {
      const subscriberWithoutComplete = new Subscriber({
        next: subscriber.next.bind(subscriber),
        error: subscriber.error.bind(subscriber),
        complete: noop
      });
      this.refCount++;
      let innerSub;
      subscriber.add(() => {
        var _a;
        this.refCount--;
        innerSub.unsubscribe();
        if (this.refCount === 0) {
          this.currentValue = EMPTY_VALUE2;
          if (this.subscription) {
            this.subscription.unsubscribe();
          }
          teardown();
          (_a = this.subject) == null ? void 0 : _a.complete();
          this.subject = null;
          this.subscription = null;
          if (this.promise) {
            this.promise.rej(new NoSubscribersError());
            this.promise = null;
          }
        }
      });
      if (!this.subject) {
        this.subject = new Subject();
        innerSub = this.subject.subscribe(subscriberWithoutComplete);
        this.subscription = null;
        this.subscription = new Subscriber({
          next: (value2) => {
            if (this.promise && value2 !== SUSPENSE) {
              this.promise.res(value2);
              this.promise = null;
            }
            this.subject.next(this.currentValue = value2);
          },
          error: (err) => {
            var _a;
            this.subscription = null;
            const subject = this.subject;
            this.subject = null;
            this.currentValue = EMPTY_VALUE2;
            const rej = (_a = this.promise) == null ? void 0 : _a.rej;
            if (rej && err === SUSPENSE) {
              this.promise.rej = () => {
                rej(err);
              };
            }
            subject.error(err);
            if (rej && this.promise) {
              this.promise.rej = rej;
            }
          },
          complete: () => {
            this.subscription = null;
            if (this.promise) {
              this.promise.rej(new EmptyObservableError());
              this.promise = null;
            }
            if (this.currentValue !== EMPTY_VALUE2)
              return this.subject.complete();
            if (defaultValue === EMPTY_VALUE2) {
              const subject = this.subject;
              this.subject = null;
              return subject.error(new EmptyObservableError());
            }
            this.subject.next(this.currentValue = defaultValue);
            this.subject.complete();
          }
        });
        source$.subscribe(this.subscription);
        if (defaultValue !== EMPTY_VALUE2 && this.currentValue === EMPTY_VALUE2) {
          this.subject.next(this.currentValue = defaultValue);
        }
      } else {
        innerSub = this.subject.subscribe(subscriberWithoutComplete);
        if (this.currentValue !== EMPTY_VALUE2) {
          subscriber.next(this.currentValue);
        }
      }
    });
    this.defaultValue = defaultValue;
    __publicField5(this, "subject", null);
    __publicField5(this, "subscription", null);
    __publicField5(this, "refCount", 0);
    __publicField5(this, "currentValue", EMPTY_VALUE2);
    __publicField5(this, "promise", null);
    __publicField5(this, "pipeState", (...ops) => {
      const result = super.pipe(...ops);
      return result instanceof StateObservable ? result : new StateObservable(result, EMPTY_VALUE2);
    });
    __publicField5(this, "getRefCount", () => {
      return this.refCount;
    });
    __publicField5(this, "getValue", () => {
      if (this.promise)
        return this.promise.p;
      if (this.currentValue !== EMPTY_VALUE2 && this.currentValue !== SUSPENSE)
        return this.currentValue;
      if (this.defaultValue !== EMPTY_VALUE2)
        return this.defaultValue;
      if (this.refCount === 0)
        throw new NoSubscribersError();
      const promise = new StatePromise((res, rej) => {
        this.promise = { res, rej, p: null };
      });
      this.promise.p = promise;
      return promise;
    });
    __publicField5(this, "getDefaultValue", () => {
      return this.defaultValue;
    });
    if (defaultValue === EMPTY_VALUE2) {
      delete this.getDefaultValue;
    }
  }
};
function cloneProps(internal, external2) {
  external2.getValue = internal.getValue;
  external2.getRefCount = internal.getRefCount;
  external2.pipeState = internal.pipeState;
  if (internal.getDefaultValue) {
    ;
    external2.getDefaultValue = internal.getDefaultValue;
  }
}
function connectFactoryObservable(getObservable, defaultValue) {
  const cache = new NestedMap();
  const getDefaultValue = typeof defaultValue === "function" ? defaultValue : () => defaultValue;
  const getSharedObservables$ = (input) => {
    for (let i = input.length - 1; input[i] === void 0 && i > -1; i--) {
      input.splice(-1);
    }
    const keys = [input.length, ...input];
    const cachedVal = cache.get(keys);
    if (cachedVal !== void 0) {
      return cachedVal;
    }
    const sharedObservable$ = new StateObservable(getObservable(...input), getDefaultValue(...input), () => {
      cache.delete(keys);
    });
    const publicShared$ = new Observable((subscriber) => {
      const inCache = cache.get(keys);
      let source$ = sharedObservable$;
      if (!inCache) {
        cache.set(keys, result);
      } else if (inCache !== publicShared$) {
        source$ = inCache;
        cloneProps(source$, publicShared$);
      }
      return source$.subscribe(subscriber);
    });
    cloneProps(sharedObservable$, publicShared$);
    const result = publicShared$;
    cache.set(keys, result);
    return result;
  };
  return (...input) => getSharedObservables$(input);
}
var NestedMap = class {
  constructor() {
    __publicField5(this, "root");
    this.root = /* @__PURE__ */ new Map();
  }
  get(keys) {
    let current = this.root;
    for (let i = 0; i < keys.length; i++) {
      current = current.get(keys[i]);
      if (!current)
        return void 0;
    }
    return current;
  }
  set(keys, value2) {
    let current = this.root;
    let i;
    for (i = 0; i < keys.length - 1; i++) {
      let nextCurrent = current.get(keys[i]);
      if (!nextCurrent) {
        nextCurrent = /* @__PURE__ */ new Map();
        current.set(keys[i], nextCurrent);
      }
      current = nextCurrent;
    }
    current.set(keys[i], value2);
  }
  delete(keys) {
    const maps = [this.root];
    let current = this.root;
    for (let i = 0; i < keys.length - 1; i++) {
      maps.push(current = current.get(keys[i]));
    }
    let mapIdx = maps.length - 1;
    maps[mapIdx].delete(keys[mapIdx]);
    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {
      maps[mapIdx].delete(keys[mapIdx]);
    }
  }
};
function state(observable, defaultValue) {
  return new StateObservable(observable, defaultValue);
}
var state2 = (...args) => (typeof args[0] === "function" ? connectFactoryObservable : state)(args[0], args.length > 1 ? args[1] : EMPTY_VALUE2);

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/watch-entries.mjs
var getDiff = (_prev, _current, patch) => {
  const current = new Map(_current.map((x) => [x.key, x]));
  const prev = new Map(_prev.map((x) => [x.key, x]));
  const upserted = /* @__PURE__ */ new Map();
  const deleted = [];
  _current.forEach((value2) => {
    const { key } = value2;
    const prevVal = prev.get(key);
    if (!prevVal || prevVal.value !== value2.value)
      upserted.set(key, patch(value2));
  });
  _prev.forEach((x) => {
    if (!current.has(x.key)) deleted.push(x);
  });
  return {
    deltas: {
      deleted,
      upserted: [...upserted.values()]
    },
    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key))
  };
};
var findPrevious = (start, state22, pinned, includeStart = false) => {
  try {
    let target = includeStart ? start : pinned.blocks.get(start).parent;
    while (target && !state22[target]) target = pinned.blocks.get(target).parent;
    if (!target) return null;
    return state22[target];
  } catch {
    return null;
  }
};
var getPatcherFromRuntime = (pallet, entry) => (runtime) => {
  const { keys, value: value2 } = runtime.dynamicBuilder.buildStorage(pallet, entry);
  return (x) => {
    x.dec = {
      value: value2.dec(x.value),
      args: keys.dec(x.key)
    };
    return x;
  };
};
var createWatchEntries = (blocks$, storage, withRuntime) => {
  const getMemoryBlocks$ = state2(
    (pallet, entry, storageKey) => {
      const getPatcher = getPatcherFromRuntime(pallet, entry);
      const getNextMemoryBlock$ = (prev, block) => {
        const isNotCanonical$ = isBestOrFinalizedBlock(
          blocks$,
          block.hash
        ).pipe(
          filter((x) => !x),
          take(1)
        );
        return storage(
          block.hash,
          "closestDescendantMerkleValue",
          () => storageKey
        ).pipe(
          mergeMap((rootHash) => {
            if (rootHash === (prev == null ? void 0 : prev.rootHash))
              return of({
                ...prev,
                block,
                deltas: null,
                prev: prev.block.hash
              });
            return storage(
              block.hash,
              "descendantsValues",
              () => storageKey
            ).pipe(
              withRuntime(() => block.hash),
              map(
                ([entries, runtimeCtx]) => [entries, getPatcher(runtimeCtx)]
              ),
              map(
                ([entries, patcher]) => ({
                  prev: prev && prev.block.hash,
                  rootHash,
                  block,
                  ...getDiff(
                    (prev == null ? void 0 : prev.entries) ?? [],
                    entries,
                    patcher
                  )
                })
              )
            );
          }),
          takeUntil(isNotCanonical$),
          catchError(
            (e) => e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e)
          )
        );
      };
      const initial$ = blocks$.pipe(
        distinctUntilChanged((a, b) => a.finalized === b.finalized),
        lossLessExhaustMap(
          ({ blocks, finalized }) => getNextMemoryBlock$(null, blocks.get(finalized))
        ),
        take(1),
        map(
          (x) => ({
            blocks: { [x.block.hash]: x },
            finalized: x.block.hash
          })
        )
      );
      const [_memoryBlocks$, connectMemoryBlocks] = selfDependent();
      const updates$ = blocks$.pipe(
        distinctUntilChanged((a, b) => a.best === b.best),
        withLatestFrom(_memoryBlocks$),
        lossLessExhaustMap(([pinned, memoryBlocks]) => {
          const { best } = pinned;
          const { blocks } = memoryBlocks;
          let target = !blocks[best] ? best : null;
          if (!target) return EMPTY;
          const previous = findPrevious(target, blocks, pinned);
          if (previous)
            return getNextMemoryBlock$(
              previous,
              pinned.blocks.get(target)
            ).pipe(
              map((x) => {
                blocks[target] = x;
                return memoryBlocks;
              })
            );
          target = pinned.finalized;
          return getNextMemoryBlock$(
            blocks[memoryBlocks.finalized],
            pinned.blocks.get(target)
          ).pipe(
            map((x) => {
              x.prev = null;
              return {
                blocks: { [target]: x },
                finalized: target
              };
            })
          );
        })
      );
      return merge(initial$, updates$).pipe(connectMemoryBlocks());
    }
  );
  const getBestOrFinalized = (isFinalized) => (pallet, entry, storageKey) => {
    const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey);
    const getPatcher = getPatcherFromRuntime(pallet, entry);
    const prop = isFinalized ? "finalized" : "best";
    return combineLatest([
      memoryBlocks$.pipe(delay(0)),
      blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop]))
    ]).pipe(
      map(
        ([state22, blocks]) => findPrevious(blocks[prop], state22.blocks, blocks, true)
      ),
      filter(Boolean),
      distinctUntilChanged(),
      startWith(null),
      pairwise(),
      withLatestFrom(memoryBlocks$),
      withRuntime(([[, _latest]]) => _latest.block.hash),
      map(
        ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) => [
          prevUpdate,
          latest,
          memoryBlocks,
          getPatcher(runtimeCtx)
        ]
      ),
      mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {
        if (!prevUpdate) return [latest];
        let ancestor = latest;
        const updates = [];
        while (ancestor && ancestor.block.number > prevUpdate.block.number) {
          updates.unshift(ancestor);
          ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null;
        }
        if (isFinalized) {
          memoryBlocks.finalized = latest.block.hash;
          if (updates.length) {
            const { blocks } = memoryBlocks;
            Object.keys(blocks).forEach((key) => {
              if (blocks[key].block.number < updates[0].block.number)
                delete blocks[key];
            });
          }
        }
        if (prevUpdate === ancestor) return updates;
        return [
          {
            ...latest,
            ...prevUpdate.rootHash === latest.rootHash ? {
              entries: prevUpdate.entries,
              deltas: null
            } : getDiff(prevUpdate.entries, latest.entries, patcher)
          }
        ];
      })
    );
  };
  const getFinalized$ = state2(getBestOrFinalized(true));
  const getBest$ = state2(getBestOrFinalized(false));
  return (pallet, entry, args, atBest) => {
    const fn = atBest ? getBest$ : getFinalized$;
    const storageKey$ = blocks$.pipe(
      take(1),
      mergeMap(
        (b) => b.runtimes[b.blocks.get(b[atBest ? "best" : "finalized"]).runtime].runtime
      ),
      map(
        (runtime) => runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args)
      )
    );
    return storageKey$.pipe(
      take(1),
      mergeMap((storageKey) => fn(pallet, entry, storageKey)),
      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {
        const actualDeltas = idx > 0 ? deltas : { deleted: [], upserted: entries };
        return {
          block: { hash, number, parent },
          entries: entries.map(toDec),
          deltas: actualDeltas && {
            deleted: actualDeltas.deleted.map(toDec),
            upserted: actualDeltas.upserted.map(toDec)
          }
        };
      })
    );
  };
};
var toDec = (x) => x.dec;

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/viewFns.mjs
var RUNTIME_NAMESPACE = "RuntimeViewFunction";
var RUNTIME_METHOD = "execute_view_function";
var RUNTIME_CALL_NAME = RUNTIME_NAMESPACE + "_" + RUNTIME_METHOD;
var createViewFnEntry = (pallet, entry, chainHead2, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry ViewFn(${pallet}.${entry})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead2, at).pipe(
      mergeMap(([runtime, ctx]) => {
        let apiCodec;
        try {
          apiCodec = ctx.dynamicBuilder.buildRuntimeCall(
            RUNTIME_NAMESPACE,
            RUNTIME_METHOD
          );
        } catch {
          throw new Error(
            `Runtime entry RuntimeCall(${RUNTIME_CALL_NAME}) not found`
          );
        }
        let viewCodec;
        try {
          viewCodec = ctx.dynamicBuilder.buildViewFn(pallet, entry);
        } catch {
          throw new Error(`Runtime entry ViewFn(${pallet}.${entry}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        const viewArgs = viewCodec.args.enc(args);
        const arg = mergeUint8(
          fromHex(
            ctx.lookup.metadata.pallets.find(({ name }) => name === pallet).viewFns.find(({ name }) => name === entry).id
          ),
          compactNumber.enc(viewArgs.length),
          viewArgs
        );
        return chainHead2.call$(at, RUNTIME_CALL_NAME, toHex(arg)).pipe(
          map((v) => {
            try {
              const decoded = apiCodec.value.dec(v);
              if (!("success" in decoded && "value" in decoded) || !("type" in decoded.value) && !("asBytes" in decoded.value))
                throw null;
              return decoded;
            } catch {
              throw new Error(
                `Unexpected RuntimeCall(${RUNTIME_CALL_NAME}) type`
              );
            }
          }),
          map(({ success, value: value2 }) => {
            if (!success) throw new Error(`ViewFn API Error: ${value2.type}`);
            const decoded = viewCodec.value.dec(value2.asBytes());
            if (!valuesAreCompatible(runtime, ctx, decoded))
              throw compatibilityError();
            return decoded;
          })
        );
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible: isCompatible2 });
};

// node_modules/.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/client.mjs
var createApi = (compatibilityToken, chainHead2, broadcast$) => {
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const getPallet = (ctx, name) => ctx.lookup.metadata.pallets.find((p) => p.name === name);
  const getWatchEntries = createWatchEntries(
    chainHead2.pinnedBlocks$,
    chainHead2.storage$,
    chainHead2.withRuntime
  );
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead2,
      getWatchEntries,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Storage, pallet, name),
        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.
        (ctx) => {
          var _a, _b;
          const item = (_b = (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.storage) == null ? void 0 : _b.items.find(
            (s) => s.name === name
          );
          return item == null ? null : storageEntryPoint(item);
        }
      )
    )
  );
  const getEnumEntry = (ctx, side, id, name) => {
    if (id == null) return null;
    const entry = ctx.lookup(id);
    if (entry.type !== "enum") throw new Error("Expected enum");
    if (entry.value[name] == null) return null;
    const node = enumValueEntryPointNode(entry.value[name]);
    return {
      args: side === "args" ? node : voidEntryPointNode,
      values: side === "args" ? voidEntryPointNode : node
    };
  };
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainHead2,
      broadcast$,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Tx, pallet, name),
        (ctx) => {
          var _a, _b;
          return getEnumEntry(ctx, "args", (_b = (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.calls) == null ? void 0 : _b.type, name);
        }
      ),
      true
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead2,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Event, pallet, name),
        (ctx) => {
          var _a, _b;
          return getEnumEntry(
            ctx,
            "values",
            (_b = (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.events) == null ? void 0 : _b.type,
            name
          );
        }
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Const, pallet, name),
        (ctx) => {
          var _a, _b;
          const item = (_b = (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.constants.find(
            (c) => c.name === name
          )) == null ? void 0 : _b.type;
          return item == null ? null : singleValueEntryPoint(item);
        }
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead2,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Api, api, method),
        (ctx) => runtimeCallEntryPoint(
          ctx.lookup.metadata.apis.find((a) => a.name === api).methods.find((m) => m.name === method)
        )
      )
    )
  );
  const view = createProxyPath(
    (pallet, entry) => createViewFnEntry(
      pallet,
      entry,
      chainHead2,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.ViewFns, pallet, entry),
        (ctx) => runtimeCallEntryPoint(
          ctx.lookup.metadata.pallets.find((a) => a.name === pallet).viewFns.find((m) => m.name === entry)
        )
      )
    )
  );
  const _callDataTx = (callData, token) => {
    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime();
    try {
      const decoded = dynamicBuilder.buildDefinition(lookup.call).dec(callData.asBytes());
      const pallet = decoded.type;
      const call = decoded.value.type;
      const args = decoded.value.value;
      return createTxEntry(
        pallet,
        call,
        chainHead2,
        broadcast$,
        compatibilityHelper(
          compatibilityToken,
          (r) => r.getEntryPoint(OpType.Tx, pallet, call),
          (ctx) => {
            var _a, _b;
            return getEnumEntry(
              ctx,
              "args",
              (_b = (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.calls) == null ? void 0 : _b.type,
              call
            );
          }
        ),
        false
      )(args);
    } catch {
      throw new Error("createTx: invalid call data");
    }
  };
  return {
    query,
    txFromCallData: (callData, token) => token ? _callDataTx(callData, token) : compatibilityToken.then((t) => _callDataTx(callData, t)),
    tx,
    event,
    apis,
    constants,
    view
  };
};
function createClient3(provider, { getMetadata, setMetadata } = {}) {
  const rawClient = createClient2(provider);
  const client = getObservableClient(rawClient, {
    getMetadata: getMetadata ? (codeHash) => from(getMetadata(codeHash)) : void 0,
    setMetadata
  });
  const { getChainSpecData } = rawClient;
  const { genesis$, ..._chainHead } = client.chainHead$();
  const chainHead2 = {
    ..._chainHead,
    genesis$: defer(getChainSpecData).pipe(
      map(({ genesisHash }) => genesisHash),
      catchError(() => genesis$),
      shareReplay(1)
    )
  };
  const _request = rawClient.request;
  let runtimeToken;
  const compatibilityToken = /* @__PURE__ */ new WeakMap();
  const getChainToken = (chainDefinition) => {
    const result = compatibilityToken.get(chainDefinition) || createCompatibilityToken(chainDefinition, chainHead2);
    compatibilityToken.set(chainDefinition, result);
    return result;
  };
  const getRuntimeToken = () => runtimeToken ?? (runtimeToken = createRuntimeToken(chainHead2));
  const { broadcastTx$ } = client;
  return {
    getChainSpecData,
    blocks$: chainHead2.newBlocks$,
    finalizedBlock$: chainHead2.finalized$,
    getFinalizedBlock: () => firstValueFrom(chainHead2.finalized$),
    bestBlocks$: chainHead2.bestBlocks$,
    getBestBlocks: () => firstValueFrom(chainHead2.bestBlocks$),
    watchBlockBody: chainHead2.body$,
    getBlockBody: (hash) => firstValueFrom(chainHead2.body$(hash)),
    getBlockHeader: (hash) => firstValueFrom(chainHead2.header$(hash ?? null)),
    submit: (...args) => submit(chainHead2, broadcastTx$, ...args),
    submitAndWatch: (...args) => submit$(chainHead2, broadcastTx$, ...args),
    getTypedApi: (chainDefinition) => {
      const token = getChainToken(chainDefinition);
      return Object.assign(
        createApi(token, chainHead2, broadcastTx$),
        { compatibilityToken: token }
      );
    },
    getUnsafeApi: () => {
      const token = getRuntimeToken();
      return Object.assign(createApi(token, chainHead2, broadcastTx$), {
        runtimeToken: token
      });
    },
    destroy: () => {
      chainHead2.unfollow();
      client.destroy();
    },
    _request
  };
}

export {
  createClient3 as createClient
};
//# sourceMappingURL=chunk-AKNCNGJG.js.map
