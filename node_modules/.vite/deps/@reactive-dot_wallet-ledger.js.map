{
  "version": 3,
  "sources": ["../../.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/errors.ts", "../../.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/storage.ts", "../../.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/symbols.ts", "../../.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/wallets/wallet.ts", "../../.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/wallets/local-wallet.ts", "../../.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/utils/lazy.ts", "../../.pnpm/@reactive-dot+core@0.41.0_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/providers/light-client/provider.ts", "../../.pnpm/@reactive-dot+wallet-ledger@0.16.37_@ledgerhq+hw-transport@6.31.5_polkadot-api@1.12.2_j_4a10adb11d709f105fcc111b1ade258d/node_modules/@reactive-dot/wallet-ledger/src/errors.ts", "../../.pnpm/@reactive-dot+wallet-ledger@0.16.37_@ledgerhq+hw-transport@6.31.5_polkadot-api@1.12.2_j_4a10adb11d709f105fcc111b1ade258d/node_modules/@reactive-dot/wallet-ledger/src/ledger-wallet.ts"],
  "sourcesContent": ["export class BaseError extends Error {\n  static from<T>(error: T, message?: string) {\n    return new this(\n      message ?? (error instanceof Error ? error.message : undefined),\n      { cause: error },\n    );\n  }\n}\n\nexport class QueryError extends BaseError {}\n\nexport class MutationError extends BaseError {}\n\n/**\n * @deprecated Renamed to {@link BaseError}.\n */\nexport const ReactiveDotError = BaseError;\n", "import type { SimpleStorage } from \"./simple-storage.js\";\n\nexport type StorageOptions = {\n  prefix: string;\n  storage: SimpleStorage;\n};\n\nexport class Storage<TKey extends string = string> implements SimpleStorage {\n  readonly prefix: string;\n\n  #storage: SimpleStorage;\n\n  constructor(options: StorageOptions) {\n    this.prefix = options.prefix;\n    this.#storage = options.storage;\n  }\n\n  getItem(key: TKey) {\n    return this.#storage.getItem(this.#prefixKey(key));\n  }\n\n  removeItem(key: TKey) {\n    return this.#storage.removeItem(this.#prefixKey(key));\n  }\n\n  setItem(key: TKey, value: string) {\n    return this.#storage.setItem(this.#prefixKey(key), value);\n  }\n\n  join<TKeyOverride extends string | void = void>(path: string) {\n    return new Storage<TKeyOverride extends void ? TKey : TKeyOverride>({\n      prefix: `${this.prefix}/${path}`,\n      storage: this.#storage,\n    });\n  }\n\n  #prefixKey(key: string) {\n    return `${this.prefix}/${key}`;\n  }\n}\n\nexport const defaultStorage = new Storage({\n  prefix: \"@reactive-dot\",\n  storage: globalThis.localStorage,\n});\n", "export const idle = Symbol(\"idle\");\n\nexport const pending = Symbol(\"pending\");\n", "import { type Storage, defaultStorage } from \"../storage.js\";\nimport type { MaybePromise } from \"../types.js\";\nimport type { PolkadotSignerAccount } from \"./account.js\";\nimport { firstValueFrom, type Observable } from \"rxjs\";\n\nexport type WalletOptions = {\n  storage?: Storage | undefined;\n};\n\nexport abstract class Wallet<\n  TOptions extends WalletOptions = WalletOptions,\n  TStorageKey extends string = string,\n> {\n  abstract readonly id: string;\n\n  abstract readonly name: string;\n\n  readonly #storage: Storage;\n\n  protected get storage() {\n    return this.#storage.join<TStorageKey>(this.id);\n  }\n\n  constructor(protected readonly options?: TOptions | undefined) {\n    this.#storage = (options?.storage ?? defaultStorage).join(\"wallet\");\n  }\n\n  abstract initialize(): MaybePromise<void>;\n\n  abstract readonly connected$: Observable<boolean>;\n\n  abstract connect(): MaybePromise<void>;\n\n  abstract disconnect(): MaybePromise<void>;\n\n  abstract readonly accounts$: Observable<PolkadotSignerAccount[]>;\n\n  getAccounts(): MaybePromise<PolkadotSignerAccount[]> {\n    return firstValueFrom(this.accounts$, { defaultValue: [] });\n  }\n}\n", "import type { MaybePromise } from \"../types.js\";\nimport type { PolkadotSignerAccount } from \"./account.js\";\nimport { Wallet, type WalletOptions } from \"./wallet.js\";\n\n/**\n * @experimental\n */\nexport abstract class LocalWallet<\n  TAccount extends Pick<PolkadotSignerAccount, \"id\">,\n  TOptions extends WalletOptions,\n  TStorageKey extends string,\n> extends Wallet<TOptions, TStorageKey> {\n  /**\n   * @experimental\n   */\n  abstract accountStore: {\n    add(account: TAccount): MaybePromise<void>;\n    clear(): MaybePromise<void>;\n    delete(account: { id: TAccount[\"id\"] }): MaybePromise<void>;\n    delete(accountId: TAccount[\"id\"]): MaybePromise<void>;\n    has(account: { id: TAccount[\"id\"] }): MaybePromise<boolean>;\n    has(accountId: TAccount[\"id\"]): MaybePromise<boolean>;\n    values(): Iterable<TAccount>;\n  };\n}\n", "const empty = Symbol(\"empty\");\n\nexport function lazy<T>(get: () => T) {\n  let value: T | typeof empty = empty;\n\n  return () => {\n    if (value !== empty) {\n      return value;\n    }\n\n    value = get();\n    return value;\n  };\n}\n", "/* eslint-disable no-unexpected-multiline */\nimport { lazy } from \"../../utils/lazy.js\";\nimport {\n  wellknownChains,\n  type WellknownParachainId,\n  type WellknownRelayChainId,\n} from \"./wellknown-chains.js\";\nimport type { getSmoldotExtensionProviders } from \"@substrate/smoldot-discovery\";\nimport { createClient } from \"polkadot-api\";\nimport { getSmProvider } from \"polkadot-api/sm-provider\";\nimport type { JsonRpcProvider } from \"polkadot-api/ws-provider/web\";\n\nconst getProviderSymbol = Symbol(\"getProvider\");\n\nexport type LightClientProvider = {\n  [getProviderSymbol]: () => JsonRpcProvider;\n};\n\ntype AddChainOptions<TWellknownChainId> =\n  | { chainSpec: string }\n  | { id: TWellknownChainId };\n\ntype LightClientOptions = {\n  /**\n   * Connect to the first available {@link https://github.com/paritytech/substrate-connect | Substrate Connect} provider.\n   */\n  useExtensionProvider?: boolean;\n};\n\nexport function createLightClientProvider({\n  useExtensionProvider = true,\n}: LightClientOptions = {}) {\n  const getSmoldot = lazy(async () => {\n    if (!useExtensionProvider) {\n      return startSmoldotWorker();\n    }\n\n    return (await startSubstrateConnectWorker()) ?? startSmoldotWorker();\n  });\n\n  return {\n    addRelayChain<TRelayChainId extends WellknownRelayChainId>(\n      options: AddChainOptions<TRelayChainId>,\n    ) {\n      const getChainSpec = lazy(() =>\n        \"chainSpec\" in options\n          ? Promise.resolve(options.chainSpec)\n          : wellknownChains[options.id][0]().then((chain) => chain.chainSpec),\n      );\n\n      const getRelayChain = lazy(async () => {\n        const smoldot = await getSmoldot();\n        const chainSpec = await getChainSpec();\n\n        if (isSubstrateConnectProvider(smoldot)) {\n          return smoldot.addChain(chainSpec);\n        }\n\n        return smoldot.addChain({ chainSpec });\n      });\n\n      return addLightClientProvider({\n        [getProviderSymbol]() {\n          return getSmProvider(getRelayChain());\n        },\n\n        addParachain<\n          TParachainId extends\n            keyof (typeof wellknownChains)[TRelayChainId][1] extends never\n              ? WellknownParachainId\n              : keyof (typeof wellknownChains)[TRelayChainId][1],\n        >(options: AddChainOptions<TParachainId>) {\n          return addLightClientProvider({\n            [getProviderSymbol]() {\n              const chainSpecPromise =\n                \"chainSpec\" in options\n                  ? Promise.resolve(options.chainSpec)\n                  : // @ts-expect-error TODO: fix this\n                    Object.fromEntries(\n                      Object.values(wellknownChains).flatMap((relayChain) =>\n                        Object.entries(relayChain[1]),\n                      ),\n                    )\n                      [options.id]()\n                      .then((chain) => chain.chainSpec);\n\n              const parachainPromise = Promise.all([\n                getRelayChain(),\n                chainSpecPromise,\n              ]).then(([relayChain, chainSpec]) =>\n                \"addChain\" in relayChain\n                  ? relayChain.addChain(chainSpec)\n                  : (async () => {\n                      const smoldot = await getSmoldot();\n\n                      return isSubstrateConnectProvider(smoldot)\n                        ? smoldot.addChain(chainSpec)\n                        : smoldot.addChain({\n                            chainSpec,\n                            potentialRelayChains: [relayChain],\n                          });\n                    })(),\n              );\n\n              return getSmProvider(parachainPromise);\n            },\n          });\n        },\n      });\n    },\n  };\n}\n\nexport function isLightClientProvider(\n  value: unknown,\n): value is LightClientProvider {\n  return lightClientProviders.has(value as LightClientProvider);\n}\n\nexport function createClientFromLightClientProvider(\n  provider: LightClientProvider,\n) {\n  return createClient(provider[getProviderSymbol]());\n}\n\nconst lightClientProviders = new WeakSet<LightClientProvider>();\n\nfunction addLightClientProvider<T extends LightClientProvider>(provider: T) {\n  lightClientProviders.add(provider);\n  return provider;\n}\n\nfunction startSmoldotWorker() {\n  return import(\"polkadot-api/smoldot/from-worker\").then(\n    ({ startFromWorker }) =>\n      startFromWorker(\n        new Worker(new URL(\"polkadot-api/smoldot/worker\", import.meta.url), {\n          type: \"module\",\n        }),\n      ),\n  );\n}\n\nconst substrateConnectSet = new WeakSet<\n  Awaited<ReturnType<typeof getSmoldotExtensionProviders>[number][\"provider\"]>\n>();\n\nfunction startSubstrateConnectWorker() {\n  return import(\"@substrate/smoldot-discovery\").then(\n    async ({ getSmoldotExtensionProviders }) => {\n      const provider = await getSmoldotExtensionProviders().at(0)?.provider;\n\n      if (provider !== undefined) {\n        substrateConnectSet.add(provider);\n      }\n\n      return provider;\n    },\n  );\n}\n\nfunction isSubstrateConnectProvider(\n  value: unknown,\n): value is Awaited<\n  ReturnType<typeof getSmoldotExtensionProviders>[number][\"provider\"]\n> {\n  return substrateConnectSet.has(value as never);\n}\n", "import { BaseError } from \"@reactive-dot/core\";\n\nexport class AccountMismatchError extends BaseError {}\n", "import type { WalletOptions } from \"../../core/build/wallets/wallet.js\";\nimport { AccountMismatchError } from \"./errors.js\";\nimport type { LedgerSigner } from \"@polkadot-api/ledger-signer\";\nimport { Binary } from \"@polkadot-api/substrate-bindings\";\nimport {\n  LocalWallet,\n  type PolkadotSignerAccount,\n} from \"@reactive-dot/core/wallets.js\";\nimport { BehaviorSubject } from \"rxjs\";\nimport { map, skip } from \"rxjs/operators\";\n\ntype LedgerAccount = {\n  id: string;\n  publicKey: Uint8Array;\n  name?: string;\n  path: number;\n};\n\ntype JsonLedgerAccount = Omit<LedgerAccount, \"publicKey\" | \"id\"> & {\n  publicKey: string;\n};\n\nexport class LedgerWallet extends LocalWallet<\n  LedgerAccount,\n  WalletOptions,\n  \"accounts\"\n> {\n  readonly id = \"ledger\";\n\n  readonly name = \"Ledger\";\n\n  readonly #ledgerAccounts$ = new BehaviorSubject<LedgerAccount[]>([]);\n\n  readonly accounts$ = this.#ledgerAccounts$.pipe(\n    map((accounts) =>\n      accounts\n        .toSorted((a, b) => a.path - b.path)\n        .map(\n          (account): PolkadotSignerAccount => ({\n            id: account.id,\n            ...(account.name === undefined ? {} : { name: account.name }),\n            polkadotSigner: ({ tokenSymbol, tokenDecimals }) => ({\n              publicKey: account.publicKey,\n              signTx: async (...args) => {\n                await this.#assertMatchingAccount(account);\n\n                const ledgerSigner = await this.#getOrCreateLedgerSigner();\n                const polkadotSigner = await ledgerSigner.getPolkadotSigner(\n                  { tokenSymbol, decimals: tokenDecimals },\n                  account.path,\n                );\n\n                return polkadotSigner.signTx(...args);\n              },\n              signBytes: async (...args) => {\n                await this.#assertMatchingAccount(account);\n\n                const ledgerSigner = await this.#getOrCreateLedgerSigner();\n                const polkadotSigner = await ledgerSigner.getPolkadotSigner(\n                  { tokenSymbol, decimals: tokenDecimals },\n                  account.path,\n                );\n\n                return polkadotSigner.signBytes(...args);\n              },\n            }),\n          }),\n        ),\n    ),\n  );\n\n  readonly connected$ = this.accounts$.pipe(\n    map((accounts) => accounts.length > 0),\n  );\n\n  #ledgerSigner?: LedgerSigner;\n\n  constructor(options?: WalletOptions) {\n    super(options);\n    this.#ledgerAccounts$.pipe(skip(1)).subscribe((accounts) =>\n      this.storage.setItem(\n        \"accounts\",\n        JSON.stringify(\n          accounts.map(\n            ({ id, ...account }): JsonLedgerAccount => ({\n              ...account,\n              publicKey: Binary.fromBytes(account.publicKey).asHex(),\n            }),\n          ),\n        ),\n      ),\n    );\n  }\n\n  initialize() {\n    this.#ledgerAccounts$.next(\n      (\n        JSON.parse(\n          this.storage.getItem(\"accounts\") ?? JSON.stringify([]),\n        ) as JsonLedgerAccount[]\n      ).map((account) => ({\n        ...account,\n        id: account.publicKey,\n        publicKey: Binary.fromHex(account.publicKey).asBytes(),\n      })),\n    );\n  }\n\n  async connect() {\n    this.accountStore.add(await this.getConnectedAccount());\n  }\n\n  disconnect() {\n    this.accountStore.clear();\n  }\n\n  accountStore = {\n    add: (account: LedgerAccount) => {\n      this.#ledgerAccounts$.next(\n        this.#ledgerAccounts$.value\n          .filter((storedAccount) => storedAccount.id !== account.id)\n          .concat([account]),\n      );\n    },\n    clear: () => {\n      this.#ledgerAccounts$.next([]);\n    },\n    delete: (identifiable: string | { id: string }) => {\n      const id =\n        typeof identifiable === \"string\" ? identifiable : identifiable.id;\n\n      this.#ledgerAccounts$.next(\n        this.#ledgerAccounts$.value.filter(\n          (storedAccount) => storedAccount.id !== id,\n        ),\n      );\n    },\n    has: (identifiable: string | { id: string }) => {\n      const id =\n        typeof identifiable === \"string\" ? identifiable : identifiable.id;\n\n      return this.#ledgerAccounts$.value.some((account) => account.id === id);\n    },\n    values: () => this.#ledgerAccounts$.value,\n  };\n\n  /**\n   * @experimental\n   * @param path - The primary derivation index\n   * @returns The connected Ledger's account\n   */\n  async getConnectedAccount(path = 0) {\n    const ledgerSigner = await this.#getOrCreateLedgerSigner();\n    const publicKey = await ledgerSigner.getPubkey(path);\n\n    return {\n      id: Binary.fromBytes(publicKey).asHex(),\n      publicKey,\n      path,\n    } as LedgerAccount;\n  }\n\n  async #assertMatchingAccount(account: LedgerAccount) {\n    const ledgerSigner = await this.#getOrCreateLedgerSigner();\n    const publicKey = await ledgerSigner.getPubkey(account.path);\n\n    if (\n      Binary.fromBytes(account.publicKey).asHex() !==\n      Binary.fromBytes(publicKey).asHex()\n    ) {\n      throw new AccountMismatchError();\n    }\n  }\n\n  async #getOrCreateLedgerSigner() {\n    if (this.#ledgerSigner !== undefined) {\n      return this.#ledgerSigner;\n    }\n\n    if (!(\"Buffer\" in globalThis)) {\n      const {\n        default: { Buffer },\n      } = await import(\"buffer/\");\n\n      // @ts-expect-error polyfill types mismatch\n      globalThis.Buffer = Buffer;\n    }\n\n    const [{ default: TransportWebUSB }, { LedgerSigner }] = await Promise.all([\n      import(\"@ledgerhq/hw-transport-webusb\"),\n      import(\"@polkadot-api/ledger-signer\"),\n    ]);\n\n    return (this.#ledgerSigner = new LedgerSigner(\n      // @ts-expect-error Weird bug with Ledger\n      await TransportWebUSB.create(),\n    ));\n  }\n}\n"],
  "mappings": "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",
  "names": ["_storage"]
}
