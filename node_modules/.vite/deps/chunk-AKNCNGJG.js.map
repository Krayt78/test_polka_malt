{
  "version": 3,
  "sources": ["../../.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/src/typedef.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/src/isCompatible.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/src/doubleSet.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/src/isStaticCompatible.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.3/node_modules/@polkadot-api/metadata-compatibility/src/entryPoint.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/internal-utils/noop.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/methods.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/transaction/transaction.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/errors.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/internal-utils/deferred-promise.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/internal-utils/subscriptions-manager.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/internal-utils/abortablePromiseFn.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/operation-promise.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/body.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/call.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/header.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/storage-subscription.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/storage.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/unpin.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/client/DestroyedError.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/chainhead.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/client/RpcError.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/client/createClient.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainspec.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/index.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/operationLimitRecovery.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/errors.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/optionalHash.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/fromAbortControllerFn.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/lazyFollower.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/withStopRecovery.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/new-blocks.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/storage-queries.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/streams/follow.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/streams/get-runtime-creator.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/utils/shareLatest.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/streams/pinned-blocks.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/track-tx.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/validate-tx.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/utils/with-default-value.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/utils/delay-unsubscription.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/utils/concatMapEager.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/chainHead.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/tx.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/getObservableClient.ts", "../../.pnpm/@polkadot-api+observable-client@0.11.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/streams/block-operations.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/compatibility.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/constants.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/utils/shareLatest.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/event.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/utils/firstValueFromWithSignal.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/utils/optional-arg.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/runtime-call.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/utils/lossLessExhaustMap.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/storage.ts", "../../.pnpm/@polkadot-api+signer@0.2.1/node_modules/@polkadot-api/signer/src/from-raw-signer.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/tx/signed-extensions/system-version.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/tx/signed-extensions/mortal-enc.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/tx/signed-extensions/charge-asset-tx-enc.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/tx/signed-extensions/sign-extensions.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/tx/create-tx.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/utils/continue-with.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/tx/submit-fns.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/tx/tx.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/utils/self-dependent.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/SUSPENSE.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/StatePromise.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/errors.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/internal/empty-value.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/state/stateFactory.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/internal/state-observable.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/state/stateSingle.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/state/index.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/withDefault.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/effects/sinkSuspense.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/effects/liftSuspense.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/watch-entries.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/viewFns.ts", "../../.pnpm/polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2/node_modules/polkadot-api/src/client.ts"],
  "sourcesContent": ["import type { MetadataPrimitives, Var } from \"@polkadot-api/metadata-builders\"\nimport {\n  Codec,\n  Enum,\n  Option,\n  Self,\n  StringRecord,\n  Struct,\n  Tuple,\n  Variant,\n  Vector,\n  _void,\n  compactNumber,\n  str,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst smallCompact = compactNumber\nexport interface StructNode {\n  type: \"struct\"\n  value: Array<[string, number]>\n}\nconst StructCodec = Vector(Tuple(str, smallCompact))\n\nexport const Primitive = {\n  bool: \"boolean\" as const,\n  str: \"string\" as const,\n  num: \"number\" as const,\n  big: \"bigint\" as const,\n  bits: \"bitseq\" as const,\n  void: \"void\" as const,\n}\nexport type PRIMITIVES = (typeof Primitive)[keyof typeof Primitive]\n\nexport interface TerminalNode {\n  type: \"terminal\"\n  value: {\n    type: PRIMITIVES\n  }\n}\nconst TerminalCodec = Variant(\n  Object.fromEntries(\n    Object.values(Primitive).map((p) => [p, _void]),\n  ) as StringRecord<Codec<undefined>>,\n) as any as Codec<TerminalNode[\"value\"]>\n\nexport interface EnumNode {\n  type: \"enum\"\n  value: Array<[string, Enum<{ inline: TypedefNode; lookup: number }>]>\n}\nconst EnumCodec: Codec<EnumNode[\"value\"]> = Vector(\n  Tuple(\n    str,\n    Variant({\n      inline: Self(() => TypedefCodec),\n      lookup: smallCompact,\n    }),\n  ),\n)\n\nexport interface TupleNode {\n  type: \"tuple\"\n  value: number[]\n}\nconst TupleCodec = Vector(smallCompact)\n\nexport interface ArrayNode {\n  type: \"array\"\n  value: {\n    typeRef: number\n    length?: number\n  }\n}\nconst ArrayCodec = Struct({\n  typeRef: smallCompact,\n  length: Option(smallCompact),\n}) as Codec<ArrayNode[\"value\"]>\n\nexport interface BinaryNode {\n  type: \"binary\"\n  value: number | undefined\n}\nconst BinaryCodec = Option(smallCompact) as Codec<BinaryNode[\"value\"]>\n\nexport interface OptionNode {\n  type: \"option\"\n  value: number\n}\nconst OptionCodec = smallCompact\n\nexport interface ResultNode {\n  type: \"result\"\n  value: {\n    ok: number\n    ko: number\n  }\n}\nconst ResultCodec = Struct({\n  ok: smallCompact,\n  ko: smallCompact,\n})\n\nexport type TypedefNode =\n  | StructNode\n  | TerminalNode\n  | EnumNode\n  | TupleNode\n  | ArrayNode\n  | BinaryNode\n  | OptionNode\n  | ResultNode\nexport const TypedefCodec: Codec<TypedefNode> = Variant({\n  struct: StructCodec,\n  terminal: TerminalCodec,\n  enum: EnumCodec,\n  tuple: TupleCodec,\n  array: ArrayCodec,\n  binary: BinaryCodec,\n  option: OptionCodec,\n  result: ResultCodec,\n})\n\nconst primitiveToTerminal: Record<MetadataPrimitives, PRIMITIVES> = {\n  i256: Primitive.big,\n  i128: Primitive.big,\n  i64: Primitive.big,\n  i32: Primitive.num,\n  i16: Primitive.num,\n  i8: Primitive.num,\n  u256: Primitive.big,\n  u128: Primitive.big,\n  u64: Primitive.big,\n  u32: Primitive.num,\n  u16: Primitive.num,\n  u8: Primitive.num,\n  bool: Primitive.bool,\n  char: Primitive.str,\n  str: Primitive.str,\n}\n\nconst terminal = (type: PRIMITIVES): TerminalNode => ({\n  type: \"terminal\",\n  value: { type },\n})\nexport function mapLookupToTypedef(\n  entry: Var,\n  resolve: (id: number) => void = () => {},\n): TypedefNode {\n  switch (entry.type) {\n    case \"AccountId20\":\n    case \"AccountId32\":\n      return terminal(Primitive.str)\n    case \"array\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: entry.len }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: {\n          typeRef: entry.value.id,\n          length: entry.len,\n        },\n      }\n    case \"bitSequence\":\n      return terminal(Primitive.bits)\n    case \"compact\":\n      return terminal(entry.isBig ? Primitive.big : Primitive.num)\n    case \"enum\":\n      return {\n        type: \"enum\",\n        value: Object.entries(entry.value).map(\n          ([key, params]): EnumNode[\"value\"][number] => {\n            if (params.type !== \"lookupEntry\")\n              return [\n                key,\n                { type: \"inline\", value: mapLookupToTypedef(params, resolve) },\n              ]\n\n            resolve(params.value.id)\n            return [\n              key,\n              {\n                type: \"lookup\",\n                value: params.value.id,\n              },\n            ]\n          },\n        ),\n      }\n    case \"struct\": {\n      const value = Object.entries(entry.value).map(\n        ([key, prop]) => [key, prop.id] satisfies [string, number],\n      )\n      value.forEach(([, v]) => resolve(v))\n      return {\n        type: \"struct\",\n        value,\n      }\n    }\n    case \"tuple\": {\n      const value = entry.value.map((v) => v.id)\n      value.forEach(resolve)\n      return {\n        type: \"tuple\",\n        value,\n      }\n    }\n    case \"option\":\n      resolve(entry.value.id)\n      return {\n        type: \"option\",\n        value: entry.value.id,\n      }\n    case \"primitive\":\n      return terminal(primitiveToTerminal[entry.value])\n    case \"result\":\n      resolve(entry.value.ok.id)\n      resolve(entry.value.ko.id)\n      return {\n        type: \"result\",\n        value: {\n          ok: entry.value.ok.id,\n          ko: entry.value.ko.id,\n        },\n      }\n    case \"sequence\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: undefined }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: { typeRef: entry.value.id },\n      }\n    case \"void\":\n      return terminal(Primitive.void)\n  }\n}\n\nexport function mapReferences(\n  node: TypedefNode,\n  mapFn: (id: number) => number,\n): TypedefNode {\n  switch (node.type) {\n    case \"array\":\n      return {\n        ...node,\n        value: {\n          ...node.value,\n          typeRef: mapFn(node.value.typeRef),\n        },\n      }\n    case \"option\":\n      return { ...node, value: mapFn(node.value) }\n    case \"result\":\n      return {\n        ...node,\n        value: { ok: mapFn(node.value.ok), ko: mapFn(node.value.ko) },\n      }\n    case \"tuple\":\n      return { ...node, value: node.value.map(mapFn) }\n    case \"struct\":\n      return {\n        ...node,\n        value: node.value.map(([k, v]) => [k, mapFn(v)] as [string, number]),\n      }\n    case \"enum\": {\n      return {\n        ...node,\n        value: node.value.map(([k, { type, value }]): EnumNode[\"value\"][0] => [\n          k,\n          type === \"lookup\"\n            ? { type, value: mapFn(value) }\n            : { type, value: mapReferences(value, mapFn) },\n        ]),\n      }\n    }\n\n    case \"binary\":\n    case \"terminal\":\n      return node\n  }\n}\n", "import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { Primitive, type TerminalNode, type TypedefNode } from \"./typedef\"\n\n// Descriptors: pallet + name => index (this._descriptors[opType][pallet][name])\n// index will be for both checksums and compatLookup\n\n// Dest type: describes types of the receiving end.\nexport function isCompatible(\n  value: any,\n  destNode: TypedefNode,\n  getNode: (id: number) => TypedefNode,\n): boolean {\n  if (destNode.type === \"option\" && value == null) {\n    return true\n  }\n\n  const nextCall = (value: any, destNode: TypedefNode) =>\n    isCompatible(value, destNode, getNode)\n\n  const checkTerminal = (terminal: TerminalNode) => {\n    switch (terminal.value.type) {\n      case Primitive.str:\n      case Primitive.big:\n      case Primitive.bool:\n      case Primitive.num:\n        return typeof value === terminal.value.type\n      case Primitive.bits:\n        return (\n          typeof value === \"object\" &&\n          value != null &&\n          typeof value.bitsLen === \"number\" &&\n          value.bytes instanceof Uint8Array\n        )\n      case Primitive.void:\n        // A void node is always compatible, since the codec ignores the input.\n        return true\n    }\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return checkTerminal(destNode)\n    case \"binary\":\n      return (\n        value instanceof Binary &&\n        (destNode.value == null || value.asBytes().length >= destNode.value)\n      )\n    case \"array\":\n      if (!Array.isArray(value)) return false\n      const valueArr = value as Array<any>\n      if (\n        destNode.value.length != null &&\n        valueArr.length < destNode.value.length\n      ) {\n        return false\n      }\n      return valueArr\n        .slice(0, destNode.value.length)\n        .every((value) => nextCall(value, getNode(destNode.value.typeRef)))\n    case \"enum\":\n      if (!value) return false\n      const valueEnum = value as { type: string; value: any }\n      const destVariants = Object.fromEntries(destNode.value)\n      if (!(valueEnum.type in destVariants)) {\n        return false\n      }\n      const variantValue = destVariants[valueEnum.type]\n      if (variantValue == null) {\n        return true\n      }\n      return nextCall(\n        valueEnum.value,\n        variantValue.type === \"inline\"\n          ? variantValue.value\n          : getNode(variantValue.value),\n      )\n    case \"option\":\n      if (value == null) {\n        return true\n      }\n      return nextCall(value, getNode(destNode.value))\n    case \"struct\":\n      if (!value) return false\n      return destNode.value.every(([key, typeRef]) =>\n        nextCall(value[key], getNode(typeRef)),\n      )\n    case \"tuple\":\n      if (!value) return false\n      // length will be checked indirectly\n      return destNode.value.every((typeRef, idx) =>\n        nextCall(value[idx], getNode(typeRef)),\n      )\n    case \"result\":\n      if (!(\"success\" in value && \"value\" in value)) return false\n      return nextCall(\n        value.value,\n        getNode(value.success ? destNode.value.ok : destNode.value.ko),\n      )\n  }\n}\n", "export class DoubleSet<T> {\n  private value: Map<T, Set<T>> = new Map()\n\n  constructor(values: Array<[T, T]> = []) {\n    values.forEach(([a, b]) => this.add(a, b))\n  }\n\n  public has(a: T, b: T) {\n    return this.value.get(a)?.has(b) ?? false\n  }\n  public add(a: T, b: T) {\n    if (!this.value.has(a)) {\n      this.value.set(a, new Set())\n    }\n    this.value.get(a)!.add(b)\n  }\n  public addAll(values: Array<[T, T]>) {\n    values.forEach(([a, b]) => this.add(a, b))\n  }\n  public delete(a: T, b: T) {\n    if (!this.value.has(a)) return\n    const set = this.value.get(a)!\n    set.delete(b)\n    if (!set.size) {\n      this.value.delete(a)\n    }\n  }\n  public isEmpty() {\n    return !this.value.size\n  }\n  public get values() {\n    return Array.from(this.value).flatMap(([a, values]) =>\n      Array.from(values).map((b) => [a, b] as [T, T]),\n    )\n  }\n}\n", "import { DoubleSet } from \"./doubleSet\"\nimport type {\n  ArrayNode,\n  BinaryNode,\n  EnumNode,\n  OptionNode,\n  ResultNode,\n  StructNode,\n  TerminalNode,\n  TupleNode,\n  TypedefNode,\n} from \"./typedef\"\n\nexport enum CompatibilityLevel {\n  // No possible value from origin will be compatible with dest\n  Incompatible = 0,\n  // Some values of origin will be compatible with dest\n  Partial,\n  // Every value from origin will be compatible with dest\n  BackwardsCompatible,\n  // Types are identical\n  Identical,\n}\n\n/*\n * We have to be careful with circular references and early returns with the cache.\n *\n * For early returns, the resulting level could be even lower when exploring other branches.\n * This means that we can't store early returns in the cache. For simplicity, the\n * initial implementation will not have early returns.\n * It should be possible to store in the cache what was the CompatibilityLevel that\n * caused the early return, so that if the same call is done with the same CompatibilityLevel\n * we could still leverage the cache.\n *\n * For circular references, the simplest solution is to assume that the circular\n * node is fully-compatible (Identical). But then any node that is reading from it\n * can't be cached because its result will be doing the assumption that the circular\n * node is `Identical`.\n * Only once the whole cycle has completed, then the circular node can actually\n * cache its own result (TODO check this assumption is fine), and then any other\n * node that referenced it can also safely cache.\n * We have to think cases where there could be two cycles:\n *         F ← E\n *         ↓   ↑\n * A → B → C → D\n *     ↑       ↓\n *     I ← H ← G\n *\n * B = 4 => B = 1\n * B = 1 => B = 0\n *\n * As we're going depth-first, when we reach C from F, we will return a \"temporary\"\n * `Identical`. This means that F, E or D can't be cached. But then we continue\n * depth-first into G-H-I-B, then detect the cycle and return a \"temporary\" `Identical`.\n * Then I, H, G and C can't be cached because they actually depend on the temporary result of B.\n * B on the other hand will be able to cache its own result, and so does A.\n *\n * If a new call enters the cycle from D, then the branch G-H-I-B will be cached.\n * But the cycle D-E-F-C will make E-F-C not to cache their result yet.\n *\n *\n * => Maybe instead of having two separate [originNode, destNode] we can first merge\n * both trees into one, and then run the search? This would simplify the double-map/set stuff.\n * Can it be done lazily though? In a way that we don't need to go through the whole tree?\n */\n\nexport type StaticCompatibleResult = {\n  level: CompatibilityLevel\n  assumptions: DoubleSet<TypedefNode>\n}\nexport type CompatibilityCache = Map<\n  TypedefNode,\n  Map<TypedefNode, CompatibilityLevel | null>\n>\nexport function isStaticCompatible(\n  originNode: TypedefNode | undefined,\n  getOriginNode: (id: number) => TypedefNode,\n  destNode: TypedefNode | undefined,\n  getDestNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n): StaticCompatibleResult {\n  if (!destNode && !originNode) {\n    return unconditional(CompatibilityLevel.Identical)\n  }\n  if (!destNode) return unconditional(CompatibilityLevel.BackwardsCompatible)\n  if (!originNode)\n    return unconditional(\n      destNode.type === \"option\"\n        ? CompatibilityLevel.BackwardsCompatible\n        : CompatibilityLevel.Incompatible,\n    )\n\n  if (!cache.has(destNode)) {\n    cache.set(destNode, new Map())\n  }\n  const destNodeCache = cache.get(destNode)!\n  if (destNodeCache.has(originNode)) {\n    const result = destNodeCache.get(originNode)\n    if (result === null) {\n      // Circular reference hit, return Identical with assumption\n      return {\n        level: CompatibilityLevel.Identical,\n        assumptions: new DoubleSet([[originNode, destNode]]),\n      }\n    }\n    return unconditional(result!)\n  }\n\n  // Initialize to null for detecting circular references\n  destNodeCache.set(originNode, null)\n\n  const result = getIsStaticCompatible(\n    originNode,\n    destNode,\n    (originNode, destNode) =>\n      isStaticCompatible(\n        typeof originNode === \"number\" ? getOriginNode(originNode) : originNode,\n        getOriginNode,\n        typeof destNode === \"number\" ? getDestNode(destNode) : destNode,\n        getDestNode,\n        cache,\n      ),\n  )\n\n  result.assumptions.delete(originNode, destNode)\n  if (\n    result.assumptions.isEmpty() ||\n    result.level === CompatibilityLevel.Incompatible\n  ) {\n    destNodeCache.set(originNode, result.level)\n  } else {\n    // Remove the temporary `null` value from the cache\n    destNodeCache.delete(originNode)\n  }\n  return result\n}\n\nfunction getIsStaticCompatible(\n  originNode: TypedefNode,\n  destNode: TypedefNode,\n  nextCall: (\n    originNode: TypedefNode | number | undefined,\n    destNode: TypedefNode | number | undefined,\n  ) => StaticCompatibleResult,\n): StaticCompatibleResult {\n  if (originNode.type !== destNode.type) {\n    if (destNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode, destNode.value),\n        CompatibilityLevel.BackwardsCompatible,\n      )\n    }\n    if (originNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode.value, destNode),\n        CompatibilityLevel.Partial,\n      )\n    }\n    return unconditional(CompatibilityLevel.Incompatible)\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return unconditional(\n        destNode.value.type === (originNode as TerminalNode).value.type\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.Incompatible,\n      )\n    case \"binary\":\n      const binaryOrigin = originNode as BinaryNode\n      return unconditional(\n        compareOptionalLengths(binaryOrigin.value, destNode.value),\n      )\n    case \"array\":\n      const arrayOrigin = originNode as ArrayNode\n      const lengthCheck = unconditional(\n        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length),\n      )\n      return strictMerge([\n        lengthCheck,\n        () => nextCall(arrayOrigin.value.typeRef, destNode.value.typeRef),\n      ])\n    case \"enum\": {\n      const enumOrigin = originNode as EnumNode\n      const destVariants = Object.fromEntries(\n        destNode.value.map(([key, value]) => [key, value.value]),\n      )\n      const maxLevel =\n        enumOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      // check whether every possible `origin` value is compatible with dest\n      return withMaxLevel(\n        mergeResults(\n          enumOrigin.value.map(\n            ([type, value]) =>\n              () =>\n                type in destVariants\n                  ? nextCall(value.value, destVariants[type])\n                  : unconditional(CompatibilityLevel.Incompatible),\n          ),\n        ),\n        maxLevel,\n      )\n    }\n    case \"option\":\n      return nextCall((originNode as OptionNode).value, destNode.value)\n    case \"struct\":\n      const structOrigin = originNode as StructNode\n      const originProperties = Object.fromEntries(structOrigin.value)\n      const maxLevel =\n        structOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      return withMaxLevel(\n        strictMerge(\n          destNode.value.map(\n            ([key, value]) =>\n              () =>\n                nextCall(originProperties[key], value),\n          ),\n        ),\n        maxLevel,\n      )\n    case \"tuple\": {\n      const tupleOrigin = originNode as TupleNode\n      const lengthCheck = unconditional(\n        compareArrayLengths(tupleOrigin.value, destNode.value),\n      )\n      return strictMerge([\n        lengthCheck,\n        ...destNode.value.map(\n          (value, idx) => () => nextCall(tupleOrigin.value[idx], value),\n        ),\n      ])\n    }\n    case \"result\":\n      const resultOrigin = originNode as ResultNode\n      return mergeResults([\n        nextCall(resultOrigin.value.ok, destNode.value.ok),\n        nextCall(resultOrigin.value.ko, destNode.value.ko),\n      ])\n  }\n}\n\nconst withMaxLevel = (\n  result: StaticCompatibleResult,\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  ...result,\n  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result\n  level: Math.min(result.level, level),\n})\nconst noAssumptions = new DoubleSet<TypedefNode>()\nexport const unconditional = (\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  level,\n  assumptions: noAssumptions,\n})\n\n/**\n * Merges multiple results, following the most \"strict\" one, (semantically an\n * AND)\n */\nexport const strictMerge = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  let merged = unconditional(CompatibilityLevel.Identical)\n\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    // On early return we don't need to keep the other assumptions\n    if (result.level === CompatibilityLevel.Incompatible) return result\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return merged\n}\n\n/**\n * Merges multiple results, going to `partially` (semantically an OR)\n */\nconst mergeResults = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  if (!results.length) return unconditional(CompatibilityLevel.Identical)\n\n  let hasCompatibles = false\n\n  let merged = unconditional(CompatibilityLevel.Identical)\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    if (result.level === CompatibilityLevel.Incompatible) {\n      merged.level = Math.min(merged.level, CompatibilityLevel.Partial)\n      continue\n    }\n    hasCompatibles = true\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return hasCompatibles\n    ? merged\n    : unconditional(CompatibilityLevel.Incompatible)\n}\n\nexport const compareArrayLengths = (\n  origin: unknown[],\n  dest: unknown[],\n): CompatibilityLevel =>\n  dest.length === origin.length\n    ? CompatibilityLevel.Identical\n    : origin.length >= dest.length\n      ? CompatibilityLevel.BackwardsCompatible\n      : CompatibilityLevel.Incompatible\n\nexport const compareOptionalLengths = (\n  origin: number | undefined,\n  dest: number | undefined,\n): CompatibilityLevel =>\n  dest === origin\n    ? CompatibilityLevel.Identical\n    : dest == null || origin! >= dest\n      ? CompatibilityLevel.BackwardsCompatible\n      : origin == null\n        ? CompatibilityLevel.Partial\n        : CompatibilityLevel.Incompatible\n", "import type { EnumVar } from \"@polkadot-api/metadata-builders\"\nimport {\n  compactNumber,\n  UnifiedMetadata,\n  Struct,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { isCompatible } from \"./isCompatible\"\nimport { CompatibilityCache, isStaticCompatible } from \"./isStaticCompatible\"\nimport {\n  mapLookupToTypedef,\n  mapReferences,\n  Primitive,\n  TypedefCodec,\n  type TypedefNode,\n} from \"./typedef\"\n\nexport type EntryPointNode =\n  | {\n      type: \"lookup\"\n      value: number\n    }\n  | {\n      type: \"typedef\"\n      value: TypedefNode\n    }\nconst EntryPointNodeCodec = Variant({\n  lookup: compactNumber,\n  typedef: TypedefCodec,\n})\n\nconst lookupNode = (value: number): EntryPointNode => ({\n  type: \"lookup\",\n  value,\n})\nconst typedefNode = (value: TypedefNode): EntryPointNode => ({\n  type: \"typedef\",\n  value,\n})\nexport const voidEntryPointNode = typedefNode({\n  type: \"terminal\",\n  value: { type: Primitive.void },\n})\n\nexport interface EntryPoint {\n  args: EntryPointNode\n  values: EntryPointNode\n}\nexport const EntryPointCodec = Struct({\n  args: EntryPointNodeCodec,\n  values: EntryPointNodeCodec,\n})\n\nexport function storageEntryPoint(\n  storageEntry: Exclude<\n    UnifiedMetadata[\"pallets\"][number][\"storage\"],\n    undefined\n  >[\"items\"][number],\n): EntryPoint {\n  if (storageEntry.type.tag === \"plain\")\n    return {\n      args: voidEntryPointNode,\n      values: lookupNode(storageEntry.type.value),\n    }\n\n  const { key, value } = storageEntry.type.value\n  return {\n    args: lookupNode(key),\n    values: lookupNode(value),\n  }\n}\n\nexport function runtimeCallEntryPoint(\n  entry: UnifiedMetadata[\"apis\"][number][\"methods\"][number],\n): EntryPoint {\n  return {\n    args: typedefNode({\n      type: \"tuple\",\n      value: entry.inputs.map((v) => v.type),\n    }),\n    values: lookupNode(entry.output),\n  }\n}\n\nexport function enumValueEntryPointNode(\n  entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n): EntryPointNode {\n  return entry.type === \"lookupEntry\"\n    ? lookupNode(entry.value.id)\n    : typedefNode(mapLookupToTypedef(entry))\n}\n\nexport function singleValueEntryPoint(value: number): EntryPoint {\n  return {\n    args: voidEntryPointNode,\n    values: lookupNode(value),\n  }\n}\n\nexport function entryPointsAreCompatible(\n  descriptorEntry: EntryPoint,\n  getDescriptorNode: (id: number) => TypedefNode,\n  runtimeEntry: EntryPoint,\n  getRuntimeNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n) {\n  const resolveNode = (\n    node: EntryPointNode,\n    getTypedef: (id: number) => TypedefNode,\n  ): TypedefNode =>\n    node.type === \"lookup\" ? getTypedef(node.value) : node.value\n\n  // EntryPoint interaction \"origin -> dest\" is descriptor -> runtime for args, and runtime -> descriptor for values.\n  return {\n    args: isStaticCompatible(\n      resolveNode(descriptorEntry.args, getDescriptorNode),\n      getDescriptorNode,\n      resolveNode(runtimeEntry.args, getRuntimeNode),\n      getRuntimeNode,\n      cache,\n    ).level,\n    values: isStaticCompatible(\n      resolveNode(runtimeEntry.values, getRuntimeNode),\n      getRuntimeNode,\n      resolveNode(descriptorEntry.values, getDescriptorNode),\n      getDescriptorNode,\n      cache,\n    ).level,\n  }\n}\n\nexport function valueIsCompatibleWithDest(\n  dest: EntryPointNode,\n  getDestNode: (id: number) => TypedefNode,\n  value: unknown,\n) {\n  const node = dest.type === \"lookup\" ? getDestNode(dest.value) : dest.value\n  return isCompatible(value, node, getDestNode)\n}\n\nexport function mapEntryPointReferences(\n  entryPoint: EntryPoint,\n  mapFn: (id: number) => number,\n): EntryPoint {\n  const mapNode = (node: EntryPointNode) =>\n    node.type === \"lookup\"\n      ? lookupNode(mapFn(node.value))\n      : typedefNode(mapReferences(node.value, mapFn))\n\n  return {\n    args: mapNode(entryPoint.args),\n    values: mapNode(entryPoint.values),\n  }\n}\n", "export const noop = (): void => {}\n", "const chainHead = {\n  body: \"\",\n  call: \"\",\n  continue: \"\",\n  follow: \"\",\n  header: \"\",\n  stopOperation: \"\",\n  storage: \"\",\n  unfollow: \"\",\n  unpin: \"\",\n  followEvent: \"\",\n}\n\nconst chainSpec = {\n  chainName: \"\",\n  genesisHash: \"\",\n  properties: \"\",\n}\n\nconst transaction = {\n  broadcast: \"\",\n  stop: \"\",\n}\n\nObject.entries({ chainHead, chainSpec, transaction }).forEach(\n  ([fnGroupName, methods]) => {\n    Object.keys(methods).forEach((methodName) => {\n      ;(methods as any)[methodName] = `${fnGroupName}_v1_${methodName}`\n    })\n  },\n)\n\nexport { chainHead, transaction, chainSpec }\n", "import { noop } from \"@/internal-utils\"\nimport { type ClientRequest } from \"../client\"\nimport { transaction } from \"@/methods\"\n\nexport const getTransaction =\n  (request: ClientRequest<string, any>) =>\n  (tx: string, error: (e: Error) => void) => {\n    let cancel = request(transaction.broadcast, [tx], {\n      onSuccess: (subscriptionId) => {\n        cancel =\n          subscriptionId === null\n            ? noop\n            : () => {\n                request(transaction.stop, [subscriptionId])\n              }\n\n        if (subscriptionId === null) {\n          error(new Error(\"Max # of broadcasted transactions has been reached\"))\n        }\n      },\n      onError: error,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n", "export class StopError extends Error {\n  constructor() {\n    super(\"ChainHead stopped\")\n    this.name = \"StopError\"\n  }\n}\n\nexport class DisjointError extends Error {\n  constructor() {\n    super(\"ChainHead disjointed\")\n    this.name = \"DisjointError\"\n  }\n}\n\nexport class OperationLimitError extends Error {\n  constructor() {\n    super(\"ChainHead operations limit reached\")\n    this.name = \"OperationLimitError\"\n  }\n}\n\nexport class OperationError extends Error {\n  constructor(error: string) {\n    super(error)\n    this.name = \"OperationError\"\n  }\n}\n\nexport class OperationInaccessibleError extends Error {\n  constructor() {\n    super(\"ChainHead operation inaccessible\")\n    this.name = \"OperationInaccessibleError\"\n  }\n}\n", "export interface DeferredPromise<T> {\n  promise: Promise<T>\n  res: (value: T) => void\n  rej: (err: Error) => void\n}\n\nexport function deferred<T>(): DeferredPromise<T> {\n  let res: (value: T) => void = () => {}\n  let rej: (err: Error) => void = () => {}\n\n  const promise = new Promise<T>((_res, _rej) => {\n    res = _res\n    rej = _rej\n  })\n\n  return { promise, res, rej }\n}\n", "export interface Subscriber<T> {\n  next: (data: T) => void\n  error: (e: Error) => void\n}\n\nexport const getSubscriptionsManager = <T>() => {\n  const subscriptions = new Map<string, Subscriber<T>>()\n\n  return {\n    has: subscriptions.has.bind(subscriptions),\n    subscribe(id: string, subscriber: Subscriber<T>) {\n      subscriptions.set(id, subscriber)\n    },\n    unsubscribe(id: string) {\n      subscriptions.delete(id)\n    },\n    next(id: string, data: T) {\n      subscriptions.get(id)?.next(data)\n    },\n    error(id: string, e: Error) {\n      const subscriber = subscriptions.get(id)\n      if (subscriber) {\n        subscriptions.delete(id)\n        subscriber.error(e)\n      }\n    },\n    errorAll(e: Error) {\n      const subscribers = [...subscriptions.values()]\n      subscriptions.clear()\n      subscribers.forEach((s) => {\n        s.error(e)\n      })\n    },\n  }\n}\n\nexport type SubscriptionManager<T> = ReturnType<\n  typeof getSubscriptionsManager<T>\n>\n", "import { AbortError, noop } from \"@polkadot-api/utils\"\nimport { AbortablePromiseFn } from \"../common-types\"\n\nexport const abortablePromiseFn =\n  <T, A extends Array<any>>(\n    fn: (\n      ...args: [...[res: (x: T) => void, rej: (e: any) => void], ...A]\n    ) => () => void,\n  ): AbortablePromiseFn<A, T> =>\n  (...args): Promise<T> =>\n    new Promise((res, rej) => {\n      let cancel = noop\n\n      const [actualArgs, abortSignal] =\n        args[args.length - 1] instanceof AbortSignal\n          ? ([args.slice(0, args.length - 1), args[args.length - 1]] as [\n              A,\n              AbortSignal,\n            ])\n          : ([args] as unknown as [A])\n\n      const onAbort = () => {\n        cancel()\n        rej(new AbortError())\n      }\n\n      abortSignal?.addEventListener(\"abort\", onAbort, { once: true })\n\n      const withCleanup =\n        <T>(fn: (x: T) => void): ((x: T) => void) =>\n        (x) => {\n          cancel = noop\n          abortSignal?.removeEventListener(\"abort\", onAbort)\n          fn(x)\n        }\n\n      cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs])\n    })\n", "import { abortablePromiseFn, noop } from \"@/internal-utils\"\nimport {\n  CommonOperationEventsRpc,\n  OperationResponseRpc,\n} from \"./json-rpc-types\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\nimport { ClientInnerRequest } from \"./public-types\"\nimport { chainHead } from \"@/methods\"\n\nexport const createOperationPromise =\n  <I extends { operationId: string; event: string }, O, A extends Array<any>>(\n    operationName: string,\n    factory: (\n      ...args: A\n    ) => [\n      Array<any>,\n      (e: I, res: (x: O) => void, rej: (e: Error) => void) => void,\n    ],\n  ) =>\n  (\n    request: ClientInnerRequest<\n      OperationResponseRpc,\n      I | CommonOperationEventsRpc\n    >,\n  ) =>\n    abortablePromiseFn<O, A>((res, rej, ...args) => {\n      let isRunning = true\n      let cancel = () => {\n        isRunning = false\n      }\n\n      const [requestArgs, logicCb] = factory(...args)\n      request(operationName, requestArgs, {\n        onSuccess: (response, followSubscription) => {\n          if (response.result === \"limitReached\")\n            return rej(new OperationLimitError())\n\n          const { operationId } = response\n          const stopOperation = () => {\n            request(chainHead.stopOperation, [operationId])\n          }\n\n          if (!isRunning) return stopOperation()\n\n          let done = noop\n          const _res = (x: O) => {\n            isRunning = false\n            done()\n            res(x)\n          }\n          const _rej = (x: Error) => {\n            isRunning = false\n            done()\n            rej(x)\n          }\n\n          done = followSubscription(operationId, {\n            next: (e) => {\n              const _e = e as CommonOperationEventsRpc\n              if (_e.event === \"operationError\")\n                rej(new OperationError(_e.error))\n              else if (_e.event === \"operationInaccessible\")\n                rej(new OperationInaccessibleError())\n              else logicCb(e as I, _res, _rej)\n            },\n            error: _rej,\n          })\n\n          cancel = () => {\n            if (isRunning) {\n              done()\n              stopOperation()\n            }\n          }\n        },\n        onError: rej,\n      })\n\n      return () => {\n        cancel()\n      }\n    })\n", "import { chainHead } from \"@/methods\"\nimport type { OperationBodyDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createBodyFn = createOperationPromise(\n  chainHead.body,\n  (hash: string) => [\n    [hash],\n    (e: OperationBodyDoneRpc, res: (x: Array<string>) => void) => {\n      res(e.value)\n    },\n  ],\n)\n", "import { chainHead } from \"@/methods\"\nimport type { OperationCallDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createCallFn = createOperationPromise(\n  chainHead.call,\n  (hash: string, fnName: string, callParameters: string) => [\n    [hash, fnName, callParameters],\n    (e: OperationCallDoneRpc, res: (output: string) => void) => {\n      res(e.output)\n    },\n  ],\n)\n", "import { chainHead } from \"@/methods\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createHeaderFn =\n  (request: ClientInnerRequest<string, unknown>) => (hash: string) =>\n    new Promise<string>((res, rej) => {\n      request(chainHead.header, [hash], {\n        onSuccess: res,\n        onError: rej,\n      })\n    })\n", "import { noop } from \"@polkadot-api/utils\"\nimport type { ClientInnerRequest, FollowResponse } from \"./public-types\"\nimport {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { chainHead } from \"@/methods\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\n\nexport const createStorageCb =\n  (\n    request: ClientInnerRequest<\n      OperationStorageStartedRpc | LimitReachedRpc,\n      | CommonOperationEventsRpc\n      | OperationStorageItemsRpc\n      | OperationStorageDoneRpc\n      | OperationWaitingForContinueRpc\n    >,\n  ): FollowResponse[\"storageSubscription\"] =>\n  (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {\n    if (inputs.length === 0) {\n      onDone()\n      return noop\n    }\n\n    let isRunning = true\n    let cancel = () => {\n      isRunning = false\n    }\n\n    request(chainHead.storage, [hash, inputs, childTrie], {\n      onSuccess: (response, followSubscription) => {\n        if (\n          response.result === \"limitReached\" ||\n          response.discardedItems === inputs.length\n        )\n          return onError(new OperationLimitError())\n\n        const { operationId } = response\n        const stopOperation = () => {\n          request(chainHead.stopOperation, [operationId])\n        }\n\n        if (!isRunning) return stopOperation()\n\n        const doneListening = followSubscription(response.operationId, {\n          next: (event) => {\n            switch (event.event) {\n              case \"operationStorageItems\": {\n                onItems(event.items)\n                break\n              }\n              case \"operationStorageDone\": {\n                _onDone()\n                break\n              }\n              case \"operationError\": {\n                _onError(new OperationError(event.error))\n                break\n              }\n              case \"operationInaccessible\": {\n                _onError(new OperationInaccessibleError())\n                break\n              }\n              default:\n                request(chainHead.continue, [event.operationId])\n            }\n          },\n          error: onError,\n        })\n\n        cancel = () => {\n          doneListening()\n          request(chainHead.stopOperation, [response.operationId])\n        }\n\n        const _onError = (e: Error) => {\n          cancel = noop\n          doneListening()\n          onError(e)\n        }\n\n        const _onDone = () => {\n          cancel = noop\n          doneListening()\n          onDone()\n        }\n\n        onDiscardedItems(response.discardedItems)\n      },\n      onError,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n", "import { OperationLimitError } from \"./errors\"\nimport type {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { abortablePromiseFn } from \"@/internal-utils\"\nimport { createStorageCb } from \"./storage-subscription\"\nimport type { ClientInnerRequest, FollowResponse } from \"./public-types\"\n\nexport const createStorageFn = (\n  request: ClientInnerRequest<\n    OperationStorageStartedRpc | LimitReachedRpc,\n    | CommonOperationEventsRpc\n    | OperationStorageItemsRpc\n    | OperationStorageDoneRpc\n    | OperationWaitingForContinueRpc\n  >,\n): FollowResponse[\"storage\"] => {\n  const cbStore = createStorageCb(request)\n  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {\n    const isDescendants = type.startsWith(\"descendants\")\n    let result: any = isDescendants ? [] : null\n\n    const onItems: Parameters<typeof cbStore>[3] = isDescendants\n      ? (items) => {\n          result.push(items)\n        }\n      : (items) => {\n          result = items[0]?.[type as \"value\"]\n        }\n\n    const cancel = cbStore(\n      hash,\n      [{ key, type }],\n      childTrie ?? null,\n      onItems,\n      reject,\n      () => {\n        try {\n          resolve(isDescendants ? result.flat() : result)\n        } catch (e) {\n          reject(e)\n        }\n      },\n      (nDiscarded) => {\n        if (nDiscarded > 0) {\n          cancel()\n          reject(new OperationLimitError())\n        }\n      },\n    )\n    return cancel\n  })\n}\n", "import { chainHead } from \"@/methods\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createUnpinFn =\n  (request: ClientInnerRequest<null, unknown>) => (hashes: string[]) =>\n    hashes.length > 0\n      ? new Promise<void>((res, rej) => {\n          request(chainHead.unpin, [hashes], {\n            onSuccess() {\n              res()\n            },\n            onError: rej,\n          })\n        })\n      : Promise.resolve()\n", "export class DestroyedError extends Error {\n  constructor() {\n    super(\"Client destroyed\")\n    this.name = \"DestroyedError\"\n  }\n}\n", "import type { ClientRequest, FollowSubscriptionCb } from \"@/client\"\nimport type {\n  FollowEventWithRuntimeRpc,\n  FollowEventWithoutRuntimeRpc,\n  OperationEventsRpc,\n  StopRpc,\n} from \"./json-rpc-types\"\nimport type {\n  ChainHead,\n  ClientInnerRequest,\n  FollowEventWithoutRuntime,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"./public-types\"\nimport {\n  Subscriber,\n  getSubscriptionsManager,\n  noop,\n  deferred,\n} from \"@/internal-utils\"\nimport { createBodyFn } from \"./body\"\nimport { createCallFn } from \"./call\"\nimport { createHeaderFn } from \"./header\"\nimport { createStorageFn } from \"./storage\"\nimport { createUnpinFn } from \"./unpin\"\nimport { DisjointError, StopError } from \"./errors\"\nimport { createStorageCb } from \"./storage-subscription\"\nimport { DestroyedError } from \"@/client/DestroyedError\"\nimport { chainHead } from \"@/methods\"\n\ntype FollowEventRpc =\n  | FollowEventWithRuntimeRpc\n  | FollowEventWithoutRuntimeRpc\n  | OperationEventsRpc\n  | StopRpc\n\nfunction isOperationEvent(event: FollowEventRpc): event is OperationEventsRpc {\n  return (event as OperationEventsRpc).operationId !== undefined\n}\n\nexport function getChainHead(\n  request: ClientRequest<string, FollowEventRpc>,\n): ChainHead {\n  return (\n    withRuntime: boolean,\n    onFollowEvent:\n      | ((event: FollowEventWithoutRuntime) => void)\n      | ((event: FollowEventWithRuntime) => void),\n    onFollowError: (e: Error) => void,\n  ): FollowResponse => {\n    const subscriptions = getSubscriptionsManager<OperationEventsRpc>()\n\n    const ongoingRequests = new Set<() => void>()\n    const deferredFollow = deferred<string | Error>()\n    let followSubscription: Promise<string | Error> | string | null =\n      deferredFollow.promise\n\n    const onAllFollowEventsNext = (event: FollowEventRpc) => {\n      if (isOperationEvent(event)) {\n        if (!subscriptions.has(event.operationId))\n          console.warn(\"Uknown operationId on\", event)\n\n        return subscriptions.next(event.operationId, event)\n      }\n\n      if (event.event !== \"stop\") {\n        if (event.event === \"initialized\") {\n          return onFollowEvent({\n            type: event.event,\n            finalizedBlockHashes: event.finalizedBlockHashes,\n            finalizedBlockRuntime: (event as any).finalizedBlockRuntime,\n          })\n        }\n\n        const { event: type, ...rest } = event\n        // This is kinda dangerous, but YOLO\n        return onFollowEvent({ type, ...rest } as any)\n      }\n\n      onFollowError(new StopError())\n      unfollow(false)\n    }\n\n    const onAllFollowEventsError = (error: Error) => {\n      onFollowError(error)\n      unfollow(!(error instanceof DestroyedError))\n    }\n\n    const onFollowRequestSuccess = (\n      subscriptionId: string,\n      follow: FollowSubscriptionCb<FollowEventRpc>,\n    ) => {\n      const done = follow(subscriptionId, {\n        next: onAllFollowEventsNext,\n        error: onAllFollowEventsError,\n      })\n\n      unfollow = (sendUnfollow = true) => {\n        followSubscription = null\n        unfollow = noop\n        done()\n        sendUnfollow && request(chainHead.unfollow, [subscriptionId])\n        subscriptions.errorAll(new DisjointError())\n        ongoingRequests.forEach((cb) => {\n          cb()\n        })\n        ongoingRequests.clear()\n      }\n\n      followSubscription = subscriptionId\n      deferredFollow.res(subscriptionId)\n    }\n\n    const onFollowRequestError = (e: Error) => {\n      if (e instanceof DestroyedError) {\n        unfollow(false)\n      } else {\n        onFollowError(e)\n      }\n      followSubscription = null\n      deferredFollow.res(e)\n    }\n\n    let unfollow: (internal?: boolean) => void = request(\n      chainHead.follow,\n      [withRuntime],\n      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError },\n    )\n\n    const fRequest: ClientInnerRequest<any, any> = (method, params, cb) => {\n      const disjoint = () => {\n        cb?.onError(new DisjointError())\n      }\n\n      if (followSubscription === null) {\n        disjoint()\n        return noop\n      }\n\n      const onSubscription = (subscription: string) => {\n        if (!cb) return request(method, [subscription, ...params])\n\n        ongoingRequests.add(disjoint)\n\n        const onSubscribeOperation = (\n          operationId: string,\n          subscriber: Subscriber<any>,\n        ) => {\n          if (followSubscription === null) {\n            subscriber.error(new DisjointError())\n            return noop\n          }\n\n          subscriptions.subscribe(operationId, subscriber)\n\n          return () => {\n            subscriptions.unsubscribe(operationId)\n          }\n        }\n\n        const cleanup = request(method, [subscription, ...params], {\n          onSuccess: (response) => {\n            ongoingRequests.delete(disjoint)\n            cb.onSuccess(response, onSubscribeOperation)\n          },\n          onError: (e) => {\n            ongoingRequests.delete(disjoint)\n            cb.onError(e)\n          },\n        })\n\n        return () => {\n          ongoingRequests.delete(disjoint)\n          cleanup()\n        }\n      }\n\n      if (typeof followSubscription === \"string\")\n        return onSubscription(followSubscription)\n\n      let onCancel = noop\n      followSubscription.then((x) => {\n        if (x instanceof Error) return disjoint()\n        if (followSubscription) onCancel = onSubscription(x)\n      })\n\n      return () => {\n        onCancel()\n      }\n    }\n\n    return {\n      unfollow() {\n        unfollow()\n        followSubscription = null\n      },\n      body: createBodyFn(fRequest),\n      call: createCallFn(fRequest),\n      header: createHeaderFn(fRequest),\n      storage: createStorageFn(fRequest),\n      storageSubscription: createStorageCb(fRequest),\n      unpin: createUnpinFn(fRequest),\n      _request: fRequest,\n    }\n  }\n}\n", "export interface IRpcError {\n  code: number\n  message: string\n  data?: any\n}\n\nexport class RpcError extends Error implements IRpcError {\n  code\n  data\n  constructor(e: IRpcError) {\n    super(e.message)\n    this.code = e.code\n    this.data = e.data\n    this.name = \"RpcError\"\n  }\n}\n", "import type {\n  JsonRpcConnection,\n  JsonRpcProvider,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { UnsubscribeFn } from \"../common-types\"\nimport { RpcError, IRpcError } from \"./RpcError\"\nimport { getSubscriptionsManager, Subscriber } from \"@/internal-utils\"\nimport { DestroyedError } from \"./DestroyedError\"\n\nexport type FollowSubscriptionCb<T> = (\n  subscriptionId: string,\n  cb: Subscriber<T>,\n) => UnsubscribeFn\n\nexport type ClientRequestCb<T, TT> = {\n  onSuccess: (result: T, followSubscription: FollowSubscriptionCb<TT>) => void\n  onError: (e: Error) => void\n}\n\nexport type ClientRequest<T, TT> = (\n  method: string,\n  params: Array<any>,\n  cb?: ClientRequestCb<T, TT>,\n) => UnsubscribeFn\n\nexport interface Client {\n  disconnect: () => void\n  request: ClientRequest<any, any>\n}\n\nlet nextClientId = 1\nexport const createClient = (gProvider: JsonRpcProvider): Client => {\n  let clientId = nextClientId++\n  const responses = new Map<string, ClientRequestCb<any, any>>()\n  const subscriptions = getSubscriptionsManager()\n\n  let connection: JsonRpcConnection | null = null\n\n  const send = (\n    id: string,\n    method: string,\n    params: Array<boolean | string | number | null>,\n  ) => {\n    connection!.send(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method,\n        params,\n      }),\n    )\n  }\n\n  function onMessage(message: string): void {\n    try {\n      let id: string,\n        result,\n        error: IRpcError | undefined,\n        params: { subscription: any; result: any; error?: IRpcError },\n        subscription: string\n\n      const parsed = JSON.parse(message)\n      ;({ id, result, error, params } = parsed)\n\n      if (id) {\n        const cb = responses.get(id)\n        if (!cb) return\n\n        responses.delete(id)\n\n        return error\n          ? cb.onError(new RpcError(error))\n          : cb.onSuccess(result, (opaqueId, subscriber) => {\n              const subscriptionId = opaqueId\n              subscriptions.subscribe(subscriptionId, subscriber)\n              return () => {\n                subscriptions.unsubscribe(subscriptionId)\n              }\n            })\n      }\n\n      // at this point, it means that it should be a notification\n      ;({ subscription, result, error } = params)\n      if (!subscription || (!error && !Object.hasOwn(params, \"result\"))) throw 0\n\n      const subscriptionId = subscription\n\n      if (error) {\n        subscriptions.error(subscriptionId, new RpcError(error!))\n      } else {\n        subscriptions.next(subscriptionId, result)\n      }\n    } catch (e) {\n      console.warn(\"Error parsing incomming message: \" + message)\n      console.error(e)\n    }\n  }\n  connection = gProvider(onMessage)\n\n  const disconnect = () => {\n    connection?.disconnect()\n    connection = null\n    subscriptions.errorAll(new DestroyedError())\n    responses.forEach((r) => r.onError(new DestroyedError()))\n    responses.clear()\n  }\n\n  let nextId = 1\n  const request = <T, TT>(\n    method: string,\n    params: Array<any>,\n    cb?: ClientRequestCb<T, TT>,\n  ): UnsubscribeFn => {\n    if (!connection) throw new Error(\"Not connected\")\n    const id = `${clientId}-${nextId++}`\n\n    if (cb) responses.set(id, cb)\n    send(id, method, params)\n\n    return (): void => {\n      responses.delete(id)\n    }\n  }\n\n  return {\n    request,\n    disconnect,\n  }\n}\n", "import { ClientRequest } from \"./client\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { chainSpec } from \"./methods\"\n\nexport interface ChainSpecData {\n  name: string\n  genesisHash: string\n  properties: any\n}\n\nexport const createGetChainSpec = (clientRequest: ClientRequest<any, any>) => {\n  const request = abortablePromiseFn(\n    <T>(\n      onSuccess: (value: T) => void,\n      onError: (e: any) => void,\n      method: string,\n      params: any[],\n    ) => clientRequest(method, params, { onSuccess, onError }),\n  )\n  let cachedPromise: null | Promise<ChainSpecData> = null\n\n  return async (): Promise<ChainSpecData> => {\n    if (cachedPromise) return cachedPromise\n    return (cachedPromise = Promise.all([\n      request<string>(chainSpec.chainName, []),\n      request<string>(chainSpec.genesisHash, []),\n      request<any>(chainSpec.properties, []),\n    ]).then(([name, genesisHash, properties]) => ({\n      name,\n      genesisHash,\n      properties,\n    })))\n  }\n}\n", "import type { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport { getTransaction } from \"./transaction/transaction\"\nimport { getChainHead } from \"./chainhead\"\nimport { ClientRequestCb, createClient as createRawClient } from \"./client\"\nimport type { ChainHead } from \"./chainhead\"\nimport type { Transaction } from \"./transaction\"\nimport { UnsubscribeFn } from \"./common-types\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { ChainSpecData, createGetChainSpec } from \"./chainspec\"\n\nexport { AbortError } from \"@polkadot-api/utils\"\nexport type * from \"@polkadot-api/json-rpc-provider\"\n\nexport type * from \"./common-types\"\nexport type * from \"./client\"\nexport type * from \"./transaction\"\nexport type * from \"./chainhead\"\nexport type * from \"./chainspec\"\n\nexport { RpcError, DestroyedError } from \"./client\"\nexport {\n  StopError,\n  DisjointError,\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./chainhead\"\n\nexport interface SubstrateClient {\n  chainHead: ChainHead\n  transaction: Transaction\n  destroy: UnsubscribeFn\n  getChainSpecData: () => Promise<ChainSpecData>\n  request: <T>(\n    method: string,\n    params: any[],\n    abortSignal?: AbortSignal,\n  ) => Promise<T>\n  _request: <Reply, Notification>(\n    method: string,\n    params: any[],\n    cb?: ClientRequestCb<Reply, Notification>,\n  ) => UnsubscribeFn\n}\n\nconst clientCache = new Map<\n  JsonRpcProvider,\n  { client: SubstrateClient; refCount: number }\n>()\n\nexport const createClient = (provider: JsonRpcProvider): SubstrateClient => {\n  const cached = clientCache.get(provider)\n  if (cached) {\n    cached.refCount++\n    return cached.client\n  }\n\n  const { request, disconnect } = createRawClient(provider)\n  const destroy = () => {\n    const cached = clientCache.get(provider)\n    if (!cached || cached.refCount <= 1) {\n      clientCache.delete(provider)\n      disconnect()\n    } else {\n      cached.refCount--\n    }\n  }\n  const client: SubstrateClient = {\n    chainHead: getChainHead(request),\n    transaction: getTransaction(request),\n    getChainSpecData: createGetChainSpec(request),\n    destroy,\n    request: abortablePromiseFn(\n      <T>(\n        onSuccess: (value: T) => void,\n        onError: (e: any) => void,\n        method: string,\n        params: any[],\n      ) => request(method, params, { onSuccess, onError }),\n    ),\n    _request: request,\n  }\n  clientCache.set(provider, { client, refCount: 1 })\n  return client\n}\n", "import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    let isOperationLimit = false\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        ;(isOperationLimit = e instanceof OperationLimitError)\n          ? addTask(data, true)\n          : observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    if (!subscription.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n        onEmptySlot()\n      })\n    } else if (!isOperationLimit) onEmptySlot()\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n", "export class BlockNotPinnedError extends Error {\n  constructor(hash: string, label: string) {\n    super(`Block ${hash} is not pinned (${label})`)\n    this.name = \"BlockNotPinnedError\"\n  }\n}\n", "import {\n  MonoTypeOperatorFunction,\n  Observable,\n  catchError,\n  concatMap,\n  mergeMap,\n  take,\n  throwError,\n  timer,\n} from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\n\nconst dynamicBlocks = new Set([\"best\", \"finalized\", null])\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const getWithOptionalhash$ = (\n  finalized$: Observable<string>,\n  best$: Observable<string>,\n  usingBlock: <T>(blockHash: string) => MonoTypeOperatorFunction<T>,\n) => {\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) => {\n      if (!dynamicBlocks.has(hash))\n        return operable(fn(hash as string, ...args)).pipe(\n          usingBlock(hash as string),\n        )\n\n      const hash$ = hash === \"best\" ? best$ : finalized$\n      const result$: Observable<T> = hash$.pipe(\n        take(1),\n        mergeMap((h) => fn(h, ...args).pipe(usingBlock(h))),\n        catchError((e) => {\n          return e instanceof BlockNotPinnedError\n            ? result$\n            : throwError(() => e)\n        }),\n      )\n      return operable(result$)\n    }\n}\n", "import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n", "import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n", "import { Observable, ObservedValueOf, Subscription } from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { PinnedBlocks } from \"../streams\"\n\nexport function withStopRecovery<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n  label: string,\n) {\n  return (hash: string, ...args: A) => {\n    const source$ = fn(hash, ...args)\n\n    return new Observable<ObservedValueOf<typeof source$>>((observer) => {\n      let sourceSub: Subscription | null = null\n      let isSubscribed = false\n      const performSourceSub = () => {\n        if (isSubscribed) return\n        isSubscribed = true\n        sourceSub = source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => observer.error(e),\n          complete: () => observer.complete(),\n        })\n        sourceSub.add(() => {\n          isSubscribed = false\n          sourceSub = null\n        })\n      }\n\n      let isRecovering = false\n      const blockSub = blocks$.subscribe({\n        next: (v) => {\n          const block = v.blocks.get(hash)\n          if (!block) {\n            // This branch used to conflict with BlockPrunedError, as the block might disappear when it gets pruned\n            // We can avoid this conflict by checking that we're actually recovering.\n            if (isRecovering) {\n              observer.error(new BlockNotPinnedError(hash, label))\n            }\n          } else if (block.recovering) {\n            // Pause while it's recovering, as we don't know if the block is there\n            sourceSub?.unsubscribe()\n          } else {\n            performSourceSub()\n          }\n          isRecovering = v.recovering\n        },\n        error: (e) => observer.error(e),\n      })\n\n      return () => {\n        blockSub.unsubscribe()\n        sourceSub?.unsubscribe()\n      }\n    })\n  }\n}\n", "import { mergeMap, Observable, scan, share } from \"rxjs\"\nimport { BlockInfo } from \"./chainHead\"\nimport { PinnedBlocks } from \"./streams\"\n\nexport const getNewBlocks$ = (pinnedBlocks$: Observable<PinnedBlocks>) =>\n  pinnedBlocks$.pipe(\n    scan(\n      ({ reportedBlocks: prevReportedBlocks }, { blocks }) => {\n        const reportedBlocks = new Set<string>(blocks.keys())\n        const newBlocks: BlockInfo[] = []\n\n        if (reportedBlocks.size > prevReportedBlocks.size) {\n          blocks.forEach(({ hash, number, parent }) => {\n            if (!prevReportedBlocks.has(hash)) {\n              newBlocks.push({\n                hash,\n                number,\n                parent,\n              })\n            }\n          })\n        }\n\n        return { reportedBlocks, newBlocks }\n      },\n      {\n        reportedBlocks: new Set<string>(),\n        newBlocks: new Array<BlockInfo>(0),\n      },\n    ),\n    mergeMap(({ newBlocks }) => newBlocks),\n    share(),\n  )\n", "import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            // TODO: leave it like this b/c due to a bug on\n            // PolkadotSDK sometimes this value is `undefined`\n            // https://github.com/paritytech/polkadot-sdk/issues/6683\n            if (nDiscarded > 0)\n              observer.next(\n                recoveralStorage$(\n                  hash,\n                  queries.slice(-nDiscarded),\n                  childTrie,\n                  true,\n                ),\n              )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n", "import { BlockHeader, blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  BestBlockChanged,\n  ChainHead,\n  Finalized,\n  FollowEventWithRuntime,\n  FollowResponse,\n  Initialized,\n  NewBlockWithRuntime,\n  StopError,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ObservedValueOf,\n  Subscription,\n  connectable,\n  noop,\n} from \"rxjs\"\n\ntype EnhancedFollowEventWithRuntime =\n  | (Initialized & {\n      number: number\n      parentHash: string\n    })\n  | NewBlockWithRuntime\n  | BestBlockChanged\n  | Finalized\n\nconst withInitializedNumber =\n  (getHeader: (hash: string) => Promise<BlockHeader>) =>\n  (source$: Observable<FollowEventWithRuntime>) =>\n    new Observable<EnhancedFollowEventWithRuntime>((observer) => {\n      let pending: Array<EnhancedFollowEventWithRuntime> | null = null\n      return source$.subscribe({\n        next(event) {\n          if (event.type === \"initialized\") {\n            pending = []\n            getHeader(event.finalizedBlockHashes[0])\n              .then((header) => {\n                if (!observer.closed) {\n                  observer.next({\n                    ...event,\n                    number: header.number,\n                    parentHash: header.parentHash,\n                  })\n                  pending!.forEach((e) => {\n                    observer.next(e)\n                  })\n                  pending = null\n                }\n              })\n              .catch((e) => {\n                if (!observer.closed) observer.error(e)\n              })\n          } else if (pending) pending.push(event)\n          else observer.next(event)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n    })\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse | null = null\n  let unfollow: () => void = noop\n\n  const getFollower = () => {\n    if (!follower) throw new Error(\"Missing chainHead subscription\")\n    return follower\n  }\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const follow$ = connectable(\n    new Observable<FollowEventWithRuntime>((observer) => {\n      follower = chainHead(\n        true,\n        (e) => {\n          observer.next(e)\n        },\n        (e) => {\n          follower = null\n          observer.error(e)\n        },\n      )\n      unfollow = () => {\n        observer.complete()\n        follower?.unfollow()\n      }\n    }).pipe(withInitializedNumber(getHeader), retryChainHeadError()),\n  )\n\n  const startFollow = () => {\n    follow$.connect()\n    return () => {\n      unfollow()\n    }\n  }\n\n  return {\n    getHeader,\n    getFollower,\n    startFollow,\n    follow$,\n  }\n}\n\nconst retryChainHeadError =\n  <T extends { type: string }>() =>\n  (source$: Observable<T>) =>\n    new Observable<\n      | T\n      | {\n          type: \"stop-error\"\n        }\n    >((observer) => {\n      const subscription = new Subscription()\n      const subscribe = () =>\n        source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => {\n            subscription.add(subscribe())\n            if (e instanceof StopError) {\n              observer.next({ type: \"stop-error\" })\n            } else {\n              console.warn(\"ChainHead follow request failed, retrying…\", e)\n            }\n          },\n          complete: () => observer.complete(),\n        })\n      subscription.add(subscribe())\n      return subscription\n    })\n\nexport type FollowEvent =\n  | ObservedValueOf<ReturnType<ReturnType<typeof withInitializedNumber>>>\n  | { type: \"stop-error\" }\n", "import {\n  getDynamicBuilder,\n  getLookupFn,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  AccountId,\n  Binary,\n  Bytes,\n  Codec,\n  Decoder,\n  HexString,\n  metadata as metadataCodec,\n  Option,\n  SS58String,\n  u32,\n  UnifiedMetadata,\n  unifyMetadata,\n  Vector,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport {\n  catchError,\n  EMPTY,\n  map,\n  mergeMap,\n  Observable,\n  of,\n  shareReplay,\n  tap,\n  timer,\n} from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<Binary>\n}\n\nexport interface RuntimeContext {\n  metadataRaw: Uint8Array\n  lookup: MetadataLookup\n  codeHash: HexString\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  assetId: number | null\n}\n\nexport interface Runtime {\n  at: string\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst versionedArgs = (v: number) => toHex(u32.enc(v))\nconst opaqueBytes = Bytes()\nconst optionalOpaqueBytes = Option(opaqueBytes)\nconst u32ListDecoder = Vector(u32).dec\n\nexport const getRuntimeCreator = (\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  getCodeHash$: (blockHash: string) => Observable<string>,\n  getCachedMetadata: (codeHash: string) => Observable<Uint8Array | null>,\n  setCachedMetadata: (codeHash: string, metadataRaw: Uint8Array) => void,\n) => {\n  const getMetadata$ = (\n    getHash: () => string | null,\n  ): Observable<{\n    metadataRaw: Uint8Array\n    metadata: UnifiedMetadata\n    codeHash: string\n  }> => {\n    const withRecovery = <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ): ((...args: Args) => Observable<T>) => {\n      const result: (...args: Args) => Observable<T> = (...args) => {\n        const hash = getHash()\n        return hash\n          ? fn(hash, ...args).pipe(\n              catchError((e) => {\n                if (e instanceof BlockNotPinnedError) return result(...args)\n                if (e instanceof OperationInaccessibleError)\n                  return timer(750).pipe(mergeMap(() => result(...args)))\n                throw e\n              }),\n            )\n          : EMPTY\n      }\n      return result\n    }\n\n    const recoverCall$ = withRecovery(call$)\n    const recoverCodeHash$ = withRecovery(getCodeHash$)\n\n    const versions$ = recoverCall$(\"Metadata_metadata_versions\", \"\").pipe(\n      map(u32ListDecoder),\n      catchError(() => of([14])),\n    )\n    const versioned$ = (availableVersions: number[]) => {\n      const [v] = availableVersions\n        .filter((x) => x > 13 && x < 17)\n        .sort((a, b) => b - a)\n      return v === 14\n        ? recoverCall$(\"Metadata_metadata\", \"\").pipe(map(opaqueBytes.dec))\n        : recoverCall$(\"Metadata_metadata_at_version\", versionedArgs(v)).pipe(\n            map((x) => optionalOpaqueBytes.dec(x)!),\n          )\n    }\n    const metadataRaw$ = versions$.pipe(mergeMap(versioned$))\n\n    return recoverCodeHash$().pipe(\n      mergeMap((codeHash) =>\n        getCachedMetadata(codeHash).pipe(\n          catchError(() => of(null)),\n          mergeMap((metadataRaw) =>\n            metadataRaw\n              ? of(metadataRaw)\n              : metadataRaw$.pipe(\n                  tap((raw) => {\n                    setCachedMetadata(codeHash, raw)\n                  }),\n                ),\n          ),\n          map((metadataRaw) => ({\n            codeHash,\n            metadataRaw,\n            metadata: unifyMetadata(metadataCodec.dec(metadataRaw)),\n          })),\n        ),\n      ),\n    )\n  }\n\n  return (getHash: () => string | null): Runtime => {\n    const initialHash = getHash()!\n    const usages = new Set<string>([initialHash])\n\n    const runtimeContext$: Observable<RuntimeContext> = getMetadata$(\n      getHash,\n    ).pipe(\n      map(({ metadata, metadataRaw, codeHash }) => {\n        const lookup = getLookupFn(metadata)\n        const dynamicBuilder = getDynamicBuilder(lookup)\n        const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n        const assetPayment = metadata.extrinsic.signedExtensions.find(\n          (x) => x.identifier === \"ChargeAssetTxPayment\",\n        )\n\n        let assetId: null | number = null\n        if (assetPayment) {\n          const assetTxPayment = lookup(assetPayment.type)\n          if (assetTxPayment.type === \"struct\") {\n            const optionalAssetId = assetTxPayment.value.asset_id\n            if (optionalAssetId.type === \"option\")\n              assetId = optionalAssetId.value.id\n          }\n        }\n\n        return {\n          assetId,\n          metadataRaw,\n          codeHash,\n          lookup,\n          dynamicBuilder,\n          events: {\n            key: events.keys.enc(),\n            dec: events.value.dec as any,\n          },\n          accountId: AccountId(dynamicBuilder.ss58Prefix),\n        }\n      }),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: initialHash,\n      runtime: runtimeContext$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe({\n      error() {},\n    })\n\n    return result\n  }\n}\n", "import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n", "import { shareLatest } from \"@/utils\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  Observable,\n  Subject,\n  exhaustMap,\n  filter,\n  map,\n  merge,\n  scan,\n  timer,\n} from \"rxjs\"\nimport { withStopRecovery } from \"../enhancers\"\nimport type { FollowEvent } from \"./follow\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  unpinnable: boolean\n  refCount: number\n  recovering: boolean\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\ninterface CleanupEvent {\n  type: \"cleanup\"\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n  recovering: boolean\n}\n\nconst createRuntimeGetter = (pinned: PinnedBlocks, startAt: HexString) => {\n  return () => {\n    const runtime = pinned.runtimes[startAt]\n    if (!runtime) return pinned.blocks.has(startAt) ? startAt : null\n    const winner = [...runtime.usages].at(-1)\n    return winner ?? null\n  }\n}\n\nconst deleteBlock = (blocks: PinnedBlocks[\"blocks\"], blockHash: string) => {\n  blocks.get(blocks.get(blockHash)!.parent)?.children.delete(blockHash)\n  blocks.delete(blockHash)\n}\n\nconst deleteBlocks = (blocks: PinnedBlocks, toDelete: string[]) => {\n  toDelete.forEach((hash) => {\n    deleteBlock(blocks.blocks, hash)\n  })\n\n  Object.entries(blocks.runtimes)\n    .map(([key, value]) => ({\n      key,\n      usages: value.deleteBlocks(toDelete),\n    }))\n    .filter((x) => x.usages === 0)\n    .map((x) => x.key)\n    .forEach((unusedRuntime) => {\n      delete blocks.runtimes[unusedRuntime]\n    })\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEvent>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  getCodeHash$: (blockHash: string) => Observable<string>,\n  getCachedMetadata$: (codeHash: string) => Observable<Uint8Array | null>,\n  setCachedMetadata: (codeHash: string, metadataRaw: Uint8Array) => void,\n  blockUsage$: Subject<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n  deleteFromCache: (block: string) => void,\n) => {\n  const cleanup$ = new Subject<void>()\n  const cleanupEvt$ = cleanup$.pipe(\n    exhaustMap(() => timer(0)),\n    map(\n      (): CleanupEvent => ({\n        type: \"cleanup\" as const,\n      }),\n    ),\n  )\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    cleanupEvt$,\n    follow$,\n  ).pipe(\n    scan((acc, event) => {\n      const unpinAndDelete = (toUnpin: string[]) => {\n        deleteBlocks(acc, toUnpin)\n        onUnpin(toUnpin)\n      }\n\n      switch (event.type) {\n        case \"initialized\":\n          if (acc.recovering) {\n            const isConnected = event.finalizedBlockHashes.some((hash) =>\n              acc.blocks.has(hash),\n            )\n            if (!isConnected) {\n              acc = getInitialPinnedBlocks()\n            }\n          }\n\n          const [finalizedHash] = event.finalizedBlockHashes.slice(-1)\n          acc.finalized = acc.best = finalizedHash\n\n          const lastIdx = event.finalizedBlockHashes.length - 1\n          event.finalizedBlockHashes.forEach((hash, i) => {\n            const preexistingBlock = acc.blocks.get(hash)\n            if (preexistingBlock) {\n              preexistingBlock.recovering = false\n              preexistingBlock.unpinnable = i !== lastIdx\n            } else {\n              acc.blocks.set(hash, {\n                hash: hash,\n                parent:\n                  i === 0\n                    ? event.parentHash\n                    : event.finalizedBlockHashes[i - 1],\n                children: new Set(\n                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]],\n                ),\n                unpinnable: i !== lastIdx,\n                runtime: hash,\n                refCount: 0,\n                number: event.number + i,\n                recovering: false,\n              })\n            }\n          })\n\n          const finalizedRuntime = Object.values(acc.runtimes).find((runtime) =>\n            runtime.usages.has(finalizedHash),\n          )\n\n          acc.finalizedRuntime =\n            finalizedRuntime ??\n            (acc.runtimes[finalizedHash] = getRuntime(\n              createRuntimeGetter(acc, finalizedHash),\n            ))\n\n          return acc\n\n        case \"stop-error\":\n          for (const block of acc.blocks.values()) {\n            block.recovering = true\n          }\n          acc.recovering = true\n\n          return acc\n\n        case \"newBlock\": {\n          const { parentBlockHash: parent, blockHash: hash } = event\n          if (acc.blocks.has(hash)) {\n            acc.blocks.get(hash)!.recovering = false\n          } else {\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              unpinnable: false,\n              refCount: 0,\n              recovering: false,\n            }\n            acc.blocks.set(hash, block)\n            if (event.newRuntime) {\n              // getRuntime calls getHash immediately\n              // it assumes pinnedBlocks.runtimes[hash] is empty and pinnedBlocks.blocks.has(hash)\n              acc.runtimes[hash] = getRuntime(createRuntimeGetter(acc, hash))\n            }\n            acc.runtimes[block.runtime].addBlock(hash)\n          }\n\n          return acc\n        }\n\n        case \"bestBlockChanged\": {\n          if (acc.recovering) {\n            for (const [hash, block] of acc.blocks) {\n              if (block.recovering) {\n                deleteBlock(acc.blocks, hash)\n                deleteFromCache(hash)\n              }\n            }\n            acc.recovering = false\n          }\n          acc.best = event.bestBlockHash\n          return acc\n        }\n\n        case \"finalized\": {\n          acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n          const { blocks } = acc\n\n          // This logic is only needed because of a bug on some pretty old versions\n          // of the polkadot-sdk node. However, fixing it with an enhancer\n          // was a huge PITA. Therefore, it's more pragmatic to address it here\n          if (blocks.get(acc.best)!.number < blocks.get(acc.finalized)!.number)\n            acc.best = acc.finalized\n\n          acc.finalizedRuntime =\n            acc.runtimes[blocks.get(acc.finalized)!.runtime]\n\n          event.prunedBlockHashes.forEach((hash) => {\n            const block = acc.blocks.get(hash)\n            if (block) {\n              block.unpinnable = true\n            }\n          })\n\n          let current = blocks.get(blocks.get(acc.finalized)!.parent)\n          while (current && !current.unpinnable) {\n            current.unpinnable = true\n            current = blocks.get(current.parent)\n          }\n\n          cleanup$.next()\n\n          return acc\n        }\n        case \"cleanup\": {\n          const toUnpin = [...acc.blocks.values()]\n            .filter(({ unpinnable, refCount }) => unpinnable && !refCount)\n            .map(({ hash }) => hash)\n\n          unpinAndDelete(toUnpin)\n          return acc\n        }\n        case \"blockUsage\": {\n          if (!acc.blocks.has(event.value.hash)) return acc\n\n          const block = acc.blocks.get(event.value.hash)!\n          block.refCount += event.value.type === \"hold\" ? 1 : -1\n          if (block.refCount === 0 && !block.recovering && block.unpinnable) {\n            const toUnpin = [block.hash]\n            unpinAndDelete(toUnpin)\n          }\n          return acc\n        }\n      }\n    }, getInitialPinnedBlocks()),\n    filter((x) => !!x.finalizedRuntime.runtime),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntime = getRuntimeCreator(\n    withStopRecovery(pinnedBlocks$, call$, \"pinned-blocks\"),\n    withStopRecovery(pinnedBlocks$, getCodeHash$, \"pinned-blocks\"),\n    getCachedMetadata$,\n    setCachedMetadata,\n  )\n  return pinnedBlocks$\n}\n\nconst getInitialPinnedBlocks = (): PinnedBlocks => ({\n  best: \"\",\n  finalized: \"\",\n  runtimes: {},\n  blocks: new Map(),\n  finalizedRuntime: {} as Runtime,\n  recovering: false,\n})\n", "import {\n  Observable,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { HexString, ResultPayload } from \"@polkadot-api/substrate-bindings\"\n\nexport type AnalyzedBlock = {\n  hash: HexString\n  found:\n    | {\n        type: true\n        index: number\n        events: any\n      }\n    | {\n        type: false\n        validity: ResultPayload<any, any> | null // null means that the block was already present when the tx was broadcasted\n      }\n}\n\nexport const getTrackTx = (\n  blocks$: Observable<PinnedBlocks>,\n  getBody: (block: string) => Observable<string[]>, // Returns an observable that should emit just once and complete\n  getIsValid: (\n    block: string,\n    tx: string,\n  ) => Observable<ResultPayload<any, any>>, // Returns an observable that should emit just once and complete\n  getEvents: (block: string) => Observable<any>, // Returns an observable that should emit just once and complete\n) => {\n  const whileBlockPresent = <TT>(\n    hash: string,\n  ): (<T = TT>(base: Observable<T>) => Observable<T>) =>\n    takeUntil(blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))))\n\n  const analyzeBlock = (\n    hash: string,\n    tx: string,\n    alreadyPresent: boolean,\n  ): Observable<AnalyzedBlock> => {\n    if (alreadyPresent)\n      return of({ hash, found: { type: false, validity: null } })\n\n    const whilePresent = whileBlockPresent(hash)\n    return getBody(hash).pipe(\n      mergeMap((txs) => {\n        const index = txs.indexOf(tx)\n        return index > -1\n          ? whilePresent(getEvents(hash)).pipe(\n              map((events) => ({\n                hash,\n                found: {\n                  type: true as true,\n                  index,\n                  events,\n                },\n              })),\n            )\n          : getIsValid(hash, tx).pipe(\n              map((validity) => ({\n                hash,\n                found: { type: false as false, validity },\n              })),\n            )\n      }),\n      whilePresent,\n    )\n  }\n\n  const findInBranch = (\n    hash: string,\n    tx: string,\n    alreadyPresent: Set<string>,\n  ): Observable<AnalyzedBlock> =>\n    analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(\n      mergeMap((analyzed) => {\n        const { found } = analyzed\n        return found.type || found.validity?.success === false\n          ? of(analyzed)\n          : blocks$.pipe(\n              whileBlockPresent(hash),\n              mergeMap((x) => x.blocks.get(hash)!.children),\n              distinct(),\n              mergeMap((hash) => findInBranch(hash, tx, alreadyPresent)),\n            )\n      }),\n    )\n\n  return (tx: string): Observable<AnalyzedBlock> =>\n    blocks$.pipe(\n      take(1),\n      mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys()))),\n    )\n}\n", "import { Observable, map, withLatestFrom } from \"rxjs\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  _void,\n  createDecoder,\n  Decoder,\n  ResultPayload,\n  u8,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { RuntimeContext } from \"./streams\"\n\nconst external = new Uint8Array([2])\n\nconst getValidateTxArgs = (tx: string, hash: string) =>\n  toHex(mergeUint8(external, fromHex(tx), fromHex(hash)))\n\nconst TaggedTransactionQueue = \"TaggedTransactionQueue\"\nconst validateTransaction = \"validate_transaction\"\n\nconst [, defaultInvalidTxDecoder] = Variant({\n  InvalidTransaction: Variant({\n    Call: _void,\n    Payment: _void,\n    Future: _void,\n    Stale: _void,\n    BadProof: _void,\n    AncientBirthBlock: _void,\n    ExhaustsResources: _void,\n    Custom: u8,\n    BadMandatory: _void,\n    MandatoryValidation: _void,\n    BadSigner: _void,\n  }),\n  UnknownTransaction: Variant({\n    CannotLookup: _void,\n    NoUnsignedValidator: _void,\n    Custom: u8,\n  }),\n})\nconst defaultValidateTxDecoder: Decoder<ResultPayload<undefined, any>> =\n  createDecoder((input) => {\n    const firstByte = u8.dec(input)\n    if (firstByte > 1)\n      throw new Error(\"Unable to decode validateTransaction result\")\n\n    if (!firstByte) return { success: true, value: undefined }\n    let value: any\n    try {\n      value = defaultInvalidTxDecoder(input)\n    } catch (_) {\n      value = {\n        type: \"UnknownInvalidTx\",\n      }\n    }\n    return { success: false, value }\n  })\n\nexport const getValidateTx =\n  (\n    call$: (\n      hash: string | null,\n      fnName: string,\n      parameters: string,\n    ) => Observable<string>,\n    getRuntimeContext: (hash: string) => Observable<RuntimeContext>,\n  ) =>\n  (blockHash: string, tx: string): Observable<ResultPayload<any, any>> => {\n    const decoder$ = getRuntimeContext(blockHash).pipe(\n      map((ctx) => {\n        try {\n          return ctx.dynamicBuilder.buildRuntimeCall(\n            TaggedTransactionQueue,\n            validateTransaction,\n          ).value[1] as Decoder<ResultPayload<any, any>>\n        } catch (_) {\n          return defaultValidateTxDecoder\n        }\n      }),\n    )\n    return call$(\n      blockHash,\n      `${TaggedTransactionQueue}_${validateTransaction}`,\n      getValidateTxArgs(tx, blockHash),\n    ).pipe(\n      withLatestFrom(decoder$),\n      map(([result, decoder]) => decoder(result)),\n    )\n  }\n", "import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n", "import { Observable } from \"rxjs\"\n\nexport const delayUnsubscription =\n  (ms?: number) =>\n  <T>(source: Observable<T>): Observable<T> =>\n    new Observable((observer) => {\n      const subscription = source.subscribe({\n        next(v) {\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n      const unsubscribe = () => subscription.unsubscribe()\n      return () => {\n        if (ms != null) setTimeout(unsubscribe, ms)\n        else Promise.resolve().then(unsubscribe)\n      }\n    })\n", "import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n\n        let isCompleted = false\n        let subscription = inner$.subscribe({\n          next(x: O) {\n            if (observerIdx === idx) {\n              observer.next(x)\n            } else {\n              results.get(idx)!.push(x)\n            }\n          },\n          complete() {\n            isCompleted = true\n            innerSubscriptions.delete(idx)\n            if (idx === observerIdx) {\n              observerIdx++\n              while (results.has(observerIdx)) {\n                results.get(observerIdx)!.forEach((x) => observer.next(x))\n                results.delete(observerIdx)\n                if (innerSubscriptions.has(observerIdx)) {\n                  break\n                }\n                observerIdx++\n              }\n            }\n            nextSubscription()\n          },\n          error(e: any) {\n            observer.error(e)\n          },\n        })\n\n        if (!isCompleted) innerSubscriptions.set(idx, subscription)\n      }\n\n      // Cover synchronous path sub => nextSubscription => no new values => if (topSubscription == null) complete()\n      topSubscription = new Subscription()\n      topSubscription.add(\n        source$.subscribe({\n          next(outterValue: I) {\n            const idx = mapperIdx++\n            queues.set(\n              idx,\n              defer(() => mapper(outterValue, idx)),\n            )\n            if (innerSubscriptions.size < concurrent) {\n              nextSubscription()\n            }\n          },\n          error(e: any) {\n            observer.error(e)\n          },\n          complete() {\n            if (innerSubscriptions.size === 0) {\n              observer.complete()\n            }\n          },\n        }),\n      )\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n", "import { concatMapEager, delayUnsubscription, shareLatest } from \"@/utils\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  MonoTypeOperatorFunction,\n  Observable,\n  ReplaySubject,\n  Subject,\n  defer,\n  distinctUntilChanged,\n  filter,\n  map,\n  merge,\n  mergeAll,\n  mergeMap,\n  noop,\n  of,\n  scan,\n  share,\n  shareReplay,\n  switchMap,\n  take,\n  tap,\n} from \"rxjs\"\n\nimport { withDefaultValue } from \"@/utils\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withLazyFollower,\n  withStopRecovery,\n} from \"./enhancers\"\nimport { BlockNotPinnedError } from \"./errors\"\nimport { getNewBlocks$ } from \"./new-blocks\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport type {\n  BlockUsageEvent,\n  PinnedBlock,\n  PinnedBlocks,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport { getTrackTx } from \"./track-tx\"\nimport { getValidateTx } from \"./validate-tx\"\n\nexport type {\n  FollowEventWithRuntime,\n  PinnedBlock,\n  PinnedBlocks,\n  RuntimeContext,\n  SystemEvent,\n}\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (\n  chainHead: ChainHead,\n  getCachedMetadata: (codeHash: string) => Observable<Uint8Array | null>,\n  setCachedMetadata: (codeHash: string, metadataRaw: Uint8Array) => void,\n) => {\n  const { getFollower, startFollow, follow$, getHeader } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const holdBlock = (hash: string) => {\n    blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n    return () => {\n      setTimeout(() => {\n        blockUsage$.next({\n          type: \"blockUsage\",\n          value: { type: \"release\", hash },\n        })\n      }, 0)\n    }\n  }\n\n  const usingBlock: <T>(blockHash: string) => MonoTypeOperatorFunction<T> =\n    (blockHash: string) => (base) =>\n      new Observable((observer) => {\n        const release = holdBlock(blockHash)\n        const subscription = base.subscribe(observer)\n        subscription.add(release)\n        return subscription\n      })\n\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      fn(hash, ...args).pipe(usingBlock(hash))\n\n  const withInMemory =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n      label: string,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        let isPresent = false\n        pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {\n          isPresent = blocks.blocks.has(hash)\n        })\n\n        return isPresent\n          ? fn(hash, ...args).subscribe(observer)\n          : observer.error(new BlockNotPinnedError(hash, label))\n      })\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n    label: string,\n  ) =>\n    withInMemory(\n      withRefcount(\n        withStopRecovery(\n          pinnedBlocks$,\n          withRecoveryFn(fromAbortControllerFn(fn)),\n          `stop-${label}`,\n        ),\n      ),\n      label,\n    )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n\n  const stg = withRefcount(\n    withRecoveryFn(fromAbortControllerFn(lazyFollower(\"storage\"))),\n  )\n  const getCodeHash = (blockHash: string): Observable<HexString> =>\n    // \":code\" => \"0x3a636f6465\"\n    stg(blockHash, \"hash\", \"0x3a636f6465\", null).pipe(map((x) => x!))\n\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\")))),\n    getCodeHash,\n    getCachedMetadata,\n    setCachedMetadata,\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n    (block) => {\n      cache.delete(block)\n    },\n  )\n\n  const getRuntimeContext$ = withRefcount((hash: string) =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(\n        (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n      ),\n    ),\n  )\n\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const hashCache = cache.get(hash) ?? new Map()\n    const cached = hashCache.get(key)\n    if (cached) return cached\n\n    cache.set(hash, hashCache)\n\n    let connector: ReplaySubject<T>\n    const result = stream.pipe(\n      share({\n        connector: () => (connector = new ReplaySubject()),\n      }),\n      tap({\n        complete() {\n          hashCache.set(key, connector)\n        },\n      }),\n      delayUnsubscription(),\n    )\n    hashCache.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    filter((x) => !x.recovering),\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    scan((acc, value) => {\n      let current = value.blocks.get(value.finalized)!\n      const result = [current]\n\n      const latest = acc.at(-1)\n      if (!latest) return result\n\n      while (current.number > latest.number + 1) {\n        current = value.blocks.get(current.parent)!\n        if (!current) break\n        result.unshift(current)\n      }\n      return result\n    }, [] as PinnedBlock[]),\n    mergeAll(),\n    map(toBlockInfo),\n    shareLatest,\n  )\n\n  const best$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.best === b.best),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    filter((x) => !x.recovering),\n    distinctUntilChanged(\n      (prev, current) =>\n        prev.finalized === current.finalized && prev.best === current.best,\n    ),\n    scan((acc, pinned) => {\n      const getBlockInfo = (hash: string) =>\n        acc.get(hash) || toBlockInfo(pinned.blocks.get(hash)!)\n\n      const best = getBlockInfo(pinned.best)\n      const finalized = getBlockInfo(pinned.finalized)\n\n      const len = best.number - finalized.number + 1\n      const result = new Array<BlockInfo>(len)\n      for (let i = 0, hash = best.hash; i < len; i++) {\n        result[i] = getBlockInfo(hash)\n        hash = result[i].parent\n      }\n\n      return new Map(result.map((b) => [b.hash, b]))\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.lookup.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((b) => b.hash)),\n    best$.pipe(map((b) => b.hash)),\n    usingBlock,\n  )\n\n  const _body$ = withOptionalHash$(commonEnhancer(lazyFollower(\"body\"), \"body\"))\n  const body$ = (hash: string) => upsertCachedStream(hash, \"body\", _body$(hash))\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"), \"storage\")\n\n  const storage$ = withOptionalHash$(\n    <\n      Type extends StorageItemInput[\"type\"],\n      M extends\n        | undefined\n        | ((data: StorageResult<Type>, ctx: RuntimeContext) => any),\n    >(\n      hash: string,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: M,\n    ): Observable<\n      undefined extends M\n        ? StorageResult<Type>\n        : { raw: StorageResult<Type>; mapped: ReturnType<NonNullable<M>> }\n    > =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n        mergeMap((ctx) => {\n          const key = keyMapper(ctx)\n          const unMapped$ = upsertCachedStream(\n            hash,\n            `storage-${type}-${key}-${childTrie ?? \"\"}`,\n            _storage$(hash, type, key, childTrie),\n          )\n\n          return mapper\n            ? upsertCachedStream(\n                hash,\n                `storage-${type}-${key}-${childTrie ?? \"\"}-dec`,\n                unMapped$.pipe(\n                  map((raw) => ({ raw, mapped: mapper(raw, ctx) })),\n                ),\n              )\n            : unMapped$\n        }),\n      ) as Observable<\n        undefined extends M\n          ? StorageResult<Type>\n          : { raw: StorageResult<Type>; mapped: ReturnType<NonNullable<M>> }\n      >,\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOptionalHash$(\n    withStopRecovery(\n      pinnedBlocks$,\n      (hash: string, queries: Array<StorageItemInput>, childTrie?: string) =>\n        recoveralStorage$(hash, queries, childTrie ?? null, false),\n      `storageQueries`,\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withStopRecovery(\n      pinnedBlocks$,\n      (hash: string) => defer(() => getHeader(hash)),\n      \"header\",\n    ),\n  )\n\n  const eventsAt$ = (hash: string | null) =>\n    storage$(\n      hash,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    ).pipe(map((x) => x.mapped))\n\n  const __call$ = commonEnhancer(lazyFollower(\"call\"), \"call\")\n  const call$ = withOptionalHash$((hash: string, fn: string, args: string) =>\n    upsertCachedStream(hash, `call-${fn}-${args}`, __call$(hash, fn, args)),\n  )\n\n  const validateTx$ = getValidateTx(call$, getRuntimeContext$)\n\n  const innerBody$ = (hash: string) =>\n    upsertCachedStream(hash, \"body\", _body$(hash))\n\n  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$)\n  const trackTxWithoutEvents$ = getTrackTx(\n    pinnedBlocks$,\n    innerBody$,\n    validateTx$,\n    () => of(),\n  )\n\n  const genesis$ = runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    mergeMap((runtime) => {\n      const { enc } = runtime.dynamicBuilder.buildStorage(\n        \"System\",\n        \"BlockHash\",\n      ).keys\n      // const genesis$ =\n      // there are chains (e.g. kilt) that use u64 as block number\n      // u64 is encoded as bigint\n      // using dynamic builder for safety\n      let key: string\n      try {\n        // for u32\n        key = enc(0)\n      } catch {\n        // for u64\n        key = enc(0n)\n      }\n\n      return storage$(null, \"value\", () => key, null) as Observable<HexString>\n    }),\n    shareReplay(1),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe({\n    error() {},\n  })\n\n  let unfollow = noop\n  let started: boolean | null = false\n  let nSubscribers: number = 0\n  const start = (_nSubscribers: number) => {\n    nSubscribers += _nSubscribers\n    started = true\n\n    unfollow = startFollow()\n  }\n\n  return [\n    {\n      follow$,\n      finalized$,\n      best$,\n      bestBlocks$,\n      newBlocks$: getNewBlocks$(pinnedBlocks$),\n      runtime$,\n      metadata$,\n      genesis$,\n\n      header$,\n      body$,\n      call$,\n      storage$,\n      storageQueries$,\n      eventsAt$,\n\n      holdBlock,\n      trackTx$,\n      trackTxWithoutEvents$,\n      validateTx$,\n      pinnedBlocks$,\n      withRuntime,\n      getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n      unfollow: () => {\n        if (started == null) return\n        nSubscribers--\n        if (started && !nSubscribers) {\n          started = null\n          unfollow()\n          unfollow = noop\n        }\n      },\n    },\n    start,\n  ] as const\n}\n\nexport type ChainHead$ = ReturnType<typeof getChainHead$>[0]\n", "import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<never>((observer) =>\n      baseTransaction(transaction, (e) => {\n        observer.error(e)\n      }),\n    )\n", "import type {\n  SubstrateClient,\n  UnsubscribeFn,\n} from \"@polkadot-api/substrate-client\"\nimport { noop, Observable, of } from \"rxjs\"\nimport { ChainHead$, getChainHead$ } from \"./chainHead\"\nimport getBroadcastTx$ from \"./tx\"\n\nconst ofNullFn = () => of(null)\n\nexport interface ObservableClient {\n  chainHead$: (nSubscribers?: number) => ChainHead$\n  broadcastTx$: (transaction: string) => Observable<never>\n  destroy: UnsubscribeFn\n}\n\nconst clientCache = new Map<\n  SubstrateClient,\n  { client: ObservableClient; refCount: number }\n>()\n\nexport const getObservableClient = (\n  substrateClient: SubstrateClient,\n  cache: Partial<{\n    getMetadata: (codeHash: string) => Observable<Uint8Array | null>\n    setMetadata: (codeHash: string, rawMetadata: Uint8Array) => void\n  }> = {},\n): ObservableClient => {\n  const { getMetadata, setMetadata } = cache\n  const cached = clientCache.get(substrateClient)\n  if (cached) {\n    cached.refCount++\n    return cached.client\n  }\n\n  const destroy = () => {\n    const cached = clientCache.get(substrateClient)\n    if (!cached || cached.refCount <= 1) {\n      clientCache.delete(substrateClient)\n      substrateClient.destroy()\n    } else {\n      cached.refCount--\n    }\n  }\n\n  let cachedChainhead:\n    | readonly [ChainHead$, (nSubscribers: number) => void]\n    | null = null\n  let currentSubscribers = 0\n  let expectedSubscribers: null | number = null\n\n  const client: ObservableClient = {\n    chainHead$: (_expectedSubscribers) => {\n      currentSubscribers++\n      expectedSubscribers ||= _expectedSubscribers || 1\n      cachedChainhead ||= getChainHead$(\n        substrateClient.chainHead,\n        getMetadata || ofNullFn,\n        setMetadata || noop,\n      )\n      const [result, start] = cachedChainhead\n      if (expectedSubscribers === currentSubscribers) {\n        const copiedCurrentSubscribers = currentSubscribers\n        currentSubscribers = 0\n        expectedSubscribers = null\n        cachedChainhead = null\n        start(copiedCurrentSubscribers)\n      }\n      return result\n    },\n    broadcastTx$: getBroadcastTx$(substrateClient.transaction),\n    destroy,\n  }\n\n  clientCache.set(substrateClient, { client, refCount: 1 })\n  return client\n}\n", "import { Observable, distinctUntilChanged, map, takeWhile } from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isBestOrFinalizedBlock = (\n  blocks$: Observable<PinnedBlocks>,\n  blockHash: string,\n) =>\n  blocks$.pipe(\n    takeWhile((b) => b.blocks.has(blockHash)),\n    distinctUntilChanged(\n      (a, b) => a.finalized === b.finalized && a.best === b.best,\n    ),\n    map((pinned): \"best\" | \"finalized\" | null => {\n      if (\n        pinned.blocks.get(blockHash)!.number >\n        pinned.blocks.get(pinned.best)!.number\n      )\n        return null\n\n      const { number } = pinned.blocks.get(blockHash)!\n      let current = pinned.blocks.get(pinned.best)!\n      let isFinalized = pinned.finalized === current.hash\n      while (current.number > number) {\n        current = pinned.blocks.get(current.parent)!\n        isFinalized = isFinalized || pinned.finalized === current.hash\n      }\n      if (isFinalized) return \"finalized\"\n      return current.hash === blockHash ? \"best\" : null\n    }),\n    distinctUntilChanged(),\n    takeWhile((x) => x !== \"finalized\", true),\n  )\n", "import { MetadataLookup } from \"@polkadot-api/metadata-builders\"\nimport {\n  CompatibilityCache,\n  CompatibilityLevel,\n  EntryPoint,\n  EntryPointCodec,\n  TypedefCodec,\n  TypedefNode,\n  entryPointsAreCompatible,\n  mapLookupToTypedef,\n  valueIsCompatibleWithDest,\n} from \"@polkadot-api/metadata-compatibility\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { Tuple, Vector } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, combineLatest, filter, firstValueFrom, map } from \"rxjs\"\nimport { ChainDefinition } from \"./descriptors\"\n\nexport class RuntimeToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _runtime(value: D) {}\n}\n\nexport class CompatibilityToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _compatibility(value: D) {}\n}\n\ninterface RuntimeTokenApi {\n  runtime: () => RuntimeContext\n}\ninterface CompatibilityTokenApi extends RuntimeTokenApi {\n  typedefNodes: TypedefNode[]\n  getEntryPoint: (opType: OpType, pallet: string, name: string) => EntryPoint\n}\nconst compatibilityTokenApi = new WeakMap<\n  CompatibilityToken,\n  CompatibilityTokenApi\n>()\nconst runtimeTokenApi = new WeakMap<RuntimeToken, RuntimeTokenApi>()\nexport const getCompatibilityApi = (\n  token: RuntimeToken | CompatibilityToken,\n): RuntimeTokenApi | CompatibilityTokenApi =>\n  token instanceof RuntimeToken\n    ? runtimeTokenApi.get(token)!\n    : compatibilityTokenApi.get(token)!\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Const = \"constants\",\n  ViewFns = \"viewFns\",\n  Api = \"apis\",\n}\n\nconst EntryPointsCodec = Vector(EntryPointCodec)\nconst TypedefsCodec = Vector(TypedefCodec)\nconst TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec)\n\nexport const createCompatibilityToken = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ChainHead$,\n): Promise<CompatibilityToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = Promise.all([\n    chainDefinition.metadataTypes.then(TypesCodec.dec),\n    chainDefinition.descriptors,\n    awaitedRuntime,\n  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {\n    const token = new (CompatibilityToken as any)()\n    compatibilityTokenApi.set(token, {\n      runtime,\n      getEntryPoint(opType, pallet, name) {\n        const idx = descriptors[opType]?.[pallet]?.[name]\n        if (idx == null)\n          throw new Error(\n            `Descriptor for ${opType} ${pallet}.${name} does not exist`,\n          )\n        return entryPoints[idx]\n      },\n      typedefNodes,\n    })\n\n    return token\n  })\n\n  return promise\n}\n\nexport const createRuntimeToken = <D>(\n  chainHead: ChainHead$,\n): Promise<RuntimeToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = awaitedRuntime.then((runtime) => {\n    const token = new (RuntimeToken as any)()\n    runtimeTokenApi.set(token, {\n      runtime,\n    })\n    return token\n  })\n\n  return promise\n}\n\n// metadataRaw -> cache\nconst metadataCache = new WeakMap<\n  Uint8Array,\n  {\n    compat: CompatibilityCache\n    lookup: MetadataLookup\n    typeNodes: (TypedefNode | null)[]\n  }\n>()\nconst getMetadataCache = (ctx: RuntimeContext) => {\n  if (!metadataCache.has(ctx.metadataRaw)) {\n    metadataCache.set(ctx.metadataRaw, {\n      compat: new Map(),\n      lookup: ctx.lookup,\n      typeNodes: [],\n    })\n  }\n  return metadataCache.get(ctx.metadataRaw)!\n}\nexport const compatibilityHelper = (\n  descriptors: Promise<RuntimeToken | CompatibilityToken>,\n  getDescriptorEntryPoint: (descriptorApi: CompatibilityTokenApi) => EntryPoint,\n  getRuntimeEntryPoint: (ctx: RuntimeContext) => EntryPoint | null,\n) => {\n  const getRuntimeTypedef = (ctx: RuntimeContext, id: number) => {\n    const cache = getMetadataCache(ctx)\n    return (cache.typeNodes[id] ||= mapLookupToTypedef(cache.lookup(id)))\n  }\n\n  function getCompatibilityLevels(\n    descriptors: CompatibilityToken | RuntimeToken,\n    /**\n     * The `Runtime` of runtimeWithDescriptors already has a RuntimeContext,\n     * which is the runtime of the finalized block.\n     * But on some cases, the user wants to perform an action on a specific\n     * block hash, which has a different RuntimeContext.\n     */\n    ctx?: RuntimeContext,\n  ) {\n    if (descriptors instanceof RuntimeToken) {\n      return {\n        args: CompatibilityLevel.Identical,\n        values: CompatibilityLevel.Identical,\n      }\n    }\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n    ctx ||= compatibilityApi.runtime()\n    const runtimeEntryPoint = getRuntimeEntryPoint(ctx)\n    if (runtimeEntryPoint == null)\n      return {\n        args: CompatibilityLevel.Incompatible,\n        values: CompatibilityLevel.Incompatible,\n      }\n    const descriptorNodes = compatibilityApi.typedefNodes\n\n    const cache = getMetadataCache(ctx)\n\n    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi)\n    return entryPointsAreCompatible(\n      descriptorEntryPoint,\n      (id) => descriptorNodes[id],\n      runtimeEntryPoint,\n      (id) => getRuntimeTypedef(ctx, id),\n      cache.compat,\n    )\n  }\n\n  const getCompatibilityLevel = withOptionalToken(descriptors, (runtime) =>\n    minCompatLevel(getCompatibilityLevels(runtime)),\n  )\n  const isCompatible = withOptionalToken(\n    descriptors,\n    (threshold: CompatibilityLevel, runtime) =>\n      getCompatibilityLevel(runtime) >= threshold,\n  )\n\n  const compatibleRuntime$ = (chainHead: ChainHead$, hash: string | null) =>\n    combineLatest([descriptors, chainHead.getRuntimeContext$(hash)])\n\n  const withCompatibleRuntime =\n    <T>(chainHead: ChainHead$, mapper: (x: T) => string) =>\n    (\n      source$: Observable<T>,\n    ): Observable<[T, CompatibilityToken | RuntimeToken, RuntimeContext]> =>\n      combineLatest([\n        source$.pipe(chainHead.withRuntime(mapper)),\n        descriptors,\n      ]).pipe(map(([[x, ctx], descriptors]) => [x, descriptors, ctx]))\n\n  const argsAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    args: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const levels = getCompatibilityLevels(descriptors, ctx)\n    if (levels.args === CompatibilityLevel.Incompatible) return false\n    if (levels.args > CompatibilityLevel.Partial) return true\n    // Although technically args could still be compatible, if the output will be incompatible we might as well just return false to skip sending the request.\n    if (levels.values === CompatibilityLevel.Incompatible) return false\n\n    const entryPoint = getRuntimeEntryPoint(ctx)\n    if (entryPoint == null) return false\n\n    return valueIsCompatibleWithDest(\n      entryPoint.args,\n      (id) => getRuntimeTypedef(ctx, id),\n      args,\n    )\n  }\n  const valuesAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    values: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const level = getCompatibilityLevels(descriptors, ctx).values\n    if (level === CompatibilityLevel.Incompatible) return false\n    if (level > CompatibilityLevel.Partial) return true\n\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n\n    const entryPoint = getDescriptorEntryPoint(compatibilityApi)\n\n    return valueIsCompatibleWithDest(\n      entryPoint.values,\n      (id) => compatibilityApi.typedefNodes[id],\n      values,\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors,\n    withCompatibleRuntime,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n    getRuntimeTypedef,\n  }\n}\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n\nexport const minCompatLevel = (levels: {\n  args: CompatibilityLevel\n  values: CompatibilityLevel\n}) => Math.min(levels.args, levels.values)\n\nconst withOptionalToken =\n  <T, D, A extends [...any[], CompatibilityToken | RuntimeToken]>(\n    compatibilityToken: Promise<CompatibilityToken<D> | RuntimeToken<D>>,\n    fn: (...args: A) => T,\n  ): WithOptionalRuntime<T, D, A extends [...infer R, any] ? R : []> =>\n  (...args: any): any => {\n    const lastElement = args.at(-1)\n    if (\n      lastElement instanceof CompatibilityToken ||\n      lastElement instanceof RuntimeToken\n    ) {\n      return fn(...args)\n    }\n    return compatibilityToken.then((token) => (fn as any)(...args, token))\n  }\n\nexport type WithOptionalRuntime<T, D, A extends any[]> = {\n  /**\n   * Returns the result after waiting for the runtime to load.\n   */\n  (...args: A): Promise<T>\n  /**\n   * Returns the result synchronously with the loaded runtime.\n   */\n  (...args: [...A, runtime: CompatibilityToken<D> | RuntimeToken<D>]): T\n}\n\nexport interface CompatibilityFunctions<D> {\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   */\n  getCompatibilityLevel(): Promise<CompatibilityLevel>\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   *\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  getCompatibilityLevel(\n    compatibilityToken: CompatibilityToken<D>,\n  ): CompatibilityLevel\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold  CompatibilityLevel threshold to use, inclusive.\n   */\n  isCompatible(threshold: CompatibilityLevel): Promise<boolean>\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold           CompatibilityLevel threshold to use,\n   *                            inclusive.\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  isCompatible(\n    threshold: CompatibilityLevel,\n    compatibilityToken: CompatibilityToken<D>,\n  ): boolean\n}\n", "import { RuntimeContext } from \"@polkadot-api/observable-client\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"./compatibility\"\n\nexport type ConstantEntry<Unsafe, D, T> = Unsafe extends true\n  ? {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (runtimeToken: RuntimeToken): T\n    }\n  : {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (compatibilityToken: CompatibilityToken): T\n    } & CompatibilityFunctions<D>\n\nexport const createConstantEntry = <D, T>(\n  palletName: string,\n  name: string,\n  {\n    valuesAreCompatible,\n    descriptors,\n    isCompatible,\n    getCompatibilityLevel,\n  }: CompatibilityHelper,\n): ConstantEntry<any, D, T> => {\n  const cachedResults = new WeakMap<RuntimeContext, T>()\n  const getValueWithContext = (ctx: RuntimeContext) => {\n    if (cachedResults.has(ctx)) {\n      return cachedResults.get(ctx)!\n    }\n\n    const pallet = ctx.lookup.metadata.pallets.find(\n      (p) => p.name === palletName,\n    )\n    const constant = pallet?.constants.find((c) => c.name === name)\n    if (constant == null)\n      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`)\n    const result = ctx.dynamicBuilder\n      .buildConstant(palletName, name)\n      .dec(constant.value)\n    cachedResults.set(ctx, result)\n    return result\n  }\n\n  const fn = (token?: CompatibilityToken | RuntimeToken): any => {\n    if (token) {\n      const ctx = getCompatibilityApi(token).runtime()\n      const value = getValueWithContext(ctx)\n      if (!valuesAreCompatible(token, ctx, value))\n        throw new Error(\n          `Incompatible runtime entry Constant(${palletName}.${name})`,\n        )\n      return value\n    }\n    return descriptors.then(fn)\n  }\n\n  return Object.assign(fn, { isCompatible, getCompatibilityLevel })\n}\n", "import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n", "import { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { concatMapEager, shareLatest } from \"./utils\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<Unsafe, D, T> = {\n  /**\n   * Multicast and stateful Observable watching for new events (matching the\n   * event kind chosen) in the latest known `finalized` block.\n   *\n   * @param filter  Optional filter function to only emit events complying\n   *                with the function.\n   */\n  watch: EvWatch<T>\n  /**\n   * Fetch (Promise-based) all events (matching the event kind chosen) available\n   * in the latest known `finalized` block.\n   */\n  pull: EvPull<T>\n  /**\n   * Filter a bunch of `SystemEvent` and return the decoded `payload` of every\n   * of them.\n   *\n   * @param collection  Array of `SystemEvent` to filter.\n   */\n  filter: EvFilter<T>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <D, T>(\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    withCompatibleRuntime,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): EvClient<any, D, T> => {\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n  const shared$ = chainHead.finalized$.pipe(\n    withCompatibleRuntime(chainHead, (x) => x.hash),\n    map(([block, runtime, ctx]) => {\n      const eventsIdx = ctx.lookup.metadata.pallets.find(\n        (p) => p.name === pallet,\n      )?.events?.type\n      if (\n        eventsIdx == null ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.tag !== \"variant\" ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.value.find(\n          (ev) => ev.name === name,\n        ) == null\n      )\n        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`)\n\n      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError()\n      return [block, runtime, ctx] as const\n    }),\n    concatMapEager(([block, runtime, ctx]) =>\n      chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))\n              throw compatibilityError()\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter, getCompatibilityLevel, isCompatible }\n}\n", "import { AbortError } from \"@polkadot-api/utils\"\nimport { Observable, Subscription, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let subscription: Subscription | null = null\n    let isDone = false\n\n    const onAbort = signal\n      ? () => {\n          subscription?.unsubscribe()\n          reject(new AbortError())\n        }\n      : noop\n\n    subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n        subscription?.unsubscribe()\n        isDone = true\n      },\n      error: (e) => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(e)\n        isDone = true\n      },\n      complete: () => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(new Error(\"Observable completed without emitting\"))\n        isDone = true\n      },\n    })\n\n    // the observable could have emitted synchronously\n    if (!isDone) signal?.addEventListener(\"abort\", onAbort)\n  })\n}\n", "export const isOptionalArg = (lastArg: unknown) =>\n  typeof lastArg === \"object\" &&\n  lastArg !== null &&\n  Object.entries(lastArg).every(\n    ([k, v]) =>\n      (k === \"at\" && (v === undefined || typeof v === \"string\")) ||\n      (k === \"signal\" && (v === undefined || v instanceof AbortSignal)),\n  )\n", "import { firstValueFromWithSignal, isOptionalArg } from \"@/utils\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport type RuntimeCall<Unsafe, D, Args extends Array<any>, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the runtime call.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport const createRuntimeCallEntry = (\n  api: string,\n  method: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): RuntimeCall<any, any, any, any> => {\n  const callName = `${api}_${method}`\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at).pipe(\n      mergeMap(([runtime, ctx]) => {\n        let codecs\n        try {\n          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        } catch {\n          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`)\n        }\n        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError()\n        return chainHead.call$(at, callName, toHex(codecs.args.enc(args))).pipe(\n          map(codecs.value.dec),\n          map((value) => {\n            if (!valuesAreCompatible(runtime, ctx, value))\n              throw compatibilityError()\n            return value\n          }),\n        )\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { getCompatibilityLevel, isCompatible })\n}\n", "import { Observable, Subscription } from \"rxjs\"\n\nconst EMPTY_VALUE = Symbol(\"EMPTY_VALUE\")\ntype EMPTY_VALUE = typeof EMPTY_VALUE\n\nexport const lossLessExhaustMap =\n  <I, O>(mapper: (x: I, idx: number) => Observable<O>) =>\n  (source$: Observable<I>): Observable<O> =>\n    new Observable((observer) => {\n      let idx = 0\n      let innerSubscription: Subscription | null = null\n      let queuedValue: I | EMPTY_VALUE = EMPTY_VALUE\n      let isOutterDone = false\n\n      const setInnerSubscription = () => {\n        const observable = mapper(queuedValue as I, idx++)\n        queuedValue = EMPTY_VALUE\n        innerSubscription = observable.subscribe({\n          next(vv) {\n            observer.next(vv)\n          },\n          error(ee) {\n            observer.error(ee)\n          },\n          complete() {\n            if (queuedValue !== EMPTY_VALUE) setInnerSubscription()\n            else {\n              innerSubscription = null\n              if (isOutterDone) observer.complete()\n            }\n          },\n        })\n      }\n\n      const subscription = source$.subscribe({\n        next(v) {\n          queuedValue = v\n          if (!innerSubscription) setInnerSubscription()\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (!innerSubscription) observer.complete()\n          isOutterDone = true\n        },\n      })\n\n      return () => {\n        innerSubscription?.unsubscribe()\n        subscription.unsubscribe()\n      }\n    })\n", "import {\n  firstValueFromWithSignal,\n  isOptionalArg,\n  lossLessExhaustMap,\n} from \"@/utils\"\nimport { CompatibilityLevel } from \"@polkadot-api/metadata-compatibility\"\nimport {\n  BlockInfo,\n  BlockNotPinnedError,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport { FixedSizeBinary } from \"@polkadot-api/substrate-bindings\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  OperatorFunction,\n  combineLatestWith,\n  distinctUntilChanged,\n  filter,\n  from,\n  identity,\n  map,\n  mergeMap,\n  pipe,\n  shareReplay,\n  take,\n} from \"rxjs\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  minCompatLevel,\n} from \"./compatibility\"\nimport { createWatchEntries } from \"./watch-entries\"\n\ntype CallOptions = Partial<{\n  /**\n   * `at` could be a blockHash, `best`, or `finalized` (default)\n   */\n  at: string\n  /**\n   * `signal` allows you to abort an ongoing Promise. See [MDN\n   * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for\n   * more information\n   */\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype WithWatchOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: { at: \"best\" },\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : ArrayPossibleParents<A>\n\n// Fixed-size arrays values can't be extracted one-by-one, so that's a specific case\ntype ArrayPossibleParents<\n  A extends Array<any>,\n  Count extends Array<any> = [],\n  R = [],\n> = A extends Array<infer T> & { length: infer L }\n  ? number extends L\n    ? Array<T> // Case variable-size array it's an unknown amount of entries\n    : L extends Count[\"length\"]\n      ? R\n      : ArrayPossibleParents<A, [...Count, T], R | Count>\n  : never\n\ntype StorageEntryWithoutKeys<Unsafe, D, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: CallOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntryWithKeys<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  Payload,\n  ArgsOut extends Array<any>,\n> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: ArgsOut; value: NonNullable<Payload> }>>\n  /**\n   * Watch changes (Observable-based) for the storage entries with a subset of\n   * `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set whether to watch against the\n   *              `best` block.\n   *              By default watches changes against the finalized block.\n   *              When watching changes against the \"best\" block, this API\n   *              gratiously handles the re-orgs and provides the deltas\n   *              based on the latest emission.\n   *              The observed value contains the following properties:\n   *              - `block`: the block in where the `deltas` took place -\n   *              `deltas`: `null` indicates that nothing has changed from\n   *              the latest emission.\n   *              If the value is not `null` then the `deleted` and `upsrted`\n   *              properties indicate the entries that have changed.\n   *              - `entries`: it's an immutable data-structure with the\n   *              latest entries.\n   * @example\n   *\n   *   typedApi.query.Staking.Nominators.watchEntries()\n   *   typedApi.query.Staking.Nominators.watchEntries({ at: \"best\" })\n   *\n   */\n  watchEntries: (\n    ...args: WithWatchOptions<PossibleParents<Args>>\n  ) => Observable<{\n    block: BlockInfo\n    deltas: null | {\n      deleted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n      upserted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n    }\n    entries: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n  }>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntry<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  ArgsOut extends Array<any>,\n  Payload,\n> = Args extends []\n  ? StorageEntryWithoutKeys<Unsafe, D, Payload>\n  : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst toMapped = map(<T>(x: { mapped: T }) => x.mapped)\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  getWatchEntries: ReturnType<typeof createWatchEntries>,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors: descriptorsPromise,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): StorageEntry<any, any, any, any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const isBlockHash = pallet === \"System\" && name === \"BlockHash\"\n  const sysNumberMapper$ = chainHead.runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    map(({ dynamicBuilder }) =>\n      typeof dynamicBuilder\n        .buildStorage(\"System\", \"Number\")\n        .value.dec(new Uint8Array(32)) === \"bigint\"\n        ? BigInt\n        : identity,\n    ),\n    shareReplay(),\n  )\n  const bigIntOrNumber: OperatorFunction<number, number | bigint> = pipe(\n    combineLatestWith(sysNumberMapper$),\n    map(([input, mapper]) => mapper(input)),\n  )\n\n  const incompatibleError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const getCodec = (ctx: RuntimeContext) => {\n    try {\n      return ctx.dynamicBuilder.buildStorage(pallet, name)\n    } catch (e: any) {\n      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`)\n    }\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const isBest = target === \"best\"\n    const actualArgs =\n      isBest || target === \"finalized\" ? args.slice(0, -1) : args\n\n    return chainHead[isBest ? \"best$\" : \"finalized$\"].pipe(\n      lossLessExhaustMap(() =>\n        getRawValue$(...actualArgs, isBest ? { at: \"best\" } : {}),\n      ),\n      distinctUntilChanged((a, b) => a.raw === b.raw),\n      toMapped,\n    )\n  }\n\n  const getRawValue$ = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    if (isSystemNumber)\n      return chainHead.pinnedBlocks$.pipe(\n        map((blocks) => {\n          const hash =\n            at === \"finalized\" || !at\n              ? blocks.finalized\n              : at === \"best\"\n                ? blocks.best\n                : at\n          const block = blocks.blocks.get(hash)\n          if (!block) {\n            throw new BlockNotPinnedError(hash, \"System.Number\")\n          }\n          return block.number\n        }),\n        distinctUntilChanged(),\n        bigIntOrNumber,\n        map((mapped) => ({ raw: mapped, mapped })),\n      )\n\n    if (isBlockHash && Number(args[0]) === 0) {\n      return chainHead.genesis$.pipe(\n        map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) })),\n      ) as Observable<any>\n    }\n\n    return from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"value\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            const actualArgs =\n              args.length === codecs.len ? args : args.slice(0, -1)\n            if (args !== actualArgs && !isLastArgOptional)\n              throw invalidArgs(args)\n            if (!argsAreCompatible(descriptors, ctx, actualArgs))\n              throw incompatibleError()\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (data, ctx) => {\n            const codecs = getCodec(ctx)\n            const value =\n              data === null ? codecs.fallback : codecs.value.dec(data)\n            if (!valuesAreCompatible(descriptors, ctx, value))\n              throw incompatibleError()\n            return value\n          },\n        ),\n      ),\n    )\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal }: CallOptions = isLastArgOptional ? lastArg : {}\n\n    return firstValueFromWithSignal(\n      getRawValue$(...args).pipe(toMapped),\n      signal,\n    )\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const descriptors = await descriptorsPromise\n    const result$ = chainHead\n      .storage$(\n        at,\n        \"descendantsValues\",\n        (ctx) => {\n          const codecs = getCodec(ctx)\n          // TODO partial compatibility check for args that become optional\n          if (\n            minCompatLevel(getCompatibilityLevels(descriptors, ctx)) ===\n            CompatibilityLevel.Incompatible\n          )\n            throw incompatibleError()\n\n          if (args.length > codecs.len) throw invalidArgs(args)\n          const actualArgs =\n            args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n          if (args.length === codecs.len && actualArgs === args)\n            throw invalidArgs(args)\n          return codecs.keys.enc(...actualArgs)\n        },\n        null,\n        (values, ctx) => {\n          const codecs = getCodec(ctx)\n          const decodedValues = values.map(({ key, value }) => ({\n            keyArgs: codecs.keys.dec(key),\n            value: codecs.value.dec(value),\n          }))\n          if (\n            decodedValues.some(\n              ({ value }) => !valuesAreCompatible(descriptors, ctx, value),\n            )\n          )\n            throw incompatibleError()\n          return decodedValues\n        },\n      )\n      .pipe(toMapped)\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  const watchEntries: any = (...args: Array<any>) => {\n    const lastArg = args.at(-1)\n    const isLastArgOptional = isOptionalArg(lastArg)\n\n    return getWatchEntries(\n      pallet,\n      name,\n      isLastArgOptional ? args.slice(0, -1) : args,\n      isLastArgOptional && lastArg.at === \"best\",\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getValue,\n    getValues,\n    getEntries,\n    watchValue,\n    watchEntries,\n  }\n}\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getSignBytes, createV4Tx } from \"@polkadot-api/signers-common\"\nimport {\n  Blake2256,\n  decAnyMetadata,\n  unifyMetadata,\n} from \"@polkadot-api/substrate-bindings\"\nimport { merkleizeMetadata } from \"@polkadot-api/merkleize-metadata\"\n\nexport function getPolkadotSigner(\n  publicKey: Uint8Array,\n  signingType: \"Ecdsa\" | \"Ed25519\" | \"Sr25519\",\n  sign: (input: Uint8Array) => Promise<Uint8Array> | Uint8Array,\n): PolkadotSigner {\n  const signTx = async (\n    callData: Uint8Array,\n    signedExtensions: Record<\n      string,\n      {\n        identifier: string\n        value: Uint8Array\n        additionalSigned: Uint8Array\n      }\n    >,\n    metadata: Uint8Array,\n    _: number,\n    hasher = Blake2256,\n  ) => {\n    const decMeta = unifyMetadata(decAnyMetadata(metadata))\n    const extra: Array<Uint8Array> = []\n    const additionalSigned: Array<Uint8Array> = []\n    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {\n      const signedExtension = signedExtensions[identifier]\n      if (!signedExtension)\n        throw new Error(`Missing ${identifier} signed extension`)\n      extra.push(signedExtension.value)\n      additionalSigned.push(signedExtension.additionalSigned)\n    })\n\n    const toSign = mergeUint8(callData, ...extra, ...additionalSigned)\n    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign)\n    return createV4Tx(decMeta, publicKey, signed, extra, callData, signingType)\n  }\n\n  return {\n    publicKey,\n    signTx,\n    signBytes: getSignBytes(sign),\n  }\n}\n\nconst METADATA_IDENTIFIER = \"CheckMetadataHash\"\nconst oneU8 = Uint8Array.from([1])\n\nexport const withMetadataHash = (\n  networkInfo: Parameters<typeof merkleizeMetadata>[1],\n  base: PolkadotSigner,\n): PolkadotSigner => ({\n  ...base,\n  signTx: async (callData, signedExtensions, metadata, ...rest) =>\n    base.signTx(\n      callData,\n      signedExtensions[METADATA_IDENTIFIER]\n        ? {\n            ...signedExtensions,\n            [METADATA_IDENTIFIER]: {\n              identifier: METADATA_IDENTIFIER,\n              value: oneU8,\n              additionalSigned: mergeUint8(\n                oneU8,\n                merkleizeMetadata(metadata, networkInfo).digest(),\n              ),\n            },\n          }\n        : signedExtensions,\n      metadata,\n      ...rest,\n    ),\n})\n", "import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\n\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\nexport const getSystemVersionStruct = (\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n): Record<string, any> => {\n  const constant = lookupFn.metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"Version\")!\n\n  const systemVersion = lookupFn(constant.type)\n  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec\n\n  if (systemVersion.type !== \"struct\") throw new Error(\"not a struct\")\n  return systemVersionDec(constant.value)\n}\n", "import { Bytes, enhanceEncoder, u16 } from \"@polkadot-api/substrate-bindings\"\n\nfunction trailingZeroes(n: number) {\n  let i = 0\n  while (!(n & 1)) {\n    i++\n    n >>= 1\n  }\n  return i\n}\n\nconst nextPower = (n: number) => 1 << Math.ceil(Math.log2(n))\n\nexport const mortal = enhanceEncoder(\n  Bytes(2)[0],\n  (value: { period: number; startAtBlock: number }) => {\n    const period = Math.min(Math.max(nextPower(value.period), 4), 1 << 16)\n    const phase = value.startAtBlock % period\n    const factor = Math.max(period >> 12, 1)\n    const left = Math.min(Math.max(trailingZeroes(period) - 1, 1), 15)\n    const right = (phase / factor) << 4\n    return u16[0](left | right)\n  },\n)\n", "import {\n  Bytes,\n  compact,\n  Option,\n  Struct,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const [ChargeAssetTxPaymentEnc] = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n})\n", "import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport { Encoder } from \"@polkadot-api/substrate-bindings\"\nimport { OfflineTxExtensions } from \"../types\"\nimport { fromHex, mapObject } from \"@polkadot-api/utils\"\nimport { getSystemVersionStruct } from \"./system-version\"\nimport { mortal } from \"./mortal-enc\"\nimport { ChargeAssetTxPaymentEnc } from \"./charge-asset-tx-enc\"\n\nconst empty = new Uint8Array()\nconst zero = Uint8Array.from([0])\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\n\nconst value = (value: Uint8Array) => ({\n  value,\n  additionalSigned: empty,\n})\nconst additionalSigned = (additionalSigned: Uint8Array) => ({\n  value: empty,\n  additionalSigned,\n})\nconst both = (value: Uint8Array, additionalSigned: Uint8Array) => ({\n  value,\n  additionalSigned,\n})\n\nexport const getSignExtensionsCreator = (\n  genesis: Uint8Array,\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n) => {\n  const signedExtensionsEncoders: Record<string, [Encoder<any>, Encoder<any>]> =\n    {}\n  lookupFn.metadata.extrinsic.signedExtensions.forEach(\n    ({ identifier, type, additionalSigned }) => {\n      signedExtensionsEncoders[identifier] = [type, additionalSigned].map(\n        (x) => dynamicBuilder.buildDefinition(x)[0],\n      ) as [Encoder<any>, Encoder<any>]\n    },\n  )\n\n  return <Asset>({\n    mortality,\n    tip = 0n,\n    nonce,\n    customSignedExtensions = {},\n    ...rest\n  }: OfflineTxExtensions<Asset>): Record<\n    string,\n    { identifier: string; value: Uint8Array; additionalSigned: Uint8Array }\n  > => {\n    const invalidKeys: string[] = []\n    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder)\n    const getFromCustomEntry = (key: string) => {\n      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key]\n      const customEntry = customSignedExtensions[key] as any\n      try {\n        return mapObject(\n          {\n            value: valueEnc,\n            additionalSigned: additionalEnc,\n          },\n          (encoder, key) => {\n            const input = customEntry?.[key]\n            // if the encoder is _void, then the input value is ignored, so no harm in passing `undefined`\n            // only an `Option` encoder will accept `undefined` as an input without crashing\n            return input instanceof Uint8Array ? input : encoder(input)\n          },\n        )\n      } catch {\n        // this means that a non optional custom signed-extension has not received its value\n        invalidKeys.push(key)\n        return null\n      }\n    }\n\n    const result = mapObject(\n      signedExtensionsEncoders,\n      ([valueEnc, additionalEnc], key) => {\n        if (customSignedExtensions[key]) return getFromCustomEntry(key)\n\n        switch (key) {\n          case \"CheckNonce\":\n            return value(valueEnc(nonce))\n\n          case \"CheckMortality\":\n            return mortality.mortal\n              ? both(\n                  mortal({\n                    period: mortality.period,\n                    startAtBlock: mortality.startAtBlock.height,\n                  }),\n                  fromHex(mortality.startAtBlock.hash),\n                )\n              : both(zero, genesis)\n\n          case \"ChargeTransactionPayment\":\n            return value(valueEnc(tip))\n\n          case \"ChargeAssetTxPayment\":\n            return value(\n              ChargeAssetTxPaymentEnc({\n                tip,\n                asset: (rest as any).asset,\n              }),\n            )\n\n          case \"CheckGenesis\":\n            return additionalSigned(genesis)\n\n          case \"CheckMetadataHash\":\n            return both(zero, zero)\n\n          case \"CheckSpecVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"spec_version\"]),\n            )\n\n          case \"CheckTxVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"transaction_version\"]),\n            )\n\n          default:\n            return getFromCustomEntry(key)\n        }\n      },\n    )\n\n    invalidKeys.forEach((key) => {\n      delete result[key]\n    })\n    return mapObject(result, (x, identifier) => ({ ...x, identifier })) as any\n  }\n}\n", "import { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { HexString, u16, u32, u64, u8 } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  filter,\n  map,\n  mergeMap,\n  of,\n  scan,\n  startWith,\n  switchMap,\n  take,\n} from \"rxjs\"\nimport { getSignExtensionsCreator } from \"./signed-extensions\"\nimport { CustomSignedExtensionValues } from \"./types\"\n\ntype HintedSignedExtensions = Partial<{\n  tip: bigint\n  mortality: { mortal: false } | { mortal: true; period: number }\n  asset: Uint8Array\n  nonce: number\n}>\n\nconst NONCE_RUNTIME_CALL = \"AccountNonceApi_account_nonce\"\nconst lenToDecoder = {\n  1: u8.dec,\n  2: u16.dec,\n  4: u32.dec,\n  8: u64.dec,\n}\n\nconst getNonceAtBlock$ = (\n  call$: ChainHead$[\"call$\"],\n  from: HexString,\n  at: string,\n) =>\n  call$(at, NONCE_RUNTIME_CALL, from).pipe(\n    map((result) => {\n      const bytes = fromHex(result)\n      const decoder = lenToDecoder[bytes.length as 2 | 4 | 8]\n      if (!decoder)\n        throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`)\n      return decoder(bytes)\n    }),\n  )\n\nexport const createTx: (\n  chainHead: ChainHead$,\n  signer: PolkadotSigner,\n  callData: Uint8Array,\n  atBlock: BlockInfo,\n  customSignExt: Record<string, CustomSignedExtensionValues>,\n  hinted?: HintedSignedExtensions,\n) => Observable<Uint8Array> = (\n  chainHead,\n  signer,\n  callData,\n  atBlock,\n  customSignedExtensions,\n  hinted = {},\n) =>\n  combineLatest([\n    hinted.nonce\n      ? of(hinted.nonce)\n      : getNonce$(chainHead, toHex(signer.publicKey)),\n    chainHead.getRuntimeContext$(atBlock.hash),\n    chainHead.genesis$,\n  ]).pipe(\n    take(1),\n    mergeMap(([nonce, ctx, genesis]) => {\n      const signExtCreator = getSignExtensionsCreator(\n        fromHex(genesis),\n        ctx.lookup,\n        ctx.dynamicBuilder,\n      )\n\n      const mortality: HintedSignedExtensions[\"mortality\"] =\n        hinted.mortality ?? { period: 64, mortal: true }\n\n      const signExtensions = signExtCreator({\n        nonce: nonce as number,\n        tip: hinted.tip ?? 0n,\n        mortality: mortality.mortal\n          ? {\n              mortal: true,\n              period: mortality.period,\n              startAtBlock: {\n                height: atBlock.number,\n                hash: atBlock.hash,\n              },\n            }\n          : { mortal: false },\n        customSignedExtensions,\n        asset: hinted.asset,\n      })\n\n      return signer.signTx(\n        callData,\n        signExtensions,\n        ctx.metadataRaw,\n        atBlock.number,\n      )\n    }),\n  )\n\nconst getNonce$ = (chainHead: ChainHead$, from: HexString) => {\n  const followHead$ = (head: string) =>\n    chainHead.newBlocks$.pipe(\n      scan((acc, block) => (block.parent === acc ? block.hash : acc), head),\n      startWith(head),\n      distinctUntilChanged(),\n    )\n  const followNonce$ = (head: string) =>\n    followHead$(head).pipe(\n      take(2),\n      switchMap((hash) => getNonceAtBlock$(chainHead.call$, from, hash)),\n    )\n  const getHeadsNonce$ = (heads: string[]) =>\n    combineLatest(\n      heads.map((head) =>\n        followNonce$(head).pipe(\n          map((value) => ({\n            success: true as const,\n            value,\n          })),\n          catchError((err) =>\n            of({\n              success: false as const,\n              value: err,\n            }),\n          ),\n        ),\n      ),\n    ).pipe(take(1))\n\n  return chainHead.pinnedBlocks$.pipe(\n    filter((v) => !v.recovering && v.blocks.size > 0),\n    take(1),\n    map(({ blocks, best }) => {\n      // Grab only the heads: those blocks above the best that don't have children and are not getting pruned\n      const bestBlock = blocks.get(best)!\n      return [...blocks.values()]\n        .filter(\n          (v) =>\n            !v.unpinnable &&\n            v.children.size === 0 &&\n            v.number >= bestBlock.number,\n        )\n        .map((v) => v.hash)\n    }),\n    switchMap(getHeadsNonce$),\n    map((result) => {\n      const winner = result.reduce(\n        (acc: bigint | number | null, v) =>\n          v.success ? (v.value >= (acc ?? 0) ? v.value : acc) : acc,\n        null,\n      )\n\n      if (winner == null) {\n        // We must have at least one error\n        throw result[0].value\n      }\n      return winner\n    }),\n  )\n}\n", "import { Observable } from \"rxjs\"\n\nlet NOTIN = {}\nexport const continueWith =\n  <I, O>(\n    mapper: (input: I) => Observable<O>,\n  ): ((source: Observable<I>) => Observable<I | O>) =>\n  (source) =>\n    new Observable((observer) => {\n      let latestValue: I = NOTIN as I\n      let subscription = source.subscribe({\n        next(v) {\n          observer.next((latestValue = v))\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (latestValue === NOTIN) observer.complete()\n          else subscription = mapper(latestValue).subscribe(observer)\n        },\n      })\n\n      return () => {\n        subscription.unsubscribe()\n      }\n    })\n", "import {\n  Binary,\n  Blake2256,\n  HexString,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  concat,\n  distinctUntilChanged,\n  filter,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n} from \"rxjs\"\nimport {\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\n// TODO: make it dynamic based on the tx-function of the client\nconst hashFromTx = (tx: HexString) => toHex(Blake2256(fromHex(tx)))\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        found: true\n        hash: string\n        number: number\n        index: number\n        events: any\n      }\n    | { found: false; validity: ResultPayload<any, any> | null }\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          found: true\n          hash: string\n          number: number\n          index: number\n          events: any\n        }\n      | { found: false; validity: ResultPayload<any, any> | null }\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n      let analyzedNumber = pinnedBlocks.blocks.get(current)!.number\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n        analyzedNumber--\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        analyzedNumber <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (found && latestState?.found && latestState.hash === analyzed.hash) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = analyzed.found.type\n          ? {\n              found: found as true,\n              hash: analyzed.hash,\n              number: analyzedNumber,\n              index: analyzed.found.index,\n              events: analyzed.found.events,\n            }\n          : {\n              found: found as false,\n              validity: analyzed.found.validity,\n            }),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (analyzed.found.validity?.success === false)\n          observer.error(new InvalidTxError(analyzed.found.validity.value))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => ({ ...x.event, topics: x.topics }))\n\n  const lastEvent = events[events.length - 1]\n  if (\n    lastEvent.type === \"System\" &&\n    lastEvent.value.type === \"ExtrinsicFailed\"\n  ) {\n    return {\n      ok: false,\n      events,\n      dispatchError: lastEvent.value.value.dispatch_error,\n    }\n  }\n\n  return { ok: true, events }\n}\n\n/*\ntype TransactionValidityError = Enum<{\n  Invalid: Enum<{\n    Call: undefined\n    Payment: undefined\n    Future: undefined\n    Stale: undefined\n    BadProof: undefined\n    AncientBirthBlock: undefined\n    ExhaustsResources: undefined\n    Custom: number\n    BadMandatory: undefined\n    MandatoryValidation: undefined\n    BadSigner: undefined\n  }>\n  Unknown: Enum<{\n    CannotLookup: undefined\n    NoUnsignedValidator: undefined\n    Custom: number\n  }>\n}>\n*/\n\nexport class InvalidTxError extends Error {\n  error: any // likely to be a `TransactionValidityError`\n  constructor(e: any) {\n    super(\n      JSON.stringify(\n        e,\n        (_, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value instanceof Binary ? value.asHex() : value\n        },\n        2,\n      ),\n    )\n    this.name = \"InvalidTxError\"\n    this.error = e\n  }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  at?: HexString,\n  emitSign = false,\n): Observable<TxEvent> => {\n  const txHash = hashFromTx(tx)\n  const getTxEvent = <\n    Type extends TxEvent[\"type\"],\n    Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n  >(\n    type: Type,\n    rest: Rest,\n  ): TxEvent & { type: Type } =>\n    ({\n      type,\n      txHash,\n      ...rest,\n    }) as any\n\n  const at$ = chainHead.pinnedBlocks$.pipe(\n    take(1),\n    map((blocks) => {\n      const block = blocks.blocks.get(at!)\n      return block ? block.hash : blocks.finalized\n    }),\n  )\n\n  const validate$: Observable<never> = at$.pipe(\n    mergeMap((at) =>\n      chainHead.validateTx$(at, tx).pipe(\n        filter((x) => !x.success),\n        map((x) => {\n          throw new InvalidTxError(x.value)\n        }),\n      ),\n    ),\n  )\n\n  const track$ = new Observable<AnalyzedBlock>((observer) => {\n    const subscription = chainHead.trackTx$(tx).subscribe(observer)\n    subscription.add(\n      broadcastTx$(tx).subscribe({\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n    return subscription\n  })\n\n  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(\n    map((x) => {\n      if (!x.found)\n        return getTxEvent(\"txBestBlocksState\", {\n          found: false,\n          isValid: x.validity?.success !== false,\n        })\n\n      return getTxEvent(\"txBestBlocksState\", {\n        found: true,\n        block: {\n          index: x.index,\n          number: x.number,\n          hash: x.hash,\n        },\n        ...getTxSuccessFromSystemEvents(x.events, x.index),\n      })\n    }),\n  )\n\n  return concat(\n    emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n    validate$,\n    of(getTxEvent(\"broadcasted\", {})),\n    bestBlockState$.pipe(\n      continueWith(({ found, type, ...rest }) =>\n        found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n      ),\n    ),\n  )\n}\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n", "import type { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getPolkadotSigner } from \"@polkadot-api/signer\"\nimport {\n  _void,\n  AccountId,\n  Binary,\n  compactBn,\n  Decoder,\n  Enum,\n  Struct,\n  u128,\n  u32,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  combineLatest,\n  firstValueFrom,\n  map,\n  mergeMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport { PlainDescriptor } from \"@/descriptors\"\nimport {\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"../compatibility\"\nimport { createTx } from \"./create-tx\"\nimport { InvalidTxError, submit, submit$ } from \"./submit-fns\"\nimport {\n  PaymentInfo,\n  TxCall,\n  TxEntry,\n  TxObservable,\n  TxOptions,\n  TxPromise,\n  TxSignFn,\n} from \"./types\"\nimport {\n  isCompatible,\n  mapLookupToTypedef,\n} from \"@polkadot-api/metadata-compatibility\"\n\nexport { submit, submit$, InvalidTxError }\n\nconst accountIdEnc = AccountId().enc\nconst fakeSignature = new Uint8Array(64)\nconst fakeSignatureEth = new Uint8Array(65)\nconst getFakeSignature = (isEth: boolean) => () =>\n  isEth ? fakeSignatureEth : fakeSignature\n\nconst [, queryInfoDecFallback] = Struct({\n  weight: Struct({\n    ref_time: compactBn,\n    proof_size: compactBn,\n  }),\n  class: Variant({\n    Normal: _void,\n    Operational: _void,\n    Mandatory: _void,\n  }),\n  partial_fee: u128,\n})\n\nexport const createTxEntry = <\n  D,\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends PlainDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  chainHead: ChainHead$,\n  broadcast: (tx: string) => Observable<never>,\n  {\n    isCompatible: isCompatibleHelper,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    getRuntimeTypedef,\n  }: CompatibilityHelper,\n  checkCompatibility: boolean,\n): TxEntry<D, Arg, Pallet, Name, Asset> => {\n  const fn = (arg?: Arg): any => {\n    const getCallDataWithContext = (\n      runtime: CompatibilityToken | RuntimeToken,\n      arg: any,\n      txOptions: Partial<{ asset: any }> = {},\n    ) => {\n      const ctx = getCompatibilityApi(runtime).runtime()\n      const { dynamicBuilder, assetId, lookup } = ctx\n      let codecs\n      try {\n        codecs = dynamicBuilder.buildCall(pallet, name)\n      } catch {\n        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`)\n      }\n      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg))\n        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n      let returnOptions = txOptions\n      if (txOptions.asset) {\n        if (\n          assetId == null ||\n          !isCompatible(\n            txOptions.asset,\n            mapLookupToTypedef(lookup(assetId)),\n            (id) => getRuntimeTypedef(ctx, id),\n          )\n        )\n          throw new Error(`Incompatible runtime asset`)\n        returnOptions = {\n          ...txOptions,\n          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset),\n        }\n      }\n\n      const { location, codec } = codecs\n      return {\n        callData: Binary.fromBytes(\n          mergeUint8(new Uint8Array(location), codec.enc(arg)),\n        ),\n        options: returnOptions,\n      }\n    }\n\n    const getCallData$ = (arg: any, options: Partial<{ asset: any }> = {}) =>\n      compatibleRuntime$(chainHead, null).pipe(\n        map(([runtime]) => getCallDataWithContext(runtime, arg, options)),\n      )\n\n    const getEncodedData: TxCall = (\n      token?: CompatibilityToken | RuntimeToken,\n    ): any => {\n      if (!token)\n        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n      return getCallDataWithContext(token, arg).callData\n    }\n\n    const sign$ = (\n      from: PolkadotSigner,\n      { ..._options }: Omit<TxOptions<{}>, \"at\">,\n      atBlock: BlockInfo,\n    ) =>\n      getCallData$(arg, _options).pipe(\n        mergeMap(({ callData, options }) =>\n          createTx(\n            chainHead,\n            from,\n            callData.asBytes(),\n            atBlock,\n            _options.customSignedExtensions || {},\n            options,\n          ),\n        ),\n      )\n\n    const _sign = (\n      from: PolkadotSigner,\n      { at, ..._options }: TxOptions<{}> = {},\n    ) => {\n      return (\n        !at || at === \"finalized\"\n          ? chainHead.finalized$\n          : at === \"best\"\n            ? chainHead.best$\n            : chainHead.bestBlocks$.pipe(\n                map((x) => x.find((b) => b.hash === at)),\n              )\n      ).pipe(\n        take(1),\n        mergeMap((atBlock) =>\n          atBlock\n            ? sign$(from, _options, atBlock).pipe(\n                map((signed) => ({\n                  tx: toHex(signed),\n                  block: atBlock,\n                })),\n              )\n            : throwError(() => new Error(`Uknown block ${at}`)),\n        ),\n      )\n    }\n\n    const sign: TxSignFn<Asset> = (from, options) =>\n      firstValueFrom(_sign(from, options)).then((x) => x.tx)\n\n    const signAndSubmit: TxPromise<Asset> = (from, _options) =>\n      firstValueFrom(_sign(from, _options)).then(({ tx, block }) =>\n        submit(chainHead, broadcast, tx, block.hash),\n      )\n\n    const signSubmitAndWatch: TxObservable<Asset> = (from, _options) =>\n      _sign(from, _options).pipe(\n        mergeMap(({ tx, block }) =>\n          submit$(chainHead, broadcast, tx, block.hash, true),\n        ),\n      )\n\n    const getPaymentInfo = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => {\n      if (typeof from === \"string\")\n        from = from.startsWith(\"0x\") ? fromHex(from) : accountIdEnc(from)\n      const isEth = from.length === 20\n      const fakeSigner = getPolkadotSigner(\n        from,\n        isEth ? \"Ecdsa\" : \"Sr25519\",\n        getFakeSignature(isEth),\n      )\n      const encoded = fromHex(await sign(fakeSigner, _options))\n      const args = toHex(mergeUint8(encoded, u32.enc(encoded.length)))\n\n      const decoder$: Observable<Decoder<PaymentInfo>> = chainHead\n        .getRuntimeContext$(null)\n        .pipe(\n          map((ctx) => {\n            try {\n              return ctx.dynamicBuilder.buildRuntimeCall(\n                \"TransactionPaymentApi\",\n                \"query_info\",\n              ).value[1]\n            } catch {\n              return queryInfoDecFallback\n            }\n          }),\n        )\n\n      const call$ = chainHead.call$(\n        null,\n        \"TransactionPaymentApi_query_info\",\n        args,\n      )\n\n      return firstValueFrom(\n        combineLatest([call$, decoder$]).pipe(\n          map(([result, decoder]) => decoder(result)),\n        ),\n      )\n    }\n\n    const getEstimatedFees = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => (await getPaymentInfo(from, _options)).partial_fee\n\n    return {\n      getPaymentInfo,\n      getEstimatedFees,\n      decodedCall: {\n        type: pallet,\n        value: Enum(name, arg as any),\n      },\n      getEncodedData,\n      sign,\n      signSubmitAndWatch,\n      signAndSubmit,\n    }\n  }\n\n  return Object.assign(fn, {\n    getCompatibilityLevel,\n    isCompatible: isCompatibleHelper,\n  })\n}\n", "import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies.\n *\n * @returns\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n", "import type { SUSPENSE as iSUSPENSE } from \"./index.d\"\nexport const SUSPENSE: iSUSPENSE = Symbol(\"SUSPENSE\") as any\nexport type SUSPENSE = iSUSPENSE\n", "import type { StatePromise as IStatePromise } from \"./index.d\"\n\nexport class StatePromise<T> extends Promise<T> implements IStatePromise<T> {\n  constructor(cb: (res: (value: T) => void, rej: any) => void) {\n    super(cb)\n  }\n}\n", "import type {\n  NoSubscribersError as INoSubscribersError,\n  EmptyObservableError as IEmptyObservableError,\n} from \"./index.d\"\n\nexport class NoSubscribersError extends Error implements INoSubscribersError {\n  constructor() {\n    super()\n    this.name = \"NoSubscribersError\"\n  }\n}\n\nexport class EmptyObservableError\n  extends Error\n  implements IEmptyObservableError\n{\n  constructor() {\n    super()\n    this.name = \"EmptyObservableError\"\n  }\n}\n", "export const EMPTY_VALUE: any = {}\n", "import { Observable } from \"rxjs\"\nimport StateObservable from \"../internal/state-observable\"\n\nfunction cloneProps<T>(\n  internal: StateObservable<T>,\n  external: StateObservable<T>,\n) {\n  external.getValue = internal.getValue\n  external.getRefCount = internal.getRefCount\n  external.pipeState = internal.pipeState\n  if ((internal as any).getDefaultValue) {\n    ;(external as any).getDefaultValue = (internal as any).getDefaultValue\n  }\n}\n\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n) {\n  const cache = new NestedMap<A, StateObservable<O>>()\n  const getDefaultValue = (\n    typeof defaultValue === \"function\" ? defaultValue : () => defaultValue\n  ) as (...args: A) => O\n\n  const getSharedObservables$ = (input: A): StateObservable<O> => {\n    for (let i = input.length - 1; input[i] === undefined && i > -1; i--) {\n      input.splice(-1)\n    }\n    const keys = [input.length, ...input] as any as A\n    const cachedVal = cache.get(keys)\n\n    if (cachedVal !== undefined) {\n      return cachedVal\n    }\n\n    const sharedObservable$ = new StateObservable(\n      getObservable(...input),\n      getDefaultValue(...input),\n      () => {\n        cache.delete(keys)\n      },\n    )\n\n    const publicShared$ = new Observable<O>((subscriber) => {\n      const inCache = cache.get(keys)\n      let source$: StateObservable<O> = sharedObservable$\n\n      if (!inCache) {\n        cache.set(keys, result)\n      } else if (inCache !== publicShared$) {\n        source$ = inCache\n        cloneProps(source$, publicShared$)\n      }\n\n      return source$.subscribe(subscriber)\n    }) as StateObservable<O>\n    cloneProps(sharedObservable$, publicShared$)\n\n    const result: StateObservable<O> = publicShared$\n\n    cache.set(keys, result)\n    return result\n  }\n\n  return (...input: A) => getSharedObservables$(input)\n}\n\nclass NestedMap<K extends [], V extends Object> {\n  private root: Map<K, any>\n  constructor() {\n    this.root = new Map()\n  }\n\n  get(keys: K[]): V | undefined {\n    let current: any = this.root\n    for (let i = 0; i < keys.length; i++) {\n      current = current.get(keys[i])\n      if (!current) return undefined\n    }\n    return current\n  }\n\n  set(keys: K[], value: V): void {\n    let current: Map<K, any> = this.root\n    let i\n    for (i = 0; i < keys.length - 1; i++) {\n      let nextCurrent = current.get(keys[i])\n      if (!nextCurrent) {\n        nextCurrent = new Map<K, any>()\n        current.set(keys[i], nextCurrent)\n      }\n      current = nextCurrent\n    }\n    current.set(keys[i], value)\n  }\n\n  delete(keys: K[]): void {\n    const maps: Map<K, any>[] = [this.root]\n    let current: Map<K, any> = this.root\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      maps.push((current = current.get(keys[i])))\n    }\n\n    let mapIdx = maps.length - 1\n    maps[mapIdx].delete(keys[mapIdx])\n\n    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {\n      maps[mapIdx].delete(keys[mapIdx])\n    }\n  }\n}\n", "import {\n  noop,\n  Observable,\n  OperatorFunction,\n  Subject,\n  Subscriber,\n  Subscription,\n} from \"rxjs\"\nimport { EmptyObservableError, NoSubscribersError } from \"../errors\"\nimport { StatePromise } from \"../StatePromise\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport { EMPTY_VALUE } from \"./empty-value\"\n\nexport default class StateObservable<T> extends Observable<T> {\n  private subject: Subject<T> | null = null\n  private subscription: Subscriber<T> | null = null\n  private refCount = 0\n  private currentValue: T = EMPTY_VALUE\n  private promise: {\n    res: (value: Exclude<T, SUSPENSE>) => void\n    rej: (v: any) => void\n    p: StatePromise<Exclude<T, SUSPENSE>>\n  } | null = null\n\n  constructor(\n    source$: Observable<T>,\n    private defaultValue: T,\n    teardown = noop,\n  ) {\n    super((subscriber) => {\n      const subscriberWithoutComplete = new Subscriber({\n        next: subscriber.next.bind(subscriber),\n        error: subscriber.error.bind(subscriber),\n        complete: noop,\n      })\n\n      this.refCount++\n      let innerSub: Subscription\n\n      subscriber.add(() => {\n        this.refCount--\n        innerSub.unsubscribe()\n        if (this.refCount === 0) {\n          this.currentValue = EMPTY_VALUE\n          if (this.subscription) {\n            this.subscription.unsubscribe()\n          }\n          teardown()\n          this.subject?.complete()\n          this.subject = null\n          this.subscription = null\n          if (this.promise) {\n            this.promise.rej(new NoSubscribersError())\n            this.promise = null\n          }\n        }\n      })\n\n      if (!this.subject) {\n        this.subject = new Subject<T>()\n        innerSub = this.subject.subscribe(subscriberWithoutComplete)\n        this.subscription = null\n        this.subscription = new Subscriber<T>({\n          next: (value: T) => {\n            if (this.promise && (value as any) !== SUSPENSE) {\n              this.promise.res(value as any)\n              this.promise = null\n            }\n            this.subject!.next((this.currentValue = value))\n          },\n          error: (err: any) => {\n            this.subscription = null\n            const subject = this.subject\n            this.subject = null\n            this.currentValue = EMPTY_VALUE\n\n            const rej = this.promise?.rej\n            if (rej && err === SUSPENSE) {\n              this.promise!.rej = () => {\n                rej!(err)\n              }\n            }\n            subject!.error(err)\n            if (rej && this.promise) {\n              this.promise.rej = rej\n            }\n          },\n          complete: () => {\n            this.subscription = null\n            if (this.promise) {\n              this.promise.rej(new EmptyObservableError())\n              this.promise = null\n            }\n\n            if (this.currentValue !== EMPTY_VALUE)\n              return this.subject!.complete()\n\n            if (defaultValue === EMPTY_VALUE) {\n              const subject = this.subject\n              this.subject = null\n              return subject!.error(new EmptyObservableError())\n            }\n\n            this.subject!.next((this.currentValue = defaultValue))\n            this.subject!.complete()\n          },\n        })\n        source$.subscribe(this.subscription)\n        if (defaultValue !== EMPTY_VALUE && this.currentValue === EMPTY_VALUE) {\n          this.subject!.next((this.currentValue = defaultValue))\n        }\n      } else {\n        innerSub = this.subject.subscribe(subscriberWithoutComplete)\n        if (this.currentValue !== EMPTY_VALUE) {\n          subscriber.next(this.currentValue)\n        }\n      }\n    })\n\n    if (defaultValue === EMPTY_VALUE) {\n      // Remove the getDefaultValue property from this object, as it's not part of the interface\n      delete this.getDefaultValue\n    }\n  }\n\n  pipeState = (...ops: OperatorFunction<any, any>[]) => {\n    const result = (super.pipe as any)(...ops)\n    return result instanceof StateObservable\n      ? result\n      : new StateObservable(result, EMPTY_VALUE)\n  }\n\n  getRefCount = () => {\n    return this.refCount\n  }\n  getValue = (): Exclude<T, SUSPENSE> | StatePromise<Exclude<T, SUSPENSE>> => {\n    if (this.promise) return this.promise.p\n    if (\n      this.currentValue !== EMPTY_VALUE &&\n      (this.currentValue as any) !== SUSPENSE\n    )\n      return this.currentValue as any\n    if (this.defaultValue !== EMPTY_VALUE) return this.defaultValue as any\n    if (this.refCount === 0) throw new NoSubscribersError()\n\n    const promise = new StatePromise<Exclude<T, SUSPENSE>>((res, rej) => {\n      this.promise = { res, rej, p: null as any }\n    })\n    this.promise!.p = promise\n    return promise\n  }\n  getDefaultValue? = () => {\n    return this.defaultValue\n  }\n}\n", "import { Observable } from \"rxjs\"\nimport StateObservable from \"../internal/state-observable\"\n\nexport default function state<T>(observable: Observable<T>, defaultValue: T) {\n  return new StateObservable<T>(observable, defaultValue)\n}\n", "import type { state as IState } from \"../index.d\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport stateFactory from \"./stateFactory\"\nimport stateSingle from \"./stateSingle\"\n\nexport const state: typeof IState = (...args: any[]) =>\n  (typeof args[0] === \"function\" ? (stateFactory as any) : stateSingle)(\n    args[0],\n    args.length > 1 ? args[1] : EMPTY_VALUE,\n  )\n", "import { Observable } from \"rxjs\"\nimport type { withDefault as IWithDefault } from \"./index.d\"\nimport { state } from \"./state\"\n\nexport const withDefault: typeof IWithDefault =\n  <D>(defaultValue: D) =>\n  <T>(source$: Observable<T>) =>\n    state<D | T>(source$, defaultValue)\n", "import { Observable, Subscriber } from \"rxjs\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport { sinkSuspense as ISinkSuspense } from \"../index.d\"\n\ntype SubscriberWithInner<T> = Subscriber<T> & { inner: Subscriber<any> }\nexport const sinkSuspense: typeof ISinkSuspense = () => {\n  return <T>(source$: Observable<T>) => {\n    let waiting: SubscriberWithInner<any> | null = null\n\n    return new Observable((observer) => {\n      if (waiting) {\n        waiting.inner = observer\n        const outter = waiting!\n        return () => {\n          if (outter.inner === observer) outter.unsubscribe()\n        }\n      }\n\n      let outter = new Subscriber<T | SUSPENSE>({\n        next(value: T | SUSPENSE) {\n          if (value === SUSPENSE) {\n            waiting = outter\n            outter.inner.error(value)\n            waiting = null\n            if (outter.inner === observer) {\n              outter.unsubscribe()\n            }\n          } else {\n            outter.inner.next(value)\n          }\n        },\n        error(e: unknown) {\n          outter.inner.error(e)\n        },\n        complete() {\n          outter.inner.complete()\n        },\n      }) as SubscriberWithInner<T>\n\n      outter.inner = observer\n      source$.subscribe(outter)\n\n      return () => {\n        if (outter.inner === observer) outter.unsubscribe()\n      }\n    })\n  }\n}\n", "import { Observable, Subscriber } from \"rxjs\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport type { liftSuspense as ILiftSuspense } from \"../index.d\"\n\nexport const liftSuspense: typeof ILiftSuspense = () => {\n  return <T>(source$: Observable<T>): Observable<T | SUSPENSE> => {\n    return new Observable((observer) => {\n      let subscriber: Subscriber<any>\n\n      const setSubscriber = () => {\n        subscriber = new Subscriber<T>({\n          next(v: T) {\n            observer.next(v as any)\n          },\n          error(e: unknown) {\n            if (e === SUSPENSE) {\n              observer.next(e)\n              setSubscriber()\n            } else observer.error(e)\n          },\n          complete() {\n            observer.complete()\n          },\n        })\n        source$.subscribe(subscriber)\n      }\n\n      setSubscriber()\n\n      return () => {\n        subscriber.unsubscribe()\n      }\n    })\n  }\n}\n", "import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  PinnedBlocks,\n  BlockInfo,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport {\n  BlockNotPinnedError,\n  isBestOrFinalizedBlock,\n} from \"@polkadot-api/observable-client\"\nimport {\n  catchError,\n  combineLatest,\n  delay,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  take,\n  takeUntil,\n  throwError,\n  withLatestFrom,\n} from \"rxjs\"\nimport { selfDependent, lossLessExhaustMap } from \"@/utils\"\nimport { state } from \"@rx-state/core\"\n\ninterface StorageEntry {\n  key: HexString\n  value: HexString\n  dec: {\n    args: Array<any>\n    value: any\n  }\n}\n\ntype Deltas = {\n  upserted: Array<StorageEntry>\n  deleted: Array<StorageEntry>\n}\n\ninterface MemoryBlock {\n  prev: HexString | null\n  block: BlockInfo\n  rootHash: string\n  entries: Array<StorageEntry>\n  deltas: Deltas | null\n}\n\ntype MemoryBlocks = {\n  blocks: Record<HexString, MemoryBlock>\n  finalized: HexString\n}\n\nconst getDiff = (\n  _prev: Array<StorageEntry>,\n  _current: Array<StorageEntry>,\n  patch: (input: StorageEntry) => StorageEntry,\n): Pick<MemoryBlock, \"entries\" | \"deltas\"> => {\n  const current = new Map(_current.map((x) => [x.key, x]))\n  const prev = new Map(_prev.map((x) => [x.key, x]))\n\n  const upserted: Map<string, StorageEntry> = new Map()\n  const deleted: Array<StorageEntry> = []\n\n  _current.forEach((value) => {\n    const { key } = value\n    const prevVal = prev.get(key)\n    if (!prevVal || prevVal.value !== value.value)\n      upserted.set(key, patch(value))\n  })\n\n  _prev.forEach((x) => {\n    if (!current.has(x.key)) deleted.push(x)\n  })\n\n  return {\n    deltas: {\n      deleted,\n      upserted: [...upserted.values()],\n    },\n    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key)!),\n  }\n}\n\nconst findPrevious = (\n  start: HexString,\n  state: MemoryBlocks[\"blocks\"],\n  pinned: PinnedBlocks,\n  includeStart = false,\n) => {\n  try {\n    let target = includeStart ? start : pinned.blocks.get(start)!.parent\n    while (target && !state[target]) target = pinned.blocks.get(target)!.parent!\n\n    if (!target) return null\n    return state[target]\n  } catch {\n    return null\n  }\n}\n\nconst getPatcherFromRuntime =\n  (pallet: string, entry: string) => (runtime: RuntimeContext) => {\n    const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry)\n    return (x: StorageEntry) => {\n      x.dec = {\n        value: value.dec(x.value),\n        args: keys.dec(x.key),\n      }\n      return x\n    }\n  }\n\nexport const createWatchEntries = (\n  blocks$: Observable<PinnedBlocks>,\n  storage: ChainHead$[\"storage$\"],\n  withRuntime: ChainHead$[\"withRuntime\"],\n) => {\n  const getMemoryBlocks$ = state(\n    (pallet: string, entry: string, storageKey: string) => {\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n      const getNextMemoryBlock$ = (\n        prev: MemoryBlock | null,\n        block: BlockInfo,\n      ): Observable<MemoryBlock> => {\n        const isNotCanonical$ = isBestOrFinalizedBlock(\n          blocks$,\n          block.hash,\n        ).pipe(\n          filter((x) => !x),\n          take(1),\n        )\n\n        return storage(\n          block.hash,\n          \"closestDescendantMerkleValue\",\n          () => storageKey,\n        ).pipe(\n          mergeMap((rootHash) => {\n            if (rootHash === prev?.rootHash)\n              return of({\n                ...prev,\n                block,\n                deltas: null,\n                prev: prev.block.hash,\n              })\n\n            return storage(\n              block.hash,\n              \"descendantsValues\",\n              () => storageKey,\n            ).pipe(\n              withRuntime(() => block.hash),\n              map(\n                ([entries, runtimeCtx]) =>\n                  [entries, getPatcher(runtimeCtx)] as const,\n              ),\n              map(\n                ([entries, patcher]): MemoryBlock => ({\n                  prev: prev && prev.block.hash,\n                  rootHash: rootHash!,\n                  block,\n                  ...getDiff(\n                    prev?.entries ?? [],\n                    entries as StorageEntry[],\n                    patcher,\n                  ),\n                }),\n              ),\n            )\n          }),\n          takeUntil(isNotCanonical$),\n          catchError((e) =>\n            e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e),\n          ),\n        )\n      }\n\n      const initial$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.finalized === b.finalized),\n        lossLessExhaustMap(({ blocks, finalized }) =>\n          getNextMemoryBlock$(null, blocks.get(finalized)!),\n        ),\n        take(1),\n        map(\n          (x): MemoryBlocks => ({\n            blocks: { [x.block.hash]: x },\n            finalized: x.block.hash,\n          }),\n        ),\n      )\n\n      const [_memoryBlocks$, connectMemoryBlocks] =\n        selfDependent<MemoryBlocks>()\n      const updates$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.best === b.best),\n        withLatestFrom(_memoryBlocks$),\n        lossLessExhaustMap(([pinned, memoryBlocks]) => {\n          const { best } = pinned\n          const { blocks } = memoryBlocks\n          let target = !blocks[best] ? best : null\n          if (!target) return EMPTY\n\n          const previous = findPrevious(target, blocks, pinned)\n          if (previous)\n            return getNextMemoryBlock$(\n              previous,\n              pinned.blocks.get(target)!,\n            ).pipe(\n              map((x) => {\n                blocks[target!] = x\n                return memoryBlocks\n              }),\n            )\n\n          // This means that there has been a stop event that the pinned-blocks\n          // couldn't recover from. Therefore, we must \"start over\"\n          target = pinned.finalized\n          return getNextMemoryBlock$(\n            blocks[memoryBlocks.finalized],\n            pinned.blocks.get(target)!,\n          ).pipe(\n            map((x) => {\n              x.prev = null\n              return {\n                blocks: { [target]: x },\n                finalized: target,\n              }\n            }),\n          )\n        }),\n      )\n\n      return merge(initial$, updates$).pipe(connectMemoryBlocks())\n    },\n  )\n\n  const getBestOrFinalized =\n    (isFinalized: boolean) =>\n    (pallet: string, entry: string, storageKey: string) => {\n      const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey)\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n\n      const prop = isFinalized ? \"finalized\" : \"best\"\n\n      return combineLatest([\n        memoryBlocks$.pipe(delay(0)),\n        blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop])),\n      ]).pipe(\n        map(([state, blocks]) =>\n          findPrevious(blocks[prop], state.blocks, blocks, true),\n        ),\n        filter(Boolean),\n        distinctUntilChanged(),\n        startWith(null),\n        pairwise(),\n        withLatestFrom(memoryBlocks$),\n        withRuntime(([[, _latest]]) => _latest!.block.hash),\n        map(\n          ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) =>\n            [\n              prevUpdate,\n              latest!,\n              memoryBlocks,\n              getPatcher(runtimeCtx),\n            ] as const,\n        ),\n        mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {\n          if (!prevUpdate) return [latest]\n\n          let ancestor: MemoryBlock | null = latest\n          const updates: Array<MemoryBlock> = []\n          while (ancestor && ancestor.block.number > prevUpdate.block.number) {\n            updates.unshift(ancestor)\n            ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null\n          }\n\n          if (isFinalized) {\n            memoryBlocks.finalized = latest.block.hash\n            if (updates.length) {\n              const { blocks } = memoryBlocks\n              Object.keys(blocks).forEach((key) => {\n                if (blocks[key].block.number < updates[0].block.number)\n                  delete blocks[key]\n              })\n            }\n          }\n\n          if (prevUpdate === ancestor) return updates\n\n          // It's a re-org\n          return [\n            {\n              ...latest,\n              ...(prevUpdate.rootHash === latest.rootHash\n                ? {\n                    entries: prevUpdate.entries,\n                    deltas: null,\n                  }\n                : getDiff(prevUpdate.entries, latest.entries, patcher)),\n            },\n          ]\n        }),\n      )\n    }\n\n  const getFinalized$ = state(getBestOrFinalized(true))\n  const getBest$ = state(getBestOrFinalized(false))\n\n  return (pallet: string, entry: string, args: Array<any>, atBest: boolean) => {\n    const fn = atBest ? getBest$ : getFinalized$\n    const storageKey$ = blocks$.pipe(\n      take(1),\n      mergeMap(\n        (b) =>\n          b.runtimes[b.blocks.get(b[atBest ? \"best\" : \"finalized\"])!.runtime]\n            .runtime,\n      ),\n      map((runtime) =>\n        runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args),\n      ),\n    )\n    return storageKey$.pipe(\n      take(1),\n      mergeMap((storageKey) => fn(pallet, entry, storageKey)),\n      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {\n        const actualDeltas =\n          idx > 0 ? deltas : { deleted: [], upserted: entries }\n\n        return {\n          block: { hash, number, parent },\n          entries: entries.map(toDec),\n          deltas: actualDeltas && {\n            deleted: actualDeltas.deleted.map(toDec),\n            upserted: actualDeltas.upserted.map(toDec),\n          },\n        }\n      }),\n    )\n  }\n}\n\nconst toDec = <T>(x: { dec: T }): T => x.dec\n", "import { firstValueFromWithSignal, isOptionalArg } from \"@/utils\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { compactNumber, _void } from \"@polkadot-api/substrate-bindings\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport type ViewFn<Unsafe, D, Args extends Array<any>, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the view function.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nconst RUNTIME_NAMESPACE = \"RuntimeViewFunction\"\nconst RUNTIME_METHOD = \"execute_view_function\"\nconst RUNTIME_CALL_NAME = RUNTIME_NAMESPACE + \"_\" + RUNTIME_METHOD\n\nexport const createViewFnEntry = (\n  pallet: string,\n  entry: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): ViewFn<any, any, any, any> => {\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry ViewFn(${pallet}.${entry})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at).pipe(\n      mergeMap(([runtime, ctx]) => {\n        let apiCodec\n        try {\n          apiCodec = ctx.dynamicBuilder.buildRuntimeCall(\n            RUNTIME_NAMESPACE,\n            RUNTIME_METHOD,\n          )\n        } catch {\n          throw new Error(\n            `Runtime entry RuntimeCall(${RUNTIME_CALL_NAME}) not found`,\n          )\n        }\n        let viewCodec\n        try {\n          viewCodec = ctx.dynamicBuilder.buildViewFn(pallet, entry)\n        } catch {\n          throw new Error(`Runtime entry ViewFn(${pallet}.${entry}) not found`)\n        }\n        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError()\n        const viewArgs = viewCodec.args.enc(args)\n        const arg = mergeUint8(\n          fromHex(\n            ctx.lookup.metadata.pallets\n              .find(({ name }) => name === pallet)!\n              .viewFns.find(({ name }) => name === entry)!.id,\n          ),\n          compactNumber.enc(viewArgs.length),\n          viewArgs,\n        )\n\n        return chainHead.call$(at, RUNTIME_CALL_NAME, toHex(arg)).pipe(\n          map((v) => {\n            try {\n              const decoded = apiCodec.value.dec(v)\n              if (\n                !(\"success\" in decoded && \"value\" in decoded) ||\n                (!(\"type\" in decoded.value) && !(\"asBytes\" in decoded.value))\n              )\n                throw null\n              return decoded\n            } catch {\n              throw new Error(\n                `Unexpected RuntimeCall(${RUNTIME_CALL_NAME}) type`,\n              )\n            }\n          }),\n          map(({ success, value }) => {\n            if (!success) throw new Error(`ViewFn API Error: ${value.type}`)\n            const decoded = viewCodec.value.dec(value.asBytes())\n            if (!valuesAreCompatible(runtime, ctx, decoded))\n              throw compatibilityError()\n            return decoded\n          }),\n        )\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { getCompatibilityLevel, isCompatible })\n}\n", "import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport {\n  enumValueEntryPointNode,\n  runtimeCallEntryPoint,\n  singleValueEntryPoint,\n  storageEntryPoint,\n  voidEntryPointNode,\n} from \"@polkadot-api/metadata-compatibility\"\nimport {\n  ChainHead$,\n  RuntimeContext,\n  getObservableClient,\n} from \"@polkadot-api/observable-client\"\nimport { Binary, HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  catchError,\n  defer,\n  firstValueFrom,\n  from,\n  map,\n  shareReplay,\n} from \"rxjs\"\nimport {\n  CompatibilityToken,\n  OpType,\n  RuntimeToken,\n  compatibilityHelper,\n  createCompatibilityToken,\n  createRuntimeToken,\n  getCompatibilityApi,\n} from \"./compatibility\"\nimport { createConstantEntry } from \"./constants\"\nimport { ChainDefinition } from \"./descriptors\"\nimport { createEventEntry } from \"./event\"\nimport { createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry } from \"./storage\"\nimport { createTxEntry, submit, submit$ } from \"./tx\"\nimport type { AnyApi, PolkadotClient } from \"./types\"\nimport { createWatchEntries } from \"./watch-entries\"\nimport { createViewFnEntry } from \"./viewFns\"\n\nconst createApi = <Unsafe extends true | false, D>(\n  compatibilityToken: Promise<CompatibilityToken | RuntimeToken>,\n  chainHead: ChainHead$,\n  broadcast$: (tx: string) => Observable<never>,\n): AnyApi<Unsafe, D> => {\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const getPallet = (ctx: RuntimeContext, name: string) =>\n    ctx.lookup.metadata.pallets.find((p) => p.name === name)\n\n  const getWatchEntries = createWatchEntries(\n    chainHead.pinnedBlocks$,\n    chainHead.storage$,\n    chainHead.withRuntime,\n  )\n  const query = createProxyPath((pallet, name) =>\n    createStorageEntry(\n      pallet,\n      name,\n      chainHead,\n      getWatchEntries,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Storage, pallet, name),\n        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.storage?.items.find(\n            (s) => s.name === name,\n          )\n          return item == null ? null : storageEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const getEnumEntry = (\n    ctx: RuntimeContext,\n    side: \"args\" | \"values\",\n    id: number | undefined,\n    name: string,\n  ) => {\n    if (id == null) return null\n    const entry = ctx.lookup(id)\n    if (entry.type !== \"enum\") throw new Error(\"Expected enum\")\n\n    if (entry.value[name] == null) return null\n    const node = enumValueEntryPointNode(entry.value[name])\n    return {\n      args: side === \"args\" ? node : voidEntryPointNode,\n      values: side === \"args\" ? voidEntryPointNode : node,\n    }\n  }\n  const tx = createProxyPath((pallet, name) =>\n    createTxEntry(\n      pallet,\n      name,\n      chainHead,\n      broadcast$,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Tx, pallet, name),\n        (ctx) =>\n          getEnumEntry(ctx, \"args\", getPallet(ctx, pallet)?.calls?.type, name),\n      ),\n      true,\n    ),\n  )\n\n  const event = createProxyPath((pallet, name) =>\n    createEventEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Event, pallet, name),\n        (ctx) =>\n          getEnumEntry(\n            ctx,\n            \"values\",\n            getPallet(ctx, pallet)?.events?.type,\n            name,\n          ),\n      ),\n    ),\n  )\n\n  const constants = createProxyPath((pallet, name) =>\n    createConstantEntry(\n      pallet,\n      name,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Const, pallet, name),\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.constants.find(\n            (c) => c.name === name,\n          )?.type\n          return item == null ? null : singleValueEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const apis = createProxyPath((api, method) =>\n    createRuntimeCallEntry(\n      api,\n      method,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Api, api, method),\n        (ctx) =>\n          runtimeCallEntryPoint(\n            ctx.lookup.metadata.apis\n              .find((a) => a.name === api)!\n              .methods.find((m) => m.name === method)!,\n          ),\n      ),\n    ),\n  )\n  const view = createProxyPath((pallet, entry) =>\n    createViewFnEntry(\n      pallet,\n      entry,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.ViewFns, pallet, entry),\n        (ctx) =>\n          runtimeCallEntryPoint(\n            ctx.lookup.metadata.pallets\n              .find((a) => a.name === pallet)!\n              .viewFns.find((m) => m.name === entry)!,\n          ),\n      ),\n    ),\n  )\n\n  const _callDataTx = (\n    callData: Binary,\n    token: CompatibilityToken | RuntimeToken,\n  ) => {\n    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime()\n    try {\n      const decoded = dynamicBuilder\n        .buildDefinition(lookup.call!)\n        .dec(callData.asBytes())\n      const pallet = decoded.type\n      const call = decoded.value.type\n      const args = decoded.value.value\n\n      return createTxEntry(\n        pallet,\n        call,\n        chainHead,\n        broadcast$,\n        compatibilityHelper(\n          compatibilityToken,\n          (r) => r.getEntryPoint(OpType.Tx, pallet, call),\n          (ctx) =>\n            getEnumEntry(\n              ctx,\n              \"args\",\n              getPallet(ctx, pallet)?.calls?.type,\n              call,\n            ),\n        ),\n        false,\n      )(args)\n    } catch {\n      throw new Error(\"createTx: invalid call data\")\n    }\n  }\n\n  return {\n    query,\n    txFromCallData: (\n      callData: Binary,\n      token?: CompatibilityToken | RuntimeToken,\n    ) =>\n      token\n        ? _callDataTx(callData, token)\n        : compatibilityToken.then((t) => _callDataTx(callData, t)),\n    tx,\n    event,\n    apis,\n    constants,\n    view,\n  } as any\n}\n\nexport type CreateClientOptions = Partial<{\n  getMetadata: (codeHash: HexString) => Promise<Uint8Array | null>\n  setMetadata: (codeHash: HexString, metadata: Uint8Array) => void\n}>\n\n/**\n * This is the top-level export for `polkadot-api`.\n *\n * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC\n *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),\n *                  which must support the `chainHead`, `transaction` and\n *                  `chainSpec` groups.\n * @param options   - *(Optional)* An object that allows customization of\n *                  metadata handling.\n *                  You can supply functions to retrieve and/or persist the\n *                  metadata associated with runtime `codeHash` values:\n *\n *                  - `getMetadata`: A function that, given a `codeHash` (the\n *                  `:code:` hash),\n *                  returns a `Promise` resolving to a `Uint8Array`\n *                  representing the metadata,\n *                  or `null` if unavailable.\n *                  - `setMetadata`: A function that accepts a `codeHash` and\n *                  its associated `Uint8Array` metadata,\n *                  allowing you to persist the metadata (e.g., in a cache or\n *                  local store).\n * @example\n *\n *   import { getMetadata } from \"@polkadot-api/descriptors\"\n *   import { createClient } from \"polkadot-api\"\n *   import { getSmProvider } from \"polkadot-api/sm-provider\"\n *   import { chainSpec } from \"polkadot-api/chains/polkadot\"\n *   import { start } from \"polkadot-api/smoldot\"\n *\n *   const smoldot = start()\n *   const chain = await smoldot.addChain({ chainSpec })\n *\n *   // Connect to the polkadot relay chain.\n *   const client = createClient(getSmProvider(chain), { getMetadata })\n *\n */\nexport function createClient(\n  provider: JsonRpcProvider,\n  { getMetadata, setMetadata }: CreateClientOptions = {},\n): PolkadotClient {\n  const rawClient: SubstrateClient = createRawClient(provider)\n  const client = getObservableClient(rawClient, {\n    getMetadata: getMetadata\n      ? (codeHash: string) => from(getMetadata(codeHash))\n      : undefined,\n    setMetadata,\n  })\n  const { getChainSpecData } = rawClient\n\n  const { genesis$, ..._chainHead } = client.chainHead$()\n  const chainHead: ChainHead$ = {\n    ..._chainHead,\n    genesis$: defer(getChainSpecData).pipe(\n      map(({ genesisHash }) => genesisHash),\n      catchError(() => genesis$),\n      shareReplay(1),\n    ),\n  }\n\n  const _request: <Reply = any, Params extends Array<any> = any[]>(\n    method: string,\n    params: Params,\n  ) => Promise<Reply> = rawClient.request\n\n  let runtimeToken: Promise<RuntimeToken>\n  const compatibilityToken = new WeakMap<\n    ChainDefinition,\n    Promise<CompatibilityToken<any>>\n  >()\n  const getChainToken = (chainDefinition: ChainDefinition) => {\n    const result =\n      compatibilityToken.get(chainDefinition) ||\n      createCompatibilityToken(chainDefinition, chainHead)\n    compatibilityToken.set(chainDefinition, result)\n    return result\n  }\n  const getRuntimeToken = <D>(): Promise<RuntimeToken<D>> =>\n    (runtimeToken ??= createRuntimeToken(chainHead))\n  const { broadcastTx$ } = client\n  return {\n    getChainSpecData,\n\n    blocks$: chainHead.newBlocks$,\n\n    finalizedBlock$: chainHead.finalized$,\n    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),\n\n    bestBlocks$: chainHead.bestBlocks$,\n    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),\n\n    watchBlockBody: chainHead.body$,\n    getBlockBody: (hash: string) => firstValueFrom(chainHead.body$(hash)),\n\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n\n    submit: (...args) => submit(chainHead, broadcastTx$, ...args),\n    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),\n\n    getTypedApi: <D extends ChainDefinition>(chainDefinition: D) => {\n      const token = getChainToken(chainDefinition)\n      return Object.assign(\n        createApi<false, D>(token, chainHead, broadcastTx$),\n        { compatibilityToken: token },\n      )\n    },\n\n    getUnsafeApi: <D>() => {\n      const token = getRuntimeToken()\n      return Object.assign(createApi<true, D>(token, chainHead, broadcastTx$), {\n        runtimeToken: token,\n      })\n    },\n\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n\n    _request,\n  }\n}\n"],
  "mappings": "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",
  "names": ["value", "value", "destNode", "terminal", "CompatibilityLevel", "result", "originNode", "destNode", "value", "maxLevel", "lengthCheck", "value", "noop", "noop", "noop", "fn", "noop", "noop", "noop", "__publicField", "subscriptionId", "createClient", "createRawClient", "cached", "__publicField", "value", "value", "chainHead", "metadataCodec", "metadata", "value", "hash", "value", "chainHead", "value", "transaction", "clientCache", "cached", "value", "OpType", "chainHead", "descriptors", "isCompatible", "isCompatible", "value", "shareLatest", "chainHead", "isCompatible", "shareLatest", "filter", "value", "chainHead", "isCompatible", "value", "chainHead", "isCompatible", "value", "metadata", "additionalSigned", "value", "value", "additionalSigned", "key", "from", "chainHead", "value", "value", "__publicField", "chainHead", "at", "transaction", "chainHead", "arg", "from", "EMPTY_VALUE", "value", "__publicField", "external", "value", "state", "chainHead", "isCompatible", "value", "chainHead", "createClient", "createRawClient"]
}
