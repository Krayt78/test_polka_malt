{
  "version": 3,
  "sources": ["../../.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/config.ts", "../../.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/query-builder.ts", "../../.pnpm/@reactive-dot+core@0.40.4_polkadot-api@1.12.2_jiti@2.4.2_postcss@8.5.4_rxjs@7.8.2_/node_modules/@reactive-dot/core/src/symbols.ts"],
  "sourcesContent": ["import type { LightClientProvider } from \"./providers/light-client/provider.js\";\nimport type { Gettable } from \"./types.js\";\nimport type { Wallet, WalletProvider } from \"./wallets/index.js\";\nimport type { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\";\nimport type { ChainDefinition } from \"polkadot-api\";\n\nexport type ChainConfig = {\n  readonly descriptor: ChainDefinition;\n  readonly provider: Gettable<JsonRpcProvider | LightClientProvider>;\n};\n\nexport type Config<\n  TChains extends Readonly<Record<string, ChainConfig>> = Readonly<\n    Record<string, ChainConfig>\n  >,\n  TTargetChainIds extends ReadonlyArray<\n    Extract<keyof TChains, string>\n  > = ReadonlyArray<Extract<keyof TChains, string>>,\n> = {\n  readonly chains: TChains;\n  readonly targetChains?: TTargetChainIds;\n  readonly wallets?: ReadonlyArray<WalletProvider | Wallet>;\n};\n\nexport function defineConfig<\n  const TChains extends Readonly<Record<string, ChainConfig>>,\n  const TTargetChainIds extends ReadonlyArray<Extract<keyof TChains, string>>,\n>(config: Config<TChains, TTargetChainIds>) {\n  return config;\n}\n", "import type { CommonDescriptor } from \"./chains.js\";\nimport type { Flatten, StringKeyOf } from \"./types.js\";\nimport type { ChainDefinition, TypedApi } from \"polkadot-api\";\nimport type { Observable } from \"rxjs\";\n\ntype PapiCallOptions = Partial<{\n  at: string;\n  signal: AbortSignal;\n}>;\n\ntype OmitCallOptions<T extends readonly unknown[]> = T extends [\n  infer Head,\n  ...infer Tail,\n]\n  ? [Head] extends [PapiCallOptions]\n    ? OmitCallOptions<Tail>\n    : [Head, ...OmitCallOptions<Tail>]\n  : [];\n\ntype InferPapiStorageEntry<T> = T extends {\n  watchValue: (...args: [...infer Args, infer _]) => infer Response;\n}\n  ? { args: Args; response: Response }\n  : { args: unknown[]; response: unknown };\n\ntype InferPapiStorageEntries<T> = T extends {\n  getEntries: (\n    ...args: infer Args\n  ) => Promise<Array<{ keyArgs: infer Key; value: infer Value }>>;\n}\n  ? {\n      args: OmitCallOptions<Args>;\n      response: Promise<\n        Array<\n          [Key, Value] & {\n            /** @deprecated Use index access instead. */\n            keyArgs: Key;\n            /** @deprecated Use index access instead. */\n            value: Value;\n          }\n        >\n      >;\n    }\n  : { args: unknown[]; response: unknown };\n\ntype InferPapiRuntimeCall<T> = T extends (...args: infer Args) => infer Response\n  ? { args: OmitCallOptions<Args>; response: Response }\n  : { args: unknown[]; response: unknown };\n\ntype InferPapiConstantEntry<T> = T extends {\n  (): Promise<infer Payload>;\n  (runtime: infer _): infer Payload;\n}\n  ? Promise<Payload>\n  : unknown;\n\ntype Finality = \"best\" | \"finalized\";\n\ntype At = Finality | `0x${string}`;\n\ntype BaseInstruction<T extends string> = {\n  instruction: T;\n};\n\nexport type ConstantFetchInstruction<\n  TPallet extends string = string,\n  TConstant extends string = string,\n> = BaseInstruction<\"get-constant\"> & {\n  pallet: TPallet;\n  constant: TConstant;\n};\n\nexport type StorageReadInstruction<\n  TPallet extends string = string,\n  TStorage extends string = string,\n  TArguments extends unknown[] = unknown[],\n> = BaseInstruction<\"read-storage\"> & {\n  pallet: TPallet;\n  storage: TStorage;\n  args: TArguments;\n  at: At | undefined;\n};\n\nexport type StorageEntriesReadInstruction<\n  TPallet extends string = string,\n  TStorage extends string = string,\n  TArguments extends unknown[] = unknown[],\n> = BaseInstruction<\"read-storage-entries\"> & {\n  pallet: TPallet;\n  storage: TStorage;\n  args: TArguments;\n  at: At | undefined;\n};\n\nexport type ApiCallInstruction<\n  TPallet extends string = string,\n  TApi extends string = string,\n  TArguments extends unknown[] = unknown[],\n> = BaseInstruction<\"call-api\"> & {\n  pallet: TPallet;\n  api: TApi;\n  args: TArguments;\n  at: Finality | undefined;\n};\n\nexport type MultiInstruction<\n  TInstruction extends BaseInstruction<string> & { args: unknown[] },\n> = Omit<TInstruction, \"args\"> & {\n  multi: true;\n  args: unknown[][];\n};\n\nexport type QueryInstruction =\n  | ConstantFetchInstruction\n  | StorageReadInstruction\n  | MultiInstruction<StorageReadInstruction>\n  | StorageEntriesReadInstruction\n  | ApiCallInstruction\n  | MultiInstruction<ApiCallInstruction>;\n\ntype ConstantFetchPayload<\n  TInstruction extends ConstantFetchInstruction,\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> = InferPapiConstantEntry<\n  TypedApi<TDescriptor>[\"constants\"][TInstruction[\"pallet\"]][TInstruction[\"constant\"]]\n>;\n\ntype StorageReadResponse<\n  TInstruction extends\n    | StorageReadInstruction\n    | MultiInstruction<StorageReadInstruction>,\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> = InferPapiStorageEntry<\n  TypedApi<TDescriptor>[\"query\"][TInstruction[\"pallet\"]][TInstruction[\"storage\"]]\n>[\"response\"];\n\ntype StorageEntriesReadResponse<\n  TInstruction extends StorageEntriesReadInstruction,\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> = InferPapiStorageEntries<\n  TypedApi<TDescriptor>[\"query\"][TInstruction[\"pallet\"]][TInstruction[\"storage\"]]\n>[\"response\"];\n\ntype ApiCallResponse<\n  TInstruction extends\n    | ApiCallInstruction\n    | MultiInstruction<ApiCallInstruction>,\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> = InferPapiRuntimeCall<\n  TypedApi<TDescriptor>[\"apis\"][TInstruction[\"pallet\"]][TInstruction[\"api\"]]\n>[\"response\"];\n\nexport type InferInstructionResponse<\n  TInstruction extends QueryInstruction,\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> = TInstruction extends ConstantFetchInstruction\n  ? ConstantFetchPayload<TInstruction, TDescriptor>\n  : TInstruction extends MultiInstruction<StorageReadInstruction>\n    ? Array<StorageReadResponse<TInstruction, TDescriptor>>\n    : TInstruction extends StorageReadInstruction\n      ? StorageReadResponse<TInstruction, TDescriptor>\n      : TInstruction extends StorageEntriesReadInstruction\n        ? StorageEntriesReadResponse<TInstruction, TDescriptor>\n        : TInstruction extends MultiInstruction<ApiCallInstruction>\n          ? Array<ApiCallResponse<TInstruction, TDescriptor>>\n          : TInstruction extends ApiCallInstruction\n            ? ApiCallResponse<TInstruction, TDescriptor>\n            : never;\n\ntype ResponsePayload<T> =\n  T extends Promise<infer Payload>\n    ? Payload\n    : T extends Observable<infer Payload>\n      ? Payload\n      : T extends Array<infer Element>\n        ? Array<ResponsePayload<Element>>\n        : unknown;\n\nexport type InferInstructionPayload<\n  TInstruction extends QueryInstruction,\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> = ResponsePayload<InferInstructionResponse<TInstruction, TDescriptor>>;\n\nexport type InferInstructionsResponse<\n  TInstructions extends readonly QueryInstruction[],\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> = {\n  [P in keyof TInstructions]: InferInstructionResponse<\n    TInstructions[P],\n    TDescriptor\n  >;\n};\n\nexport type InferInstructionsPayload<\n  TInstructions extends readonly QueryInstruction[],\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> = {\n  [P in keyof TInstructions]: InferInstructionPayload<\n    TInstructions[P],\n    TDescriptor\n  >;\n};\n\nexport type InferQueryResponse<T extends Query> =\n  T extends Query<infer Instructions, infer Descriptor>\n    ? InferInstructionsResponse<Instructions, Descriptor>\n    : never;\n\nexport type InferQueryPayload<T extends Query> =\n  T extends Query<infer Instructions, infer Descriptor>\n    ? InferInstructionsPayload<Instructions, Descriptor>\n    : never;\n\nexport class Query<\n  const TInstructions extends\n    readonly QueryInstruction[] = readonly QueryInstruction[],\n  TDescriptor extends ChainDefinition = CommonDescriptor,\n> {\n  readonly #instructions: TInstructions;\n\n  constructor(\n    instructions: TInstructions = [] as readonly QueryInstruction[] as TInstructions,\n  ) {\n    this.#instructions = instructions;\n  }\n\n  get instructions() {\n    return Object.freeze(this.#instructions.slice());\n  }\n\n  constant<\n    TPallet extends StringKeyOf<TypedApi<TDescriptor>[\"constants\"]>,\n    TConstant extends StringKeyOf<TypedApi<TDescriptor>[\"constants\"][TPallet]>,\n  >(pallet: TPallet, constant: TConstant) {\n    return this.#append({\n      instruction: \"get-constant\",\n      pallet,\n      constant,\n    });\n  }\n\n  /**\n   * @deprecated Use {@link Query.constant} instead.\n   */\n  getConstant = this.constant;\n\n  storage<\n    TPallet extends StringKeyOf<TypedApi<TDescriptor>[\"query\"]>,\n    TStorage extends StringKeyOf<TypedApi<TDescriptor>[\"query\"][TPallet]>,\n    TArguments extends InferPapiStorageEntry<\n      TypedApi<TDescriptor>[\"query\"][TPallet][TStorage]\n    >[\"args\"],\n  >(\n    pallet: TPallet,\n    storage: TStorage,\n    ...argsAndOptions: TArguments extends []\n      ? [args?: TArguments, options?: { at?: At }]\n      : [args: TArguments, options?: { at?: At }]\n  ) {\n    const [args, options] = argsAndOptions as [\n      TArguments | undefined,\n      { at?: At } | undefined,\n    ];\n\n    return this.#append({\n      instruction: \"read-storage\",\n      pallet,\n      storage,\n      args: args ?? [],\n      at: options?.at,\n    });\n  }\n\n  /**\n   * @deprecated Use {@link Query.storage} instead.\n   */\n  readStorage = this.storage;\n\n  storages<\n    TPallet extends StringKeyOf<TypedApi<TDescriptor>[\"query\"]>,\n    TStorage extends StringKeyOf<TypedApi<TDescriptor>[\"query\"][TPallet]>,\n    TArguments extends InferPapiStorageEntry<\n      TypedApi<TDescriptor>[\"query\"][TPallet][TStorage]\n    >[\"args\"],\n  >(\n    pallet: TPallet,\n    storage: TStorage,\n    args: TArguments[],\n    options?: { at?: At },\n  ) {\n    return this.#append({\n      instruction: \"read-storage\",\n      pallet,\n      storage,\n      args,\n      at: options?.at,\n      multi: true,\n    });\n  }\n\n  /**\n   * @deprecated Use {@link Query.storages} instead.\n   */\n  readStorages = this.storages;\n\n  storageEntries<\n    TPallet extends StringKeyOf<TypedApi<TDescriptor>[\"query\"]>,\n    TStorage extends StringKeyOf<TypedApi<TDescriptor>[\"query\"][TPallet]>,\n    TArguments extends InferPapiStorageEntries<\n      TypedApi<TDescriptor>[\"query\"][TPallet][TStorage]\n    >[\"args\"],\n  >(\n    pallet: TPallet,\n    storage: TStorage,\n    args?: TArguments,\n    options?: { at?: At },\n  ) {\n    return this.#append({\n      instruction: \"read-storage-entries\",\n      pallet,\n      storage,\n      args: args ?? [],\n      at: options?.at,\n    });\n  }\n\n  /**\n   * @deprecated Use {@link Query.storageEntries} instead.\n   */\n  readStorageEntries = this.storageEntries;\n\n  runtimeApi<\n    TPallet extends StringKeyOf<TypedApi<TDescriptor>[\"apis\"]>,\n    TApi extends StringKeyOf<TypedApi<TDescriptor>[\"apis\"][TPallet]>,\n    TArguments extends InferPapiRuntimeCall<\n      TypedApi<TDescriptor>[\"apis\"][TPallet][TApi]\n    >[\"args\"],\n  >(\n    pallet: TPallet,\n    api: TApi,\n    ...argsAndOptions: TArguments extends []\n      ? [args?: TArguments, options?: { at?: Finality }]\n      : [args: TArguments, options?: { at?: Finality }]\n  ) {\n    const [args, options] = argsAndOptions as [\n      TArguments | undefined,\n      { at?: Finality } | undefined,\n    ];\n\n    return this.#append({\n      instruction: \"call-api\",\n      pallet,\n      api,\n      args: args ?? [],\n      at: options?.at,\n    });\n  }\n\n  /**\n   * @deprecated Use {@link Query.runtimeApi} instead.\n   */\n  callApi = this.runtimeApi;\n\n  runtimeApis<\n    TPallet extends StringKeyOf<TypedApi<TDescriptor>[\"apis\"]>,\n    TApi extends StringKeyOf<TypedApi<TDescriptor>[\"apis\"][TPallet]>,\n    TArguments extends InferPapiRuntimeCall<\n      TypedApi<TDescriptor>[\"apis\"][TPallet][TApi]\n    >[\"args\"],\n  >(\n    pallet: TPallet,\n    api: TApi,\n    args: TArguments[],\n    options?: { at?: Finality },\n  ) {\n    return this.#append({\n      instruction: \"call-api\",\n      pallet,\n      api,\n      args,\n      at: options?.at,\n      multi: true,\n    });\n  }\n\n  /**\n   * @deprecated Use {@link Query.runtimeApis} instead.\n   */\n  callApis = this.runtimeApis;\n\n  concat<TQueries extends Query[]>(...queries: TQueries) {\n    return new Query(\n      this.#instructions.concat(...queries.map((query) => query.#instructions)),\n    ) as Query<\n      // @ts-expect-error TODO: fix this\n      [\n        ...TInstructions,\n        ...Flatten<{\n          [P in keyof TQueries]: TQueries[P] extends Query<\n            infer Instructions,\n            infer _\n          >\n            ? Instructions\n            : never;\n        }>,\n      ],\n      TDescriptor\n    >;\n  }\n\n  #append<const TInstruction extends QueryInstruction>(\n    instruction: TInstruction,\n  ) {\n    return new Query([...this.#instructions, instruction]) as Query<\n      [...TInstructions, TInstruction],\n      TDescriptor\n    >;\n  }\n}\n", "export const idle = Symbol(\"idle\");\n\nexport const pending = Symbol(\"pending\");\n"],
  "mappings": ";;;;;;;;;AAwBM,SAAU,aAGd,QAAwC;AACxC,SAAO;AACT;;;ACwLA;AAAM,IAAO,SAAP,MAAO,OAAK;EAOhB,YACE,eAA8B,CAAA,GAAkD;AAR9E;AAKK;AA0BT;;;uCAAc,KAAK;AAgCnB;;;uCAAc,KAAK;AA2BnB;;;wCAAe,KAAK;AA0BpB;;;8CAAqB,KAAK;AAgC1B;;;mCAAU,KAAK;AA2Bf;;;oCAAW,KAAK;AArKd,uBAAK,eAAgB;EACvB;EAEA,IAAI,eAAY;AACd,WAAO,OAAO,OAAO,mBAAK,eAAc,MAAK,CAAE;EACjD;EAEA,SAGE,QAAiB,UAAmB;AACpC,WAAO,sBAAK,6BAAL,WAAa;MAClB,aAAa;MACb;MACA;;EAEJ;EAOA,QAOE,QACA,YACG,gBAE0C;AAE7C,UAAM,CAAC,MAAM,OAAO,IAAI;AAKxB,WAAO,sBAAK,6BAAL,WAAa;MAClB,aAAa;MACb;MACA;MACA,MAAM,QAAQ,CAAA;MACd,IAAI,mCAAS;;EAEjB;EAOA,SAOE,QACA,SACA,MACA,SAAqB;AAErB,WAAO,sBAAK,6BAAL,WAAa;MAClB,aAAa;MACb;MACA;MACA;MACA,IAAI,mCAAS;MACb,OAAO;;EAEX;EAOA,eAOE,QACA,SACA,MACA,SAAqB;AAErB,WAAO,sBAAK,6BAAL,WAAa;MAClB,aAAa;MACb;MACA;MACA,MAAM,QAAQ,CAAA;MACd,IAAI,mCAAS;;EAEjB;EAOA,WAOE,QACA,QACG,gBAEgD;AAEnD,UAAM,CAAC,MAAM,OAAO,IAAI;AAKxB,WAAO,sBAAK,6BAAL,WAAa;MAClB,aAAa;MACb;MACA;MACA,MAAM,QAAQ,CAAA;MACd,IAAI,mCAAS;;EAEjB;EAOA,YAOE,QACA,KACA,MACA,SAA2B;AAE3B,WAAO,sBAAK,6BAAL,WAAa;MAClB,aAAa;MACb;MACA;MACA;MACA,IAAI,mCAAS;MACb,OAAO;;EAEX;EAOA,UAAoC,SAAiB;AACnD,WAAO,IAAI,OACT,mBAAK,eAAc,OAAO,GAAG,QAAQ,IAAI,CAACA,WAAU,aAAAA,QAAM,cAAa,CAAC,CAAC;EAgB7E;;AA9LS;AALL;AAqMJ,YAAO,SACL,aAAyB;AAEzB,SAAO,IAAI,OAAM,CAAC,GAAG,mBAAK,gBAAe,WAAW,CAAC;AAIvD;AA5MI,IAAO,QAAP;;;ACrNC,IAAM,OAAO,OAAO,MAAM;AAE1B,IAAM,UAAU,OAAO,SAAS;",
  "names": ["query"]
}
